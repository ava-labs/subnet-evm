// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package contracts

import (
	"errors"
	"math/big"
	"strings"

	"github.com/ava-labs/subnet-evm/accounts/abi"
	"github.com/ava-labs/subnet-evm/accounts/abi/bind"
	"github.com/ava-labs/subnet-evm/core/types"
	"github.com/ava-labs/subnet-evm/interfaces"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = interfaces.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// FeeConfig is an auto generated low-level Go binding around an user-defined struct.
type FeeConfig struct {
	GasLimit                 *big.Int
	TargetBlockRate          *big.Int
	MinBaseFee               *big.Int
	TargetGas                *big.Int
	BaseFeeChangeDenominator *big.Int
	MinBlockGasCost          *big.Int
	MaxBlockGasCost          *big.Int
	BlockGasCostStep         *big.Int
}

// IFeeManagerFeeConfig is an auto generated low-level Go binding around an user-defined struct.
type IFeeManagerFeeConfig struct {
	GasLimit                 *big.Int
	TargetBlockRate          *big.Int
	MinBaseFee               *big.Int
	TargetGas                *big.Int
	BaseFeeChangeDenominator *big.Int
	MinBlockGasCost          *big.Int
	MaxBlockGasCost          *big.Int
	BlockGasCostStep         *big.Int
}

// WarpBlockHash is an auto generated low-level Go binding around an user-defined struct.
type WarpBlockHash struct {
	SourceChainID [32]byte
	BlockHash     [32]byte
}

// WarpMessage is an auto generated low-level Go binding around an user-defined struct.
type WarpMessage struct {
	SourceChainID       [32]byte
	OriginSenderAddress common.Address
	Payload             []byte
}

// AllowListMetaData contains all meta data concerning the AllowList contract.
var AllowListMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"precompileAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"revoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x608060405234801561001057600080fd5b50604051610dfb380380610dfb833981810160405281019061003291906101c4565b61004e61004361009560201b60201c565b61009d60201b60201c565b80600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550506101f1565b600033905090565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061019182610166565b9050919050565b6101a181610186565b81146101ac57600080fd5b50565b6000815190506101be81610198565b92915050565b6000602082840312156101da576101d9610161565b5b60006101e8848285016101af565b91505092915050565b610bfb806102006000396000f3fe608060405234801561001057600080fd5b506004361061009e5760003560e01c80638da5cb5b116100665780638da5cb5b146101315780639015d3711461014f578063d0ebdbe71461017f578063f2fde38b1461019b578063f3ae2415146101b75761009e565b80630aaf7043146100a357806324d7806c146100bf578063704b6c02146100ef578063715018a61461010b57806374a8f10314610115575b600080fd5b6100bd60048036038101906100b8919061095a565b6101e7565b005b6100d960048036038101906100d4919061095a565b6101fb565b6040516100e691906109a2565b60405180910390f35b6101096004803603810190610104919061095a565b6102a8565b005b6101136102bc565b005b61012f600480360381019061012a919061095a565b6102d0565b005b6101396102e4565b60405161014691906109cc565b60405180910390f35b6101696004803603810190610164919061095a565b61030d565b60405161017691906109a2565b60405180910390f35b6101996004803603810190610194919061095a565b6103bb565b005b6101b560048036038101906101b0919061095a565b6103cf565b005b6101d160048036038101906101cc919061095a565b610452565b6040516101de91906109a2565b60405180910390f35b6101ef6104ff565b6101f88161057d565b50565b600080600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b815260040161025991906109cc565b602060405180830381865afa158015610276573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061029a9190610a1d565b905060028114915050919050565b6102b06104ff565b6102b98161060d565b50565b6102c46104ff565b6102ce600061069d565b565b6102d86104ff565b6102e181610761565b50565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b600080600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b815260040161036b91906109cc565b602060405180830381865afa158015610388573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103ac9190610a1d565b90506000811415915050919050565b6103c36104ff565b6103cc8161085f565b50565b6103d76104ff565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603610446576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161043d90610acd565b60405180910390fd5b61044f8161069d565b50565b600080600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b81526004016104b091906109cc565b602060405180830381865afa1580156104cd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104f19190610a1d565b905060038114915050919050565b6105076108ef565b73ffffffffffffffffffffffffffffffffffffffff166105256102e4565b73ffffffffffffffffffffffffffffffffffffffff161461057b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161057290610b39565b60405180910390fd5b565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043826040518263ffffffff1660e01b81526004016105d891906109cc565b600060405180830381600087803b1580156105f257600080fd5b505af1158015610606573d6000803e3d6000fd5b5050505050565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663704b6c02826040518263ffffffff1660e01b815260040161066891906109cc565b600060405180830381600087803b15801561068257600080fd5b505af1158015610696573d6000803e3d6000fd5b5050505050565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b8073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16036107cf576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016107c690610ba5565b60405180910390fd5b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638c6bfb3b826040518263ffffffff1660e01b815260040161082a91906109cc565b600060405180830381600087803b15801561084457600080fd5b505af1158015610858573d6000803e3d6000fd5b5050505050565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d0ebdbe7826040518263ffffffff1660e01b81526004016108ba91906109cc565b600060405180830381600087803b1580156108d457600080fd5b505af11580156108e8573d6000803e3d6000fd5b5050505050565b600033905090565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610927826108fc565b9050919050565b6109378161091c565b811461094257600080fd5b50565b6000813590506109548161092e565b92915050565b6000602082840312156109705761096f6108f7565b5b600061097e84828501610945565b91505092915050565b60008115159050919050565b61099c81610987565b82525050565b60006020820190506109b76000830184610993565b92915050565b6109c68161091c565b82525050565b60006020820190506109e160008301846109bd565b92915050565b6000819050919050565b6109fa816109e7565b8114610a0557600080fd5b50565b600081519050610a17816109f1565b92915050565b600060208284031215610a3357610a326108f7565b5b6000610a4184828501610a08565b91505092915050565b600082825260208201905092915050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160008201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b6000610ab7602683610a4a565b9150610ac282610a5b565b604082019050919050565b60006020820190508181036000830152610ae681610aaa565b9050919050565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572600082015250565b6000610b23602083610a4a565b9150610b2e82610aed565b602082019050919050565b60006020820190508181036000830152610b5281610b16565b9050919050565b7f63616e6e6f74207265766f6b65206f776e20726f6c6500000000000000000000600082015250565b6000610b8f601683610a4a565b9150610b9a82610b59565b602082019050919050565b60006020820190508181036000830152610bbe81610b82565b905091905056fea26469706673582212201beef4f49d5a4c7dcd08b240ea631c993e960714febef7d2619a467ef638df3064736f6c634300081a0033",
}

// AllowListABI is the input ABI used to generate the binding from.
// Deprecated: Use AllowListMetaData.ABI instead.
var AllowListABI = AllowListMetaData.ABI

// AllowListBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use AllowListMetaData.Bin instead.
var AllowListBin = AllowListMetaData.Bin

// DeployAllowList deploys a new Ethereum contract, binding an instance of AllowList to it.
func DeployAllowList(auth *bind.TransactOpts, backend bind.ContractBackend, precompileAddr common.Address) (common.Address, *types.Transaction, *AllowList, error) {
	parsed, err := AllowListMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(AllowListBin), backend, precompileAddr)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &AllowList{AllowListCaller: AllowListCaller{contract: contract}, AllowListTransactor: AllowListTransactor{contract: contract}, AllowListFilterer: AllowListFilterer{contract: contract}}, nil
}

// AllowList is an auto generated Go binding around an Ethereum contract.
type AllowList struct {
	AllowListCaller     // Read-only binding to the contract
	AllowListTransactor // Write-only binding to the contract
	AllowListFilterer   // Log filterer for contract events
}

// AllowListCaller is an auto generated read-only Go binding around an Ethereum contract.
type AllowListCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AllowListTransactor is an auto generated write-only Go binding around an Ethereum contract.
type AllowListTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AllowListFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type AllowListFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AllowListSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type AllowListSession struct {
	Contract     *AllowList        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// AllowListCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type AllowListCallerSession struct {
	Contract *AllowListCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// AllowListTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type AllowListTransactorSession struct {
	Contract     *AllowListTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// AllowListRaw is an auto generated low-level Go binding around an Ethereum contract.
type AllowListRaw struct {
	Contract *AllowList // Generic contract binding to access the raw methods on
}

// AllowListCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type AllowListCallerRaw struct {
	Contract *AllowListCaller // Generic read-only contract binding to access the raw methods on
}

// AllowListTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type AllowListTransactorRaw struct {
	Contract *AllowListTransactor // Generic write-only contract binding to access the raw methods on
}

// NewAllowList creates a new instance of AllowList, bound to a specific deployed contract.
func NewAllowList(address common.Address, backend bind.ContractBackend) (*AllowList, error) {
	contract, err := bindAllowList(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &AllowList{AllowListCaller: AllowListCaller{contract: contract}, AllowListTransactor: AllowListTransactor{contract: contract}, AllowListFilterer: AllowListFilterer{contract: contract}}, nil
}

// NewAllowListCaller creates a new read-only instance of AllowList, bound to a specific deployed contract.
func NewAllowListCaller(address common.Address, caller bind.ContractCaller) (*AllowListCaller, error) {
	contract, err := bindAllowList(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &AllowListCaller{contract: contract}, nil
}

// NewAllowListTransactor creates a new write-only instance of AllowList, bound to a specific deployed contract.
func NewAllowListTransactor(address common.Address, transactor bind.ContractTransactor) (*AllowListTransactor, error) {
	contract, err := bindAllowList(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &AllowListTransactor{contract: contract}, nil
}

// NewAllowListFilterer creates a new log filterer instance of AllowList, bound to a specific deployed contract.
func NewAllowListFilterer(address common.Address, filterer bind.ContractFilterer) (*AllowListFilterer, error) {
	contract, err := bindAllowList(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &AllowListFilterer{contract: contract}, nil
}

// bindAllowList binds a generic wrapper to an already deployed contract.
func bindAllowList(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := AllowListMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AllowList *AllowListRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AllowList.Contract.AllowListCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AllowList *AllowListRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AllowList.Contract.AllowListTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AllowList *AllowListRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AllowList.Contract.AllowListTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AllowList *AllowListCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AllowList.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AllowList *AllowListTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AllowList.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AllowList *AllowListTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AllowList.Contract.contract.Transact(opts, method, params...)
}

// IsAdmin is a free data retrieval call binding the contract method 0x24d7806c.
//
// Solidity: function isAdmin(address addr) view returns(bool)
func (_AllowList *AllowListCaller) IsAdmin(opts *bind.CallOpts, addr common.Address) (bool, error) {
	var out []interface{}
	err := _AllowList.contract.Call(opts, &out, "isAdmin", addr)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsAdmin is a free data retrieval call binding the contract method 0x24d7806c.
//
// Solidity: function isAdmin(address addr) view returns(bool)
func (_AllowList *AllowListSession) IsAdmin(addr common.Address) (bool, error) {
	return _AllowList.Contract.IsAdmin(&_AllowList.CallOpts, addr)
}

// IsAdmin is a free data retrieval call binding the contract method 0x24d7806c.
//
// Solidity: function isAdmin(address addr) view returns(bool)
func (_AllowList *AllowListCallerSession) IsAdmin(addr common.Address) (bool, error) {
	return _AllowList.Contract.IsAdmin(&_AllowList.CallOpts, addr)
}

// IsEnabled is a free data retrieval call binding the contract method 0x9015d371.
//
// Solidity: function isEnabled(address addr) view returns(bool)
func (_AllowList *AllowListCaller) IsEnabled(opts *bind.CallOpts, addr common.Address) (bool, error) {
	var out []interface{}
	err := _AllowList.contract.Call(opts, &out, "isEnabled", addr)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsEnabled is a free data retrieval call binding the contract method 0x9015d371.
//
// Solidity: function isEnabled(address addr) view returns(bool)
func (_AllowList *AllowListSession) IsEnabled(addr common.Address) (bool, error) {
	return _AllowList.Contract.IsEnabled(&_AllowList.CallOpts, addr)
}

// IsEnabled is a free data retrieval call binding the contract method 0x9015d371.
//
// Solidity: function isEnabled(address addr) view returns(bool)
func (_AllowList *AllowListCallerSession) IsEnabled(addr common.Address) (bool, error) {
	return _AllowList.Contract.IsEnabled(&_AllowList.CallOpts, addr)
}

// IsManager is a free data retrieval call binding the contract method 0xf3ae2415.
//
// Solidity: function isManager(address addr) view returns(bool)
func (_AllowList *AllowListCaller) IsManager(opts *bind.CallOpts, addr common.Address) (bool, error) {
	var out []interface{}
	err := _AllowList.contract.Call(opts, &out, "isManager", addr)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsManager is a free data retrieval call binding the contract method 0xf3ae2415.
//
// Solidity: function isManager(address addr) view returns(bool)
func (_AllowList *AllowListSession) IsManager(addr common.Address) (bool, error) {
	return _AllowList.Contract.IsManager(&_AllowList.CallOpts, addr)
}

// IsManager is a free data retrieval call binding the contract method 0xf3ae2415.
//
// Solidity: function isManager(address addr) view returns(bool)
func (_AllowList *AllowListCallerSession) IsManager(addr common.Address) (bool, error) {
	return _AllowList.Contract.IsManager(&_AllowList.CallOpts, addr)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_AllowList *AllowListCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _AllowList.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_AllowList *AllowListSession) Owner() (common.Address, error) {
	return _AllowList.Contract.Owner(&_AllowList.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_AllowList *AllowListCallerSession) Owner() (common.Address, error) {
	return _AllowList.Contract.Owner(&_AllowList.CallOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_AllowList *AllowListTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AllowList.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_AllowList *AllowListSession) RenounceOwnership() (*types.Transaction, error) {
	return _AllowList.Contract.RenounceOwnership(&_AllowList.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_AllowList *AllowListTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _AllowList.Contract.RenounceOwnership(&_AllowList.TransactOpts)
}

// Revoke is a paid mutator transaction binding the contract method 0x74a8f103.
//
// Solidity: function revoke(address addr) returns()
func (_AllowList *AllowListTransactor) Revoke(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _AllowList.contract.Transact(opts, "revoke", addr)
}

// Revoke is a paid mutator transaction binding the contract method 0x74a8f103.
//
// Solidity: function revoke(address addr) returns()
func (_AllowList *AllowListSession) Revoke(addr common.Address) (*types.Transaction, error) {
	return _AllowList.Contract.Revoke(&_AllowList.TransactOpts, addr)
}

// Revoke is a paid mutator transaction binding the contract method 0x74a8f103.
//
// Solidity: function revoke(address addr) returns()
func (_AllowList *AllowListTransactorSession) Revoke(addr common.Address) (*types.Transaction, error) {
	return _AllowList.Contract.Revoke(&_AllowList.TransactOpts, addr)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_AllowList *AllowListTransactor) SetAdmin(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _AllowList.contract.Transact(opts, "setAdmin", addr)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_AllowList *AllowListSession) SetAdmin(addr common.Address) (*types.Transaction, error) {
	return _AllowList.Contract.SetAdmin(&_AllowList.TransactOpts, addr)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_AllowList *AllowListTransactorSession) SetAdmin(addr common.Address) (*types.Transaction, error) {
	return _AllowList.Contract.SetAdmin(&_AllowList.TransactOpts, addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_AllowList *AllowListTransactor) SetEnabled(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _AllowList.contract.Transact(opts, "setEnabled", addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_AllowList *AllowListSession) SetEnabled(addr common.Address) (*types.Transaction, error) {
	return _AllowList.Contract.SetEnabled(&_AllowList.TransactOpts, addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_AllowList *AllowListTransactorSession) SetEnabled(addr common.Address) (*types.Transaction, error) {
	return _AllowList.Contract.SetEnabled(&_AllowList.TransactOpts, addr)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_AllowList *AllowListTransactor) SetManager(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _AllowList.contract.Transact(opts, "setManager", addr)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_AllowList *AllowListSession) SetManager(addr common.Address) (*types.Transaction, error) {
	return _AllowList.Contract.SetManager(&_AllowList.TransactOpts, addr)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_AllowList *AllowListTransactorSession) SetManager(addr common.Address) (*types.Transaction, error) {
	return _AllowList.Contract.SetManager(&_AllowList.TransactOpts, addr)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_AllowList *AllowListTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _AllowList.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_AllowList *AllowListSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _AllowList.Contract.TransferOwnership(&_AllowList.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_AllowList *AllowListTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _AllowList.Contract.TransferOwnership(&_AllowList.TransactOpts, newOwner)
}

// AllowListOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the AllowList contract.
type AllowListOwnershipTransferredIterator struct {
	Event *AllowListOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AllowListOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AllowListOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AllowListOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AllowListOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AllowListOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AllowListOwnershipTransferred represents a OwnershipTransferred event raised by the AllowList contract.
type AllowListOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_AllowList *AllowListFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*AllowListOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _AllowList.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &AllowListOwnershipTransferredIterator{contract: _AllowList.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_AllowList *AllowListFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *AllowListOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _AllowList.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AllowListOwnershipTransferred)
				if err := _AllowList.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_AllowList *AllowListFilterer) ParseOwnershipTransferred(log types.Log) (*AllowListOwnershipTransferred, error) {
	event := new(AllowListOwnershipTransferred)
	if err := _AllowList.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AllowListTestMetaData contains all meta data concerning the AllowListTest contract.
var AllowListTestMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"log_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"log_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"log_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"name\":\"log_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"val\",\"type\":\"address\"}],\"name\":\"log_named_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"val\",\"type\":\"bytes\"}],\"name\":\"log_named_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"val\",\"type\":\"bytes32\"}],\"name\":\"log_named_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"}],\"name\":\"log_named_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"val\",\"type\":\"string\"}],\"name\":\"log_named_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"log_named_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"log_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"logs\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"IS_TEST\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"failed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x608060405260016000806101000a81548160ff021916908315150217905550348015602957600080fd5b50610498806100396000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c8063ba414fa61461003b578063fa7626d414610059575b600080fd5b610043610077565b6040516100509190610269565b60405180910390f35b610061610214565b60405161006e9190610269565b60405180910390f35b60008060019054906101000a900460ff16156100a457600060019054906101000a900460ff169050610211565b60006100ae610225565b1561020c5760007f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d60001c60601b60601c73ffffffffffffffffffffffffffffffffffffffff167f667f9d70ca411d70ead50d8d5c22070dafc36ad75f3dcf5e7237b22ade9aecc47f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d60001c60601b60601c7f6661696c656400000000000000000000000000000000000000000000000000006040516020016101729291906102de565b6040516020818303038152906040526040516020016101929291906103c5565b6040516020818303038152906040526040516101ae91906103ed565b6000604051808303816000865af19150503d80600081146101eb576040519150601f19603f3d011682016040523d82523d6000602084013e6101f0565b606091505b50915050808060200190518101906102089190610435565b9150505b809150505b90565b60008054906101000a900460ff1681565b60008060009050737109709ecfa91a80626ff3989d68f67f5b1dd12d3b90506000811191505090565b60008115159050919050565b6102638161024e565b82525050565b600060208201905061027e600083018461025a565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006102af82610284565b9050919050565b6102bf816102a4565b82525050565b6000819050919050565b6102d8816102c5565b82525050565b60006040820190506102f360008301856102b6565b61030060208301846102cf565b9392505050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b6000819050919050565b61034e61034982610307565b610333565b82525050565b600081519050919050565b600081905092915050565b60005b8381101561038857808201518184015260208101905061036d565b60008484015250505050565b600061039f82610354565b6103a9818561035f565b93506103b981856020860161036a565b80840191505092915050565b60006103d1828561033d565b6004820191506103e18284610394565b91508190509392505050565b60006103f98284610394565b915081905092915050565b600080fd5b6104128161024e565b811461041d57600080fd5b50565b60008151905061042f81610409565b92915050565b60006020828403121561044b5761044a610404565b5b600061045984828501610420565b9150509291505056fea2646970667358221220f0f1c049009ee82674123c27c40d037a985f50b838a1db042802d49c3edca87564736f6c634300081a0033",
}

// AllowListTestABI is the input ABI used to generate the binding from.
// Deprecated: Use AllowListTestMetaData.ABI instead.
var AllowListTestABI = AllowListTestMetaData.ABI

// AllowListTestBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use AllowListTestMetaData.Bin instead.
var AllowListTestBin = AllowListTestMetaData.Bin

// DeployAllowListTest deploys a new Ethereum contract, binding an instance of AllowListTest to it.
func DeployAllowListTest(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *AllowListTest, error) {
	parsed, err := AllowListTestMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(AllowListTestBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &AllowListTest{AllowListTestCaller: AllowListTestCaller{contract: contract}, AllowListTestTransactor: AllowListTestTransactor{contract: contract}, AllowListTestFilterer: AllowListTestFilterer{contract: contract}}, nil
}

// AllowListTest is an auto generated Go binding around an Ethereum contract.
type AllowListTest struct {
	AllowListTestCaller     // Read-only binding to the contract
	AllowListTestTransactor // Write-only binding to the contract
	AllowListTestFilterer   // Log filterer for contract events
}

// AllowListTestCaller is an auto generated read-only Go binding around an Ethereum contract.
type AllowListTestCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AllowListTestTransactor is an auto generated write-only Go binding around an Ethereum contract.
type AllowListTestTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AllowListTestFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type AllowListTestFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AllowListTestSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type AllowListTestSession struct {
	Contract     *AllowListTest    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// AllowListTestCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type AllowListTestCallerSession struct {
	Contract *AllowListTestCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// AllowListTestTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type AllowListTestTransactorSession struct {
	Contract     *AllowListTestTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// AllowListTestRaw is an auto generated low-level Go binding around an Ethereum contract.
type AllowListTestRaw struct {
	Contract *AllowListTest // Generic contract binding to access the raw methods on
}

// AllowListTestCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type AllowListTestCallerRaw struct {
	Contract *AllowListTestCaller // Generic read-only contract binding to access the raw methods on
}

// AllowListTestTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type AllowListTestTransactorRaw struct {
	Contract *AllowListTestTransactor // Generic write-only contract binding to access the raw methods on
}

// NewAllowListTest creates a new instance of AllowListTest, bound to a specific deployed contract.
func NewAllowListTest(address common.Address, backend bind.ContractBackend) (*AllowListTest, error) {
	contract, err := bindAllowListTest(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &AllowListTest{AllowListTestCaller: AllowListTestCaller{contract: contract}, AllowListTestTransactor: AllowListTestTransactor{contract: contract}, AllowListTestFilterer: AllowListTestFilterer{contract: contract}}, nil
}

// NewAllowListTestCaller creates a new read-only instance of AllowListTest, bound to a specific deployed contract.
func NewAllowListTestCaller(address common.Address, caller bind.ContractCaller) (*AllowListTestCaller, error) {
	contract, err := bindAllowListTest(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &AllowListTestCaller{contract: contract}, nil
}

// NewAllowListTestTransactor creates a new write-only instance of AllowListTest, bound to a specific deployed contract.
func NewAllowListTestTransactor(address common.Address, transactor bind.ContractTransactor) (*AllowListTestTransactor, error) {
	contract, err := bindAllowListTest(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &AllowListTestTransactor{contract: contract}, nil
}

// NewAllowListTestFilterer creates a new log filterer instance of AllowListTest, bound to a specific deployed contract.
func NewAllowListTestFilterer(address common.Address, filterer bind.ContractFilterer) (*AllowListTestFilterer, error) {
	contract, err := bindAllowListTest(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &AllowListTestFilterer{contract: contract}, nil
}

// bindAllowListTest binds a generic wrapper to an already deployed contract.
func bindAllowListTest(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := AllowListTestMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AllowListTest *AllowListTestRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AllowListTest.Contract.AllowListTestCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AllowListTest *AllowListTestRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AllowListTest.Contract.AllowListTestTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AllowListTest *AllowListTestRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AllowListTest.Contract.AllowListTestTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AllowListTest *AllowListTestCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AllowListTest.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AllowListTest *AllowListTestTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AllowListTest.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AllowListTest *AllowListTestTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AllowListTest.Contract.contract.Transact(opts, method, params...)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_AllowListTest *AllowListTestCaller) ISTEST(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _AllowListTest.contract.Call(opts, &out, "IS_TEST")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_AllowListTest *AllowListTestSession) ISTEST() (bool, error) {
	return _AllowListTest.Contract.ISTEST(&_AllowListTest.CallOpts)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_AllowListTest *AllowListTestCallerSession) ISTEST() (bool, error) {
	return _AllowListTest.Contract.ISTEST(&_AllowListTest.CallOpts)
}

// Failed is a paid mutator transaction binding the contract method 0xba414fa6.
//
// Solidity: function failed() returns(bool)
func (_AllowListTest *AllowListTestTransactor) Failed(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AllowListTest.contract.Transact(opts, "failed")
}

// Failed is a paid mutator transaction binding the contract method 0xba414fa6.
//
// Solidity: function failed() returns(bool)
func (_AllowListTest *AllowListTestSession) Failed() (*types.Transaction, error) {
	return _AllowListTest.Contract.Failed(&_AllowListTest.TransactOpts)
}

// Failed is a paid mutator transaction binding the contract method 0xba414fa6.
//
// Solidity: function failed() returns(bool)
func (_AllowListTest *AllowListTestTransactorSession) Failed() (*types.Transaction, error) {
	return _AllowListTest.Contract.Failed(&_AllowListTest.TransactOpts)
}

// AllowListTestLogIterator is returned from FilterLog and is used to iterate over the raw logs and unpacked data for Log events raised by the AllowListTest contract.
type AllowListTestLogIterator struct {
	Event *AllowListTestLog // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AllowListTestLogIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AllowListTestLog)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AllowListTestLog)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AllowListTestLogIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AllowListTestLogIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AllowListTestLog represents a Log event raised by the AllowListTest contract.
type AllowListTestLog struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLog is a free log retrieval operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_AllowListTest *AllowListTestFilterer) FilterLog(opts *bind.FilterOpts) (*AllowListTestLogIterator, error) {

	logs, sub, err := _AllowListTest.contract.FilterLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return &AllowListTestLogIterator{contract: _AllowListTest.contract, event: "log", logs: logs, sub: sub}, nil
}

// WatchLog is a free log subscription operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_AllowListTest *AllowListTestFilterer) WatchLog(opts *bind.WatchOpts, sink chan<- *AllowListTestLog) (event.Subscription, error) {

	logs, sub, err := _AllowListTest.contract.WatchLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AllowListTestLog)
				if err := _AllowListTest.contract.UnpackLog(event, "log", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLog is a log parse operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_AllowListTest *AllowListTestFilterer) ParseLog(log types.Log) (*AllowListTestLog, error) {
	event := new(AllowListTestLog)
	if err := _AllowListTest.contract.UnpackLog(event, "log", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AllowListTestLogAddressIterator is returned from FilterLogAddress and is used to iterate over the raw logs and unpacked data for LogAddress events raised by the AllowListTest contract.
type AllowListTestLogAddressIterator struct {
	Event *AllowListTestLogAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AllowListTestLogAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AllowListTestLogAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AllowListTestLogAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AllowListTestLogAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AllowListTestLogAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AllowListTestLogAddress represents a LogAddress event raised by the AllowListTest contract.
type AllowListTestLogAddress struct {
	Arg0 common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogAddress is a free log retrieval operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_AllowListTest *AllowListTestFilterer) FilterLogAddress(opts *bind.FilterOpts) (*AllowListTestLogAddressIterator, error) {

	logs, sub, err := _AllowListTest.contract.FilterLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return &AllowListTestLogAddressIterator{contract: _AllowListTest.contract, event: "log_address", logs: logs, sub: sub}, nil
}

// WatchLogAddress is a free log subscription operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_AllowListTest *AllowListTestFilterer) WatchLogAddress(opts *bind.WatchOpts, sink chan<- *AllowListTestLogAddress) (event.Subscription, error) {

	logs, sub, err := _AllowListTest.contract.WatchLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AllowListTestLogAddress)
				if err := _AllowListTest.contract.UnpackLog(event, "log_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogAddress is a log parse operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_AllowListTest *AllowListTestFilterer) ParseLogAddress(log types.Log) (*AllowListTestLogAddress, error) {
	event := new(AllowListTestLogAddress)
	if err := _AllowListTest.contract.UnpackLog(event, "log_address", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AllowListTestLogBytesIterator is returned from FilterLogBytes and is used to iterate over the raw logs and unpacked data for LogBytes events raised by the AllowListTest contract.
type AllowListTestLogBytesIterator struct {
	Event *AllowListTestLogBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AllowListTestLogBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AllowListTestLogBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AllowListTestLogBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AllowListTestLogBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AllowListTestLogBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AllowListTestLogBytes represents a LogBytes event raised by the AllowListTest contract.
type AllowListTestLogBytes struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes is a free log retrieval operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_AllowListTest *AllowListTestFilterer) FilterLogBytes(opts *bind.FilterOpts) (*AllowListTestLogBytesIterator, error) {

	logs, sub, err := _AllowListTest.contract.FilterLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return &AllowListTestLogBytesIterator{contract: _AllowListTest.contract, event: "log_bytes", logs: logs, sub: sub}, nil
}

// WatchLogBytes is a free log subscription operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_AllowListTest *AllowListTestFilterer) WatchLogBytes(opts *bind.WatchOpts, sink chan<- *AllowListTestLogBytes) (event.Subscription, error) {

	logs, sub, err := _AllowListTest.contract.WatchLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AllowListTestLogBytes)
				if err := _AllowListTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes is a log parse operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_AllowListTest *AllowListTestFilterer) ParseLogBytes(log types.Log) (*AllowListTestLogBytes, error) {
	event := new(AllowListTestLogBytes)
	if err := _AllowListTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AllowListTestLogBytes32Iterator is returned from FilterLogBytes32 and is used to iterate over the raw logs and unpacked data for LogBytes32 events raised by the AllowListTest contract.
type AllowListTestLogBytes32Iterator struct {
	Event *AllowListTestLogBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AllowListTestLogBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AllowListTestLogBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AllowListTestLogBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AllowListTestLogBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AllowListTestLogBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AllowListTestLogBytes32 represents a LogBytes32 event raised by the AllowListTest contract.
type AllowListTestLogBytes32 struct {
	Arg0 [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes32 is a free log retrieval operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_AllowListTest *AllowListTestFilterer) FilterLogBytes32(opts *bind.FilterOpts) (*AllowListTestLogBytes32Iterator, error) {

	logs, sub, err := _AllowListTest.contract.FilterLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return &AllowListTestLogBytes32Iterator{contract: _AllowListTest.contract, event: "log_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogBytes32 is a free log subscription operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_AllowListTest *AllowListTestFilterer) WatchLogBytes32(opts *bind.WatchOpts, sink chan<- *AllowListTestLogBytes32) (event.Subscription, error) {

	logs, sub, err := _AllowListTest.contract.WatchLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AllowListTestLogBytes32)
				if err := _AllowListTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes32 is a log parse operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_AllowListTest *AllowListTestFilterer) ParseLogBytes32(log types.Log) (*AllowListTestLogBytes32, error) {
	event := new(AllowListTestLogBytes32)
	if err := _AllowListTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AllowListTestLogIntIterator is returned from FilterLogInt and is used to iterate over the raw logs and unpacked data for LogInt events raised by the AllowListTest contract.
type AllowListTestLogIntIterator struct {
	Event *AllowListTestLogInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AllowListTestLogIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AllowListTestLogInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AllowListTestLogInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AllowListTestLogIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AllowListTestLogIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AllowListTestLogInt represents a LogInt event raised by the AllowListTest contract.
type AllowListTestLogInt struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogInt is a free log retrieval operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_AllowListTest *AllowListTestFilterer) FilterLogInt(opts *bind.FilterOpts) (*AllowListTestLogIntIterator, error) {

	logs, sub, err := _AllowListTest.contract.FilterLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return &AllowListTestLogIntIterator{contract: _AllowListTest.contract, event: "log_int", logs: logs, sub: sub}, nil
}

// WatchLogInt is a free log subscription operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_AllowListTest *AllowListTestFilterer) WatchLogInt(opts *bind.WatchOpts, sink chan<- *AllowListTestLogInt) (event.Subscription, error) {

	logs, sub, err := _AllowListTest.contract.WatchLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AllowListTestLogInt)
				if err := _AllowListTest.contract.UnpackLog(event, "log_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogInt is a log parse operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_AllowListTest *AllowListTestFilterer) ParseLogInt(log types.Log) (*AllowListTestLogInt, error) {
	event := new(AllowListTestLogInt)
	if err := _AllowListTest.contract.UnpackLog(event, "log_int", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AllowListTestLogNamedAddressIterator is returned from FilterLogNamedAddress and is used to iterate over the raw logs and unpacked data for LogNamedAddress events raised by the AllowListTest contract.
type AllowListTestLogNamedAddressIterator struct {
	Event *AllowListTestLogNamedAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AllowListTestLogNamedAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AllowListTestLogNamedAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AllowListTestLogNamedAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AllowListTestLogNamedAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AllowListTestLogNamedAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AllowListTestLogNamedAddress represents a LogNamedAddress event raised by the AllowListTest contract.
type AllowListTestLogNamedAddress struct {
	Key string
	Val common.Address
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedAddress is a free log retrieval operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_AllowListTest *AllowListTestFilterer) FilterLogNamedAddress(opts *bind.FilterOpts) (*AllowListTestLogNamedAddressIterator, error) {

	logs, sub, err := _AllowListTest.contract.FilterLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return &AllowListTestLogNamedAddressIterator{contract: _AllowListTest.contract, event: "log_named_address", logs: logs, sub: sub}, nil
}

// WatchLogNamedAddress is a free log subscription operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_AllowListTest *AllowListTestFilterer) WatchLogNamedAddress(opts *bind.WatchOpts, sink chan<- *AllowListTestLogNamedAddress) (event.Subscription, error) {

	logs, sub, err := _AllowListTest.contract.WatchLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AllowListTestLogNamedAddress)
				if err := _AllowListTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedAddress is a log parse operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_AllowListTest *AllowListTestFilterer) ParseLogNamedAddress(log types.Log) (*AllowListTestLogNamedAddress, error) {
	event := new(AllowListTestLogNamedAddress)
	if err := _AllowListTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AllowListTestLogNamedBytesIterator is returned from FilterLogNamedBytes and is used to iterate over the raw logs and unpacked data for LogNamedBytes events raised by the AllowListTest contract.
type AllowListTestLogNamedBytesIterator struct {
	Event *AllowListTestLogNamedBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AllowListTestLogNamedBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AllowListTestLogNamedBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AllowListTestLogNamedBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AllowListTestLogNamedBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AllowListTestLogNamedBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AllowListTestLogNamedBytes represents a LogNamedBytes event raised by the AllowListTest contract.
type AllowListTestLogNamedBytes struct {
	Key string
	Val []byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes is a free log retrieval operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_AllowListTest *AllowListTestFilterer) FilterLogNamedBytes(opts *bind.FilterOpts) (*AllowListTestLogNamedBytesIterator, error) {

	logs, sub, err := _AllowListTest.contract.FilterLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return &AllowListTestLogNamedBytesIterator{contract: _AllowListTest.contract, event: "log_named_bytes", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes is a free log subscription operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_AllowListTest *AllowListTestFilterer) WatchLogNamedBytes(opts *bind.WatchOpts, sink chan<- *AllowListTestLogNamedBytes) (event.Subscription, error) {

	logs, sub, err := _AllowListTest.contract.WatchLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AllowListTestLogNamedBytes)
				if err := _AllowListTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes is a log parse operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_AllowListTest *AllowListTestFilterer) ParseLogNamedBytes(log types.Log) (*AllowListTestLogNamedBytes, error) {
	event := new(AllowListTestLogNamedBytes)
	if err := _AllowListTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AllowListTestLogNamedBytes32Iterator is returned from FilterLogNamedBytes32 and is used to iterate over the raw logs and unpacked data for LogNamedBytes32 events raised by the AllowListTest contract.
type AllowListTestLogNamedBytes32Iterator struct {
	Event *AllowListTestLogNamedBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AllowListTestLogNamedBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AllowListTestLogNamedBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AllowListTestLogNamedBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AllowListTestLogNamedBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AllowListTestLogNamedBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AllowListTestLogNamedBytes32 represents a LogNamedBytes32 event raised by the AllowListTest contract.
type AllowListTestLogNamedBytes32 struct {
	Key string
	Val [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes32 is a free log retrieval operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_AllowListTest *AllowListTestFilterer) FilterLogNamedBytes32(opts *bind.FilterOpts) (*AllowListTestLogNamedBytes32Iterator, error) {

	logs, sub, err := _AllowListTest.contract.FilterLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return &AllowListTestLogNamedBytes32Iterator{contract: _AllowListTest.contract, event: "log_named_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes32 is a free log subscription operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_AllowListTest *AllowListTestFilterer) WatchLogNamedBytes32(opts *bind.WatchOpts, sink chan<- *AllowListTestLogNamedBytes32) (event.Subscription, error) {

	logs, sub, err := _AllowListTest.contract.WatchLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AllowListTestLogNamedBytes32)
				if err := _AllowListTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes32 is a log parse operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_AllowListTest *AllowListTestFilterer) ParseLogNamedBytes32(log types.Log) (*AllowListTestLogNamedBytes32, error) {
	event := new(AllowListTestLogNamedBytes32)
	if err := _AllowListTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AllowListTestLogNamedDecimalIntIterator is returned from FilterLogNamedDecimalInt and is used to iterate over the raw logs and unpacked data for LogNamedDecimalInt events raised by the AllowListTest contract.
type AllowListTestLogNamedDecimalIntIterator struct {
	Event *AllowListTestLogNamedDecimalInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AllowListTestLogNamedDecimalIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AllowListTestLogNamedDecimalInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AllowListTestLogNamedDecimalInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AllowListTestLogNamedDecimalIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AllowListTestLogNamedDecimalIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AllowListTestLogNamedDecimalInt represents a LogNamedDecimalInt event raised by the AllowListTest contract.
type AllowListTestLogNamedDecimalInt struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalInt is a free log retrieval operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_AllowListTest *AllowListTestFilterer) FilterLogNamedDecimalInt(opts *bind.FilterOpts) (*AllowListTestLogNamedDecimalIntIterator, error) {

	logs, sub, err := _AllowListTest.contract.FilterLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return &AllowListTestLogNamedDecimalIntIterator{contract: _AllowListTest.contract, event: "log_named_decimal_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalInt is a free log subscription operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_AllowListTest *AllowListTestFilterer) WatchLogNamedDecimalInt(opts *bind.WatchOpts, sink chan<- *AllowListTestLogNamedDecimalInt) (event.Subscription, error) {

	logs, sub, err := _AllowListTest.contract.WatchLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AllowListTestLogNamedDecimalInt)
				if err := _AllowListTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalInt is a log parse operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_AllowListTest *AllowListTestFilterer) ParseLogNamedDecimalInt(log types.Log) (*AllowListTestLogNamedDecimalInt, error) {
	event := new(AllowListTestLogNamedDecimalInt)
	if err := _AllowListTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AllowListTestLogNamedDecimalUintIterator is returned from FilterLogNamedDecimalUint and is used to iterate over the raw logs and unpacked data for LogNamedDecimalUint events raised by the AllowListTest contract.
type AllowListTestLogNamedDecimalUintIterator struct {
	Event *AllowListTestLogNamedDecimalUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AllowListTestLogNamedDecimalUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AllowListTestLogNamedDecimalUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AllowListTestLogNamedDecimalUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AllowListTestLogNamedDecimalUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AllowListTestLogNamedDecimalUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AllowListTestLogNamedDecimalUint represents a LogNamedDecimalUint event raised by the AllowListTest contract.
type AllowListTestLogNamedDecimalUint struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalUint is a free log retrieval operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_AllowListTest *AllowListTestFilterer) FilterLogNamedDecimalUint(opts *bind.FilterOpts) (*AllowListTestLogNamedDecimalUintIterator, error) {

	logs, sub, err := _AllowListTest.contract.FilterLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return &AllowListTestLogNamedDecimalUintIterator{contract: _AllowListTest.contract, event: "log_named_decimal_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalUint is a free log subscription operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_AllowListTest *AllowListTestFilterer) WatchLogNamedDecimalUint(opts *bind.WatchOpts, sink chan<- *AllowListTestLogNamedDecimalUint) (event.Subscription, error) {

	logs, sub, err := _AllowListTest.contract.WatchLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AllowListTestLogNamedDecimalUint)
				if err := _AllowListTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalUint is a log parse operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_AllowListTest *AllowListTestFilterer) ParseLogNamedDecimalUint(log types.Log) (*AllowListTestLogNamedDecimalUint, error) {
	event := new(AllowListTestLogNamedDecimalUint)
	if err := _AllowListTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AllowListTestLogNamedIntIterator is returned from FilterLogNamedInt and is used to iterate over the raw logs and unpacked data for LogNamedInt events raised by the AllowListTest contract.
type AllowListTestLogNamedIntIterator struct {
	Event *AllowListTestLogNamedInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AllowListTestLogNamedIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AllowListTestLogNamedInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AllowListTestLogNamedInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AllowListTestLogNamedIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AllowListTestLogNamedIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AllowListTestLogNamedInt represents a LogNamedInt event raised by the AllowListTest contract.
type AllowListTestLogNamedInt struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedInt is a free log retrieval operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_AllowListTest *AllowListTestFilterer) FilterLogNamedInt(opts *bind.FilterOpts) (*AllowListTestLogNamedIntIterator, error) {

	logs, sub, err := _AllowListTest.contract.FilterLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return &AllowListTestLogNamedIntIterator{contract: _AllowListTest.contract, event: "log_named_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedInt is a free log subscription operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_AllowListTest *AllowListTestFilterer) WatchLogNamedInt(opts *bind.WatchOpts, sink chan<- *AllowListTestLogNamedInt) (event.Subscription, error) {

	logs, sub, err := _AllowListTest.contract.WatchLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AllowListTestLogNamedInt)
				if err := _AllowListTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedInt is a log parse operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_AllowListTest *AllowListTestFilterer) ParseLogNamedInt(log types.Log) (*AllowListTestLogNamedInt, error) {
	event := new(AllowListTestLogNamedInt)
	if err := _AllowListTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AllowListTestLogNamedStringIterator is returned from FilterLogNamedString and is used to iterate over the raw logs and unpacked data for LogNamedString events raised by the AllowListTest contract.
type AllowListTestLogNamedStringIterator struct {
	Event *AllowListTestLogNamedString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AllowListTestLogNamedStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AllowListTestLogNamedString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AllowListTestLogNamedString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AllowListTestLogNamedStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AllowListTestLogNamedStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AllowListTestLogNamedString represents a LogNamedString event raised by the AllowListTest contract.
type AllowListTestLogNamedString struct {
	Key string
	Val string
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedString is a free log retrieval operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_AllowListTest *AllowListTestFilterer) FilterLogNamedString(opts *bind.FilterOpts) (*AllowListTestLogNamedStringIterator, error) {

	logs, sub, err := _AllowListTest.contract.FilterLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return &AllowListTestLogNamedStringIterator{contract: _AllowListTest.contract, event: "log_named_string", logs: logs, sub: sub}, nil
}

// WatchLogNamedString is a free log subscription operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_AllowListTest *AllowListTestFilterer) WatchLogNamedString(opts *bind.WatchOpts, sink chan<- *AllowListTestLogNamedString) (event.Subscription, error) {

	logs, sub, err := _AllowListTest.contract.WatchLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AllowListTestLogNamedString)
				if err := _AllowListTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedString is a log parse operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_AllowListTest *AllowListTestFilterer) ParseLogNamedString(log types.Log) (*AllowListTestLogNamedString, error) {
	event := new(AllowListTestLogNamedString)
	if err := _AllowListTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AllowListTestLogNamedUintIterator is returned from FilterLogNamedUint and is used to iterate over the raw logs and unpacked data for LogNamedUint events raised by the AllowListTest contract.
type AllowListTestLogNamedUintIterator struct {
	Event *AllowListTestLogNamedUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AllowListTestLogNamedUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AllowListTestLogNamedUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AllowListTestLogNamedUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AllowListTestLogNamedUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AllowListTestLogNamedUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AllowListTestLogNamedUint represents a LogNamedUint event raised by the AllowListTest contract.
type AllowListTestLogNamedUint struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedUint is a free log retrieval operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_AllowListTest *AllowListTestFilterer) FilterLogNamedUint(opts *bind.FilterOpts) (*AllowListTestLogNamedUintIterator, error) {

	logs, sub, err := _AllowListTest.contract.FilterLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return &AllowListTestLogNamedUintIterator{contract: _AllowListTest.contract, event: "log_named_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedUint is a free log subscription operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_AllowListTest *AllowListTestFilterer) WatchLogNamedUint(opts *bind.WatchOpts, sink chan<- *AllowListTestLogNamedUint) (event.Subscription, error) {

	logs, sub, err := _AllowListTest.contract.WatchLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AllowListTestLogNamedUint)
				if err := _AllowListTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedUint is a log parse operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_AllowListTest *AllowListTestFilterer) ParseLogNamedUint(log types.Log) (*AllowListTestLogNamedUint, error) {
	event := new(AllowListTestLogNamedUint)
	if err := _AllowListTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AllowListTestLogStringIterator is returned from FilterLogString and is used to iterate over the raw logs and unpacked data for LogString events raised by the AllowListTest contract.
type AllowListTestLogStringIterator struct {
	Event *AllowListTestLogString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AllowListTestLogStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AllowListTestLogString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AllowListTestLogString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AllowListTestLogStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AllowListTestLogStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AllowListTestLogString represents a LogString event raised by the AllowListTest contract.
type AllowListTestLogString struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogString is a free log retrieval operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_AllowListTest *AllowListTestFilterer) FilterLogString(opts *bind.FilterOpts) (*AllowListTestLogStringIterator, error) {

	logs, sub, err := _AllowListTest.contract.FilterLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return &AllowListTestLogStringIterator{contract: _AllowListTest.contract, event: "log_string", logs: logs, sub: sub}, nil
}

// WatchLogString is a free log subscription operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_AllowListTest *AllowListTestFilterer) WatchLogString(opts *bind.WatchOpts, sink chan<- *AllowListTestLogString) (event.Subscription, error) {

	logs, sub, err := _AllowListTest.contract.WatchLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AllowListTestLogString)
				if err := _AllowListTest.contract.UnpackLog(event, "log_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogString is a log parse operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_AllowListTest *AllowListTestFilterer) ParseLogString(log types.Log) (*AllowListTestLogString, error) {
	event := new(AllowListTestLogString)
	if err := _AllowListTest.contract.UnpackLog(event, "log_string", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AllowListTestLogUintIterator is returned from FilterLogUint and is used to iterate over the raw logs and unpacked data for LogUint events raised by the AllowListTest contract.
type AllowListTestLogUintIterator struct {
	Event *AllowListTestLogUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AllowListTestLogUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AllowListTestLogUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AllowListTestLogUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AllowListTestLogUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AllowListTestLogUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AllowListTestLogUint represents a LogUint event raised by the AllowListTest contract.
type AllowListTestLogUint struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogUint is a free log retrieval operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_AllowListTest *AllowListTestFilterer) FilterLogUint(opts *bind.FilterOpts) (*AllowListTestLogUintIterator, error) {

	logs, sub, err := _AllowListTest.contract.FilterLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return &AllowListTestLogUintIterator{contract: _AllowListTest.contract, event: "log_uint", logs: logs, sub: sub}, nil
}

// WatchLogUint is a free log subscription operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_AllowListTest *AllowListTestFilterer) WatchLogUint(opts *bind.WatchOpts, sink chan<- *AllowListTestLogUint) (event.Subscription, error) {

	logs, sub, err := _AllowListTest.contract.WatchLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AllowListTestLogUint)
				if err := _AllowListTest.contract.UnpackLog(event, "log_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogUint is a log parse operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_AllowListTest *AllowListTestFilterer) ParseLogUint(log types.Log) (*AllowListTestLogUint, error) {
	event := new(AllowListTestLogUint)
	if err := _AllowListTest.contract.UnpackLog(event, "log_uint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AllowListTestLogsIterator is returned from FilterLogs and is used to iterate over the raw logs and unpacked data for Logs events raised by the AllowListTest contract.
type AllowListTestLogsIterator struct {
	Event *AllowListTestLogs // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AllowListTestLogsIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AllowListTestLogs)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AllowListTestLogs)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AllowListTestLogsIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AllowListTestLogsIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AllowListTestLogs represents a Logs event raised by the AllowListTest contract.
type AllowListTestLogs struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogs is a free log retrieval operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_AllowListTest *AllowListTestFilterer) FilterLogs(opts *bind.FilterOpts) (*AllowListTestLogsIterator, error) {

	logs, sub, err := _AllowListTest.contract.FilterLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return &AllowListTestLogsIterator{contract: _AllowListTest.contract, event: "logs", logs: logs, sub: sub}, nil
}

// WatchLogs is a free log subscription operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_AllowListTest *AllowListTestFilterer) WatchLogs(opts *bind.WatchOpts, sink chan<- *AllowListTestLogs) (event.Subscription, error) {

	logs, sub, err := _AllowListTest.contract.WatchLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AllowListTestLogs)
				if err := _AllowListTest.contract.UnpackLog(event, "logs", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogs is a log parse operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_AllowListTest *AllowListTestFilterer) ParseLogs(log types.Log) (*AllowListTestLogs, error) {
	event := new(AllowListTestLogs)
	if err := _AllowListTest.contract.UnpackLog(event, "logs", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ContextMetaData contains all meta data concerning the Context contract.
var ContextMetaData = &bind.MetaData{
	ABI: "[]",
}

// ContextABI is the input ABI used to generate the binding from.
// Deprecated: Use ContextMetaData.ABI instead.
var ContextABI = ContextMetaData.ABI

// Context is an auto generated Go binding around an Ethereum contract.
type Context struct {
	ContextCaller     // Read-only binding to the contract
	ContextTransactor // Write-only binding to the contract
	ContextFilterer   // Log filterer for contract events
}

// ContextCaller is an auto generated read-only Go binding around an Ethereum contract.
type ContextCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ContextTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ContextFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ContextSession struct {
	Contract     *Context          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ContextCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ContextCallerSession struct {
	Contract *ContextCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// ContextTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ContextTransactorSession struct {
	Contract     *ContextTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// ContextRaw is an auto generated low-level Go binding around an Ethereum contract.
type ContextRaw struct {
	Contract *Context // Generic contract binding to access the raw methods on
}

// ContextCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ContextCallerRaw struct {
	Contract *ContextCaller // Generic read-only contract binding to access the raw methods on
}

// ContextTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ContextTransactorRaw struct {
	Contract *ContextTransactor // Generic write-only contract binding to access the raw methods on
}

// NewContext creates a new instance of Context, bound to a specific deployed contract.
func NewContext(address common.Address, backend bind.ContractBackend) (*Context, error) {
	contract, err := bindContext(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Context{ContextCaller: ContextCaller{contract: contract}, ContextTransactor: ContextTransactor{contract: contract}, ContextFilterer: ContextFilterer{contract: contract}}, nil
}

// NewContextCaller creates a new read-only instance of Context, bound to a specific deployed contract.
func NewContextCaller(address common.Address, caller bind.ContractCaller) (*ContextCaller, error) {
	contract, err := bindContext(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ContextCaller{contract: contract}, nil
}

// NewContextTransactor creates a new write-only instance of Context, bound to a specific deployed contract.
func NewContextTransactor(address common.Address, transactor bind.ContractTransactor) (*ContextTransactor, error) {
	contract, err := bindContext(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ContextTransactor{contract: contract}, nil
}

// NewContextFilterer creates a new log filterer instance of Context, bound to a specific deployed contract.
func NewContextFilterer(address common.Address, filterer bind.ContractFilterer) (*ContextFilterer, error) {
	contract, err := bindContext(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ContextFilterer{contract: contract}, nil
}

// bindContext binds a generic wrapper to an already deployed contract.
func bindContext(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ContextMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Context *ContextRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Context.Contract.ContextCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Context *ContextRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Context.Contract.ContextTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Context *ContextRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Context.Contract.ContextTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Context *ContextCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Context.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Context *ContextTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Context.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Context *ContextTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Context.Contract.contract.Transact(opts, method, params...)
}

// DSTestMetaData contains all meta data concerning the DSTest contract.
var DSTestMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"log_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"log_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"log_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"name\":\"log_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"val\",\"type\":\"address\"}],\"name\":\"log_named_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"val\",\"type\":\"bytes\"}],\"name\":\"log_named_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"val\",\"type\":\"bytes32\"}],\"name\":\"log_named_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"}],\"name\":\"log_named_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"val\",\"type\":\"string\"}],\"name\":\"log_named_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"log_named_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"log_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"logs\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"IS_TEST\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"failed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x608060405260016000806101000a81548160ff021916908315150217905550348015602957600080fd5b50610498806100396000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c8063ba414fa61461003b578063fa7626d414610059575b600080fd5b610043610077565b6040516100509190610269565b60405180910390f35b610061610214565b60405161006e9190610269565b60405180910390f35b60008060019054906101000a900460ff16156100a457600060019054906101000a900460ff169050610211565b60006100ae610225565b1561020c5760007f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d60001c60601b60601c73ffffffffffffffffffffffffffffffffffffffff167f667f9d70ca411d70ead50d8d5c22070dafc36ad75f3dcf5e7237b22ade9aecc47f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d60001c60601b60601c7f6661696c656400000000000000000000000000000000000000000000000000006040516020016101729291906102de565b6040516020818303038152906040526040516020016101929291906103c5565b6040516020818303038152906040526040516101ae91906103ed565b6000604051808303816000865af19150503d80600081146101eb576040519150601f19603f3d011682016040523d82523d6000602084013e6101f0565b606091505b50915050808060200190518101906102089190610435565b9150505b809150505b90565b60008054906101000a900460ff1681565b60008060009050737109709ecfa91a80626ff3989d68f67f5b1dd12d3b90506000811191505090565b60008115159050919050565b6102638161024e565b82525050565b600060208201905061027e600083018461025a565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006102af82610284565b9050919050565b6102bf816102a4565b82525050565b6000819050919050565b6102d8816102c5565b82525050565b60006040820190506102f360008301856102b6565b61030060208301846102cf565b9392505050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b6000819050919050565b61034e61034982610307565b610333565b82525050565b600081519050919050565b600081905092915050565b60005b8381101561038857808201518184015260208101905061036d565b60008484015250505050565b600061039f82610354565b6103a9818561035f565b93506103b981856020860161036a565b80840191505092915050565b60006103d1828561033d565b6004820191506103e18284610394565b91508190509392505050565b60006103f98284610394565b915081905092915050565b600080fd5b6104128161024e565b811461041d57600080fd5b50565b60008151905061042f81610409565b92915050565b60006020828403121561044b5761044a610404565b5b600061045984828501610420565b9150509291505056fea26469706673582212204ae24acdd719d0ed71a122c0bba25d8aacfc03cebfcd189c2b53059321c132e864736f6c634300081a0033",
}

// DSTestABI is the input ABI used to generate the binding from.
// Deprecated: Use DSTestMetaData.ABI instead.
var DSTestABI = DSTestMetaData.ABI

// DSTestBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use DSTestMetaData.Bin instead.
var DSTestBin = DSTestMetaData.Bin

// DeployDSTest deploys a new Ethereum contract, binding an instance of DSTest to it.
func DeployDSTest(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *DSTest, error) {
	parsed, err := DSTestMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(DSTestBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &DSTest{DSTestCaller: DSTestCaller{contract: contract}, DSTestTransactor: DSTestTransactor{contract: contract}, DSTestFilterer: DSTestFilterer{contract: contract}}, nil
}

// DSTest is an auto generated Go binding around an Ethereum contract.
type DSTest struct {
	DSTestCaller     // Read-only binding to the contract
	DSTestTransactor // Write-only binding to the contract
	DSTestFilterer   // Log filterer for contract events
}

// DSTestCaller is an auto generated read-only Go binding around an Ethereum contract.
type DSTestCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DSTestTransactor is an auto generated write-only Go binding around an Ethereum contract.
type DSTestTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DSTestFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type DSTestFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DSTestSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type DSTestSession struct {
	Contract     *DSTest           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// DSTestCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type DSTestCallerSession struct {
	Contract *DSTestCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// DSTestTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type DSTestTransactorSession struct {
	Contract     *DSTestTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// DSTestRaw is an auto generated low-level Go binding around an Ethereum contract.
type DSTestRaw struct {
	Contract *DSTest // Generic contract binding to access the raw methods on
}

// DSTestCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type DSTestCallerRaw struct {
	Contract *DSTestCaller // Generic read-only contract binding to access the raw methods on
}

// DSTestTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type DSTestTransactorRaw struct {
	Contract *DSTestTransactor // Generic write-only contract binding to access the raw methods on
}

// NewDSTest creates a new instance of DSTest, bound to a specific deployed contract.
func NewDSTest(address common.Address, backend bind.ContractBackend) (*DSTest, error) {
	contract, err := bindDSTest(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &DSTest{DSTestCaller: DSTestCaller{contract: contract}, DSTestTransactor: DSTestTransactor{contract: contract}, DSTestFilterer: DSTestFilterer{contract: contract}}, nil
}

// NewDSTestCaller creates a new read-only instance of DSTest, bound to a specific deployed contract.
func NewDSTestCaller(address common.Address, caller bind.ContractCaller) (*DSTestCaller, error) {
	contract, err := bindDSTest(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &DSTestCaller{contract: contract}, nil
}

// NewDSTestTransactor creates a new write-only instance of DSTest, bound to a specific deployed contract.
func NewDSTestTransactor(address common.Address, transactor bind.ContractTransactor) (*DSTestTransactor, error) {
	contract, err := bindDSTest(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &DSTestTransactor{contract: contract}, nil
}

// NewDSTestFilterer creates a new log filterer instance of DSTest, bound to a specific deployed contract.
func NewDSTestFilterer(address common.Address, filterer bind.ContractFilterer) (*DSTestFilterer, error) {
	contract, err := bindDSTest(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &DSTestFilterer{contract: contract}, nil
}

// bindDSTest binds a generic wrapper to an already deployed contract.
func bindDSTest(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := DSTestMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_DSTest *DSTestRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _DSTest.Contract.DSTestCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_DSTest *DSTestRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DSTest.Contract.DSTestTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_DSTest *DSTestRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _DSTest.Contract.DSTestTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_DSTest *DSTestCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _DSTest.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_DSTest *DSTestTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DSTest.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_DSTest *DSTestTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _DSTest.Contract.contract.Transact(opts, method, params...)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_DSTest *DSTestCaller) ISTEST(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _DSTest.contract.Call(opts, &out, "IS_TEST")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_DSTest *DSTestSession) ISTEST() (bool, error) {
	return _DSTest.Contract.ISTEST(&_DSTest.CallOpts)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_DSTest *DSTestCallerSession) ISTEST() (bool, error) {
	return _DSTest.Contract.ISTEST(&_DSTest.CallOpts)
}

// Failed is a paid mutator transaction binding the contract method 0xba414fa6.
//
// Solidity: function failed() returns(bool)
func (_DSTest *DSTestTransactor) Failed(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DSTest.contract.Transact(opts, "failed")
}

// Failed is a paid mutator transaction binding the contract method 0xba414fa6.
//
// Solidity: function failed() returns(bool)
func (_DSTest *DSTestSession) Failed() (*types.Transaction, error) {
	return _DSTest.Contract.Failed(&_DSTest.TransactOpts)
}

// Failed is a paid mutator transaction binding the contract method 0xba414fa6.
//
// Solidity: function failed() returns(bool)
func (_DSTest *DSTestTransactorSession) Failed() (*types.Transaction, error) {
	return _DSTest.Contract.Failed(&_DSTest.TransactOpts)
}

// DSTestLogIterator is returned from FilterLog and is used to iterate over the raw logs and unpacked data for Log events raised by the DSTest contract.
type DSTestLogIterator struct {
	Event *DSTestLog // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DSTestLogIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DSTestLog)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DSTestLog)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DSTestLogIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DSTestLogIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DSTestLog represents a Log event raised by the DSTest contract.
type DSTestLog struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLog is a free log retrieval operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_DSTest *DSTestFilterer) FilterLog(opts *bind.FilterOpts) (*DSTestLogIterator, error) {

	logs, sub, err := _DSTest.contract.FilterLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return &DSTestLogIterator{contract: _DSTest.contract, event: "log", logs: logs, sub: sub}, nil
}

// WatchLog is a free log subscription operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_DSTest *DSTestFilterer) WatchLog(opts *bind.WatchOpts, sink chan<- *DSTestLog) (event.Subscription, error) {

	logs, sub, err := _DSTest.contract.WatchLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DSTestLog)
				if err := _DSTest.contract.UnpackLog(event, "log", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLog is a log parse operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_DSTest *DSTestFilterer) ParseLog(log types.Log) (*DSTestLog, error) {
	event := new(DSTestLog)
	if err := _DSTest.contract.UnpackLog(event, "log", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// DSTestLogAddressIterator is returned from FilterLogAddress and is used to iterate over the raw logs and unpacked data for LogAddress events raised by the DSTest contract.
type DSTestLogAddressIterator struct {
	Event *DSTestLogAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DSTestLogAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DSTestLogAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DSTestLogAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DSTestLogAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DSTestLogAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DSTestLogAddress represents a LogAddress event raised by the DSTest contract.
type DSTestLogAddress struct {
	Arg0 common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogAddress is a free log retrieval operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_DSTest *DSTestFilterer) FilterLogAddress(opts *bind.FilterOpts) (*DSTestLogAddressIterator, error) {

	logs, sub, err := _DSTest.contract.FilterLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return &DSTestLogAddressIterator{contract: _DSTest.contract, event: "log_address", logs: logs, sub: sub}, nil
}

// WatchLogAddress is a free log subscription operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_DSTest *DSTestFilterer) WatchLogAddress(opts *bind.WatchOpts, sink chan<- *DSTestLogAddress) (event.Subscription, error) {

	logs, sub, err := _DSTest.contract.WatchLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DSTestLogAddress)
				if err := _DSTest.contract.UnpackLog(event, "log_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogAddress is a log parse operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_DSTest *DSTestFilterer) ParseLogAddress(log types.Log) (*DSTestLogAddress, error) {
	event := new(DSTestLogAddress)
	if err := _DSTest.contract.UnpackLog(event, "log_address", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// DSTestLogBytesIterator is returned from FilterLogBytes and is used to iterate over the raw logs and unpacked data for LogBytes events raised by the DSTest contract.
type DSTestLogBytesIterator struct {
	Event *DSTestLogBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DSTestLogBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DSTestLogBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DSTestLogBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DSTestLogBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DSTestLogBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DSTestLogBytes represents a LogBytes event raised by the DSTest contract.
type DSTestLogBytes struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes is a free log retrieval operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_DSTest *DSTestFilterer) FilterLogBytes(opts *bind.FilterOpts) (*DSTestLogBytesIterator, error) {

	logs, sub, err := _DSTest.contract.FilterLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return &DSTestLogBytesIterator{contract: _DSTest.contract, event: "log_bytes", logs: logs, sub: sub}, nil
}

// WatchLogBytes is a free log subscription operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_DSTest *DSTestFilterer) WatchLogBytes(opts *bind.WatchOpts, sink chan<- *DSTestLogBytes) (event.Subscription, error) {

	logs, sub, err := _DSTest.contract.WatchLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DSTestLogBytes)
				if err := _DSTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes is a log parse operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_DSTest *DSTestFilterer) ParseLogBytes(log types.Log) (*DSTestLogBytes, error) {
	event := new(DSTestLogBytes)
	if err := _DSTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// DSTestLogBytes32Iterator is returned from FilterLogBytes32 and is used to iterate over the raw logs and unpacked data for LogBytes32 events raised by the DSTest contract.
type DSTestLogBytes32Iterator struct {
	Event *DSTestLogBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DSTestLogBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DSTestLogBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DSTestLogBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DSTestLogBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DSTestLogBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DSTestLogBytes32 represents a LogBytes32 event raised by the DSTest contract.
type DSTestLogBytes32 struct {
	Arg0 [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes32 is a free log retrieval operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_DSTest *DSTestFilterer) FilterLogBytes32(opts *bind.FilterOpts) (*DSTestLogBytes32Iterator, error) {

	logs, sub, err := _DSTest.contract.FilterLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return &DSTestLogBytes32Iterator{contract: _DSTest.contract, event: "log_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogBytes32 is a free log subscription operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_DSTest *DSTestFilterer) WatchLogBytes32(opts *bind.WatchOpts, sink chan<- *DSTestLogBytes32) (event.Subscription, error) {

	logs, sub, err := _DSTest.contract.WatchLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DSTestLogBytes32)
				if err := _DSTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes32 is a log parse operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_DSTest *DSTestFilterer) ParseLogBytes32(log types.Log) (*DSTestLogBytes32, error) {
	event := new(DSTestLogBytes32)
	if err := _DSTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// DSTestLogIntIterator is returned from FilterLogInt and is used to iterate over the raw logs and unpacked data for LogInt events raised by the DSTest contract.
type DSTestLogIntIterator struct {
	Event *DSTestLogInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DSTestLogIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DSTestLogInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DSTestLogInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DSTestLogIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DSTestLogIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DSTestLogInt represents a LogInt event raised by the DSTest contract.
type DSTestLogInt struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogInt is a free log retrieval operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_DSTest *DSTestFilterer) FilterLogInt(opts *bind.FilterOpts) (*DSTestLogIntIterator, error) {

	logs, sub, err := _DSTest.contract.FilterLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return &DSTestLogIntIterator{contract: _DSTest.contract, event: "log_int", logs: logs, sub: sub}, nil
}

// WatchLogInt is a free log subscription operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_DSTest *DSTestFilterer) WatchLogInt(opts *bind.WatchOpts, sink chan<- *DSTestLogInt) (event.Subscription, error) {

	logs, sub, err := _DSTest.contract.WatchLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DSTestLogInt)
				if err := _DSTest.contract.UnpackLog(event, "log_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogInt is a log parse operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_DSTest *DSTestFilterer) ParseLogInt(log types.Log) (*DSTestLogInt, error) {
	event := new(DSTestLogInt)
	if err := _DSTest.contract.UnpackLog(event, "log_int", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// DSTestLogNamedAddressIterator is returned from FilterLogNamedAddress and is used to iterate over the raw logs and unpacked data for LogNamedAddress events raised by the DSTest contract.
type DSTestLogNamedAddressIterator struct {
	Event *DSTestLogNamedAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DSTestLogNamedAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DSTestLogNamedAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DSTestLogNamedAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DSTestLogNamedAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DSTestLogNamedAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DSTestLogNamedAddress represents a LogNamedAddress event raised by the DSTest contract.
type DSTestLogNamedAddress struct {
	Key string
	Val common.Address
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedAddress is a free log retrieval operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_DSTest *DSTestFilterer) FilterLogNamedAddress(opts *bind.FilterOpts) (*DSTestLogNamedAddressIterator, error) {

	logs, sub, err := _DSTest.contract.FilterLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return &DSTestLogNamedAddressIterator{contract: _DSTest.contract, event: "log_named_address", logs: logs, sub: sub}, nil
}

// WatchLogNamedAddress is a free log subscription operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_DSTest *DSTestFilterer) WatchLogNamedAddress(opts *bind.WatchOpts, sink chan<- *DSTestLogNamedAddress) (event.Subscription, error) {

	logs, sub, err := _DSTest.contract.WatchLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DSTestLogNamedAddress)
				if err := _DSTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedAddress is a log parse operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_DSTest *DSTestFilterer) ParseLogNamedAddress(log types.Log) (*DSTestLogNamedAddress, error) {
	event := new(DSTestLogNamedAddress)
	if err := _DSTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// DSTestLogNamedBytesIterator is returned from FilterLogNamedBytes and is used to iterate over the raw logs and unpacked data for LogNamedBytes events raised by the DSTest contract.
type DSTestLogNamedBytesIterator struct {
	Event *DSTestLogNamedBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DSTestLogNamedBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DSTestLogNamedBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DSTestLogNamedBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DSTestLogNamedBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DSTestLogNamedBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DSTestLogNamedBytes represents a LogNamedBytes event raised by the DSTest contract.
type DSTestLogNamedBytes struct {
	Key string
	Val []byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes is a free log retrieval operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_DSTest *DSTestFilterer) FilterLogNamedBytes(opts *bind.FilterOpts) (*DSTestLogNamedBytesIterator, error) {

	logs, sub, err := _DSTest.contract.FilterLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return &DSTestLogNamedBytesIterator{contract: _DSTest.contract, event: "log_named_bytes", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes is a free log subscription operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_DSTest *DSTestFilterer) WatchLogNamedBytes(opts *bind.WatchOpts, sink chan<- *DSTestLogNamedBytes) (event.Subscription, error) {

	logs, sub, err := _DSTest.contract.WatchLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DSTestLogNamedBytes)
				if err := _DSTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes is a log parse operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_DSTest *DSTestFilterer) ParseLogNamedBytes(log types.Log) (*DSTestLogNamedBytes, error) {
	event := new(DSTestLogNamedBytes)
	if err := _DSTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// DSTestLogNamedBytes32Iterator is returned from FilterLogNamedBytes32 and is used to iterate over the raw logs and unpacked data for LogNamedBytes32 events raised by the DSTest contract.
type DSTestLogNamedBytes32Iterator struct {
	Event *DSTestLogNamedBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DSTestLogNamedBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DSTestLogNamedBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DSTestLogNamedBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DSTestLogNamedBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DSTestLogNamedBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DSTestLogNamedBytes32 represents a LogNamedBytes32 event raised by the DSTest contract.
type DSTestLogNamedBytes32 struct {
	Key string
	Val [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes32 is a free log retrieval operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_DSTest *DSTestFilterer) FilterLogNamedBytes32(opts *bind.FilterOpts) (*DSTestLogNamedBytes32Iterator, error) {

	logs, sub, err := _DSTest.contract.FilterLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return &DSTestLogNamedBytes32Iterator{contract: _DSTest.contract, event: "log_named_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes32 is a free log subscription operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_DSTest *DSTestFilterer) WatchLogNamedBytes32(opts *bind.WatchOpts, sink chan<- *DSTestLogNamedBytes32) (event.Subscription, error) {

	logs, sub, err := _DSTest.contract.WatchLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DSTestLogNamedBytes32)
				if err := _DSTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes32 is a log parse operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_DSTest *DSTestFilterer) ParseLogNamedBytes32(log types.Log) (*DSTestLogNamedBytes32, error) {
	event := new(DSTestLogNamedBytes32)
	if err := _DSTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// DSTestLogNamedDecimalIntIterator is returned from FilterLogNamedDecimalInt and is used to iterate over the raw logs and unpacked data for LogNamedDecimalInt events raised by the DSTest contract.
type DSTestLogNamedDecimalIntIterator struct {
	Event *DSTestLogNamedDecimalInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DSTestLogNamedDecimalIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DSTestLogNamedDecimalInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DSTestLogNamedDecimalInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DSTestLogNamedDecimalIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DSTestLogNamedDecimalIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DSTestLogNamedDecimalInt represents a LogNamedDecimalInt event raised by the DSTest contract.
type DSTestLogNamedDecimalInt struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalInt is a free log retrieval operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_DSTest *DSTestFilterer) FilterLogNamedDecimalInt(opts *bind.FilterOpts) (*DSTestLogNamedDecimalIntIterator, error) {

	logs, sub, err := _DSTest.contract.FilterLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return &DSTestLogNamedDecimalIntIterator{contract: _DSTest.contract, event: "log_named_decimal_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalInt is a free log subscription operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_DSTest *DSTestFilterer) WatchLogNamedDecimalInt(opts *bind.WatchOpts, sink chan<- *DSTestLogNamedDecimalInt) (event.Subscription, error) {

	logs, sub, err := _DSTest.contract.WatchLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DSTestLogNamedDecimalInt)
				if err := _DSTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalInt is a log parse operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_DSTest *DSTestFilterer) ParseLogNamedDecimalInt(log types.Log) (*DSTestLogNamedDecimalInt, error) {
	event := new(DSTestLogNamedDecimalInt)
	if err := _DSTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// DSTestLogNamedDecimalUintIterator is returned from FilterLogNamedDecimalUint and is used to iterate over the raw logs and unpacked data for LogNamedDecimalUint events raised by the DSTest contract.
type DSTestLogNamedDecimalUintIterator struct {
	Event *DSTestLogNamedDecimalUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DSTestLogNamedDecimalUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DSTestLogNamedDecimalUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DSTestLogNamedDecimalUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DSTestLogNamedDecimalUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DSTestLogNamedDecimalUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DSTestLogNamedDecimalUint represents a LogNamedDecimalUint event raised by the DSTest contract.
type DSTestLogNamedDecimalUint struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalUint is a free log retrieval operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_DSTest *DSTestFilterer) FilterLogNamedDecimalUint(opts *bind.FilterOpts) (*DSTestLogNamedDecimalUintIterator, error) {

	logs, sub, err := _DSTest.contract.FilterLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return &DSTestLogNamedDecimalUintIterator{contract: _DSTest.contract, event: "log_named_decimal_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalUint is a free log subscription operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_DSTest *DSTestFilterer) WatchLogNamedDecimalUint(opts *bind.WatchOpts, sink chan<- *DSTestLogNamedDecimalUint) (event.Subscription, error) {

	logs, sub, err := _DSTest.contract.WatchLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DSTestLogNamedDecimalUint)
				if err := _DSTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalUint is a log parse operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_DSTest *DSTestFilterer) ParseLogNamedDecimalUint(log types.Log) (*DSTestLogNamedDecimalUint, error) {
	event := new(DSTestLogNamedDecimalUint)
	if err := _DSTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// DSTestLogNamedIntIterator is returned from FilterLogNamedInt and is used to iterate over the raw logs and unpacked data for LogNamedInt events raised by the DSTest contract.
type DSTestLogNamedIntIterator struct {
	Event *DSTestLogNamedInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DSTestLogNamedIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DSTestLogNamedInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DSTestLogNamedInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DSTestLogNamedIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DSTestLogNamedIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DSTestLogNamedInt represents a LogNamedInt event raised by the DSTest contract.
type DSTestLogNamedInt struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedInt is a free log retrieval operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_DSTest *DSTestFilterer) FilterLogNamedInt(opts *bind.FilterOpts) (*DSTestLogNamedIntIterator, error) {

	logs, sub, err := _DSTest.contract.FilterLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return &DSTestLogNamedIntIterator{contract: _DSTest.contract, event: "log_named_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedInt is a free log subscription operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_DSTest *DSTestFilterer) WatchLogNamedInt(opts *bind.WatchOpts, sink chan<- *DSTestLogNamedInt) (event.Subscription, error) {

	logs, sub, err := _DSTest.contract.WatchLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DSTestLogNamedInt)
				if err := _DSTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedInt is a log parse operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_DSTest *DSTestFilterer) ParseLogNamedInt(log types.Log) (*DSTestLogNamedInt, error) {
	event := new(DSTestLogNamedInt)
	if err := _DSTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// DSTestLogNamedStringIterator is returned from FilterLogNamedString and is used to iterate over the raw logs and unpacked data for LogNamedString events raised by the DSTest contract.
type DSTestLogNamedStringIterator struct {
	Event *DSTestLogNamedString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DSTestLogNamedStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DSTestLogNamedString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DSTestLogNamedString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DSTestLogNamedStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DSTestLogNamedStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DSTestLogNamedString represents a LogNamedString event raised by the DSTest contract.
type DSTestLogNamedString struct {
	Key string
	Val string
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedString is a free log retrieval operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_DSTest *DSTestFilterer) FilterLogNamedString(opts *bind.FilterOpts) (*DSTestLogNamedStringIterator, error) {

	logs, sub, err := _DSTest.contract.FilterLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return &DSTestLogNamedStringIterator{contract: _DSTest.contract, event: "log_named_string", logs: logs, sub: sub}, nil
}

// WatchLogNamedString is a free log subscription operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_DSTest *DSTestFilterer) WatchLogNamedString(opts *bind.WatchOpts, sink chan<- *DSTestLogNamedString) (event.Subscription, error) {

	logs, sub, err := _DSTest.contract.WatchLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DSTestLogNamedString)
				if err := _DSTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedString is a log parse operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_DSTest *DSTestFilterer) ParseLogNamedString(log types.Log) (*DSTestLogNamedString, error) {
	event := new(DSTestLogNamedString)
	if err := _DSTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// DSTestLogNamedUintIterator is returned from FilterLogNamedUint and is used to iterate over the raw logs and unpacked data for LogNamedUint events raised by the DSTest contract.
type DSTestLogNamedUintIterator struct {
	Event *DSTestLogNamedUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DSTestLogNamedUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DSTestLogNamedUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DSTestLogNamedUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DSTestLogNamedUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DSTestLogNamedUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DSTestLogNamedUint represents a LogNamedUint event raised by the DSTest contract.
type DSTestLogNamedUint struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedUint is a free log retrieval operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_DSTest *DSTestFilterer) FilterLogNamedUint(opts *bind.FilterOpts) (*DSTestLogNamedUintIterator, error) {

	logs, sub, err := _DSTest.contract.FilterLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return &DSTestLogNamedUintIterator{contract: _DSTest.contract, event: "log_named_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedUint is a free log subscription operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_DSTest *DSTestFilterer) WatchLogNamedUint(opts *bind.WatchOpts, sink chan<- *DSTestLogNamedUint) (event.Subscription, error) {

	logs, sub, err := _DSTest.contract.WatchLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DSTestLogNamedUint)
				if err := _DSTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedUint is a log parse operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_DSTest *DSTestFilterer) ParseLogNamedUint(log types.Log) (*DSTestLogNamedUint, error) {
	event := new(DSTestLogNamedUint)
	if err := _DSTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// DSTestLogStringIterator is returned from FilterLogString and is used to iterate over the raw logs and unpacked data for LogString events raised by the DSTest contract.
type DSTestLogStringIterator struct {
	Event *DSTestLogString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DSTestLogStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DSTestLogString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DSTestLogString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DSTestLogStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DSTestLogStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DSTestLogString represents a LogString event raised by the DSTest contract.
type DSTestLogString struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogString is a free log retrieval operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_DSTest *DSTestFilterer) FilterLogString(opts *bind.FilterOpts) (*DSTestLogStringIterator, error) {

	logs, sub, err := _DSTest.contract.FilterLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return &DSTestLogStringIterator{contract: _DSTest.contract, event: "log_string", logs: logs, sub: sub}, nil
}

// WatchLogString is a free log subscription operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_DSTest *DSTestFilterer) WatchLogString(opts *bind.WatchOpts, sink chan<- *DSTestLogString) (event.Subscription, error) {

	logs, sub, err := _DSTest.contract.WatchLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DSTestLogString)
				if err := _DSTest.contract.UnpackLog(event, "log_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogString is a log parse operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_DSTest *DSTestFilterer) ParseLogString(log types.Log) (*DSTestLogString, error) {
	event := new(DSTestLogString)
	if err := _DSTest.contract.UnpackLog(event, "log_string", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// DSTestLogUintIterator is returned from FilterLogUint and is used to iterate over the raw logs and unpacked data for LogUint events raised by the DSTest contract.
type DSTestLogUintIterator struct {
	Event *DSTestLogUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DSTestLogUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DSTestLogUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DSTestLogUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DSTestLogUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DSTestLogUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DSTestLogUint represents a LogUint event raised by the DSTest contract.
type DSTestLogUint struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogUint is a free log retrieval operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_DSTest *DSTestFilterer) FilterLogUint(opts *bind.FilterOpts) (*DSTestLogUintIterator, error) {

	logs, sub, err := _DSTest.contract.FilterLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return &DSTestLogUintIterator{contract: _DSTest.contract, event: "log_uint", logs: logs, sub: sub}, nil
}

// WatchLogUint is a free log subscription operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_DSTest *DSTestFilterer) WatchLogUint(opts *bind.WatchOpts, sink chan<- *DSTestLogUint) (event.Subscription, error) {

	logs, sub, err := _DSTest.contract.WatchLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DSTestLogUint)
				if err := _DSTest.contract.UnpackLog(event, "log_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogUint is a log parse operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_DSTest *DSTestFilterer) ParseLogUint(log types.Log) (*DSTestLogUint, error) {
	event := new(DSTestLogUint)
	if err := _DSTest.contract.UnpackLog(event, "log_uint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// DSTestLogsIterator is returned from FilterLogs and is used to iterate over the raw logs and unpacked data for Logs events raised by the DSTest contract.
type DSTestLogsIterator struct {
	Event *DSTestLogs // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *DSTestLogsIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(DSTestLogs)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(DSTestLogs)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *DSTestLogsIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *DSTestLogsIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// DSTestLogs represents a Logs event raised by the DSTest contract.
type DSTestLogs struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogs is a free log retrieval operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_DSTest *DSTestFilterer) FilterLogs(opts *bind.FilterOpts) (*DSTestLogsIterator, error) {

	logs, sub, err := _DSTest.contract.FilterLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return &DSTestLogsIterator{contract: _DSTest.contract, event: "logs", logs: logs, sub: sub}, nil
}

// WatchLogs is a free log subscription operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_DSTest *DSTestFilterer) WatchLogs(opts *bind.WatchOpts, sink chan<- *DSTestLogs) (event.Subscription, error) {

	logs, sub, err := _DSTest.contract.WatchLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(DSTestLogs)
				if err := _DSTest.contract.UnpackLog(event, "logs", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogs is a log parse operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_DSTest *DSTestFilterer) ParseLogs(log types.Log) (*DSTestLogs, error) {
	event := new(DSTestLogs)
	if err := _DSTest.contract.UnpackLog(event, "logs", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20MetaData contains all meta data concerning the ERC20 contract.
var ERC20MetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x608060405234801561001057600080fd5b50604051611777380380611777833981810160405281019061003291906101ce565b81600390816100419190610467565b5080600490816100519190610467565b505050610539565b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6100c082610077565b810181811067ffffffffffffffff821117156100df576100de610088565b5b80604052505050565b60006100f2610059565b90506100fe82826100b7565b919050565b600067ffffffffffffffff82111561011e5761011d610088565b5b61012782610077565b9050602081019050919050565b60005b83811015610152578082015181840152602081019050610137565b60008484015250505050565b600061017161016c84610103565b6100e8565b90508281526020810184848401111561018d5761018c610072565b5b610198848285610134565b509392505050565b600082601f8301126101b5576101b461006d565b5b81516101c584826020860161015e565b91505092915050565b600080604083850312156101e5576101e4610063565b5b600083015167ffffffffffffffff81111561020357610202610068565b5b61020f858286016101a0565b925050602083015167ffffffffffffffff8111156102305761022f610068565b5b61023c858286016101a0565b9150509250929050565b600081519050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b6000600282049050600182168061029857607f821691505b6020821081036102ab576102aa610251565b5b50919050565b60008190508160005260206000209050919050565b60006020601f8301049050919050565b600082821b905092915050565b6000600883026103137fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff826102d6565b61031d86836102d6565b95508019841693508086168417925050509392505050565b6000819050919050565b6000819050919050565b600061036461035f61035a84610335565b61033f565b610335565b9050919050565b6000819050919050565b61037e83610349565b61039261038a8261036b565b8484546102e3565b825550505050565b600090565b6103a761039a565b6103b2818484610375565b505050565b5b818110156103d6576103cb60008261039f565b6001810190506103b8565b5050565b601f82111561041b576103ec816102b1565b6103f5846102c6565b81016020851015610404578190505b610418610410856102c6565b8301826103b7565b50505b505050565b600082821c905092915050565b600061043e60001984600802610420565b1980831691505092915050565b6000610457838361042d565b9150826002028217905092915050565b61047082610246565b67ffffffffffffffff81111561048957610488610088565b5b6104938254610280565b61049e8282856103da565b600060209050601f8311600181146104d157600084156104bf578287015190505b6104c9858261044b565b865550610531565b601f1984166104df866102b1565b60005b82811015610507578489015182556001820191506020850194506020810190506104e2565b868310156105245784890151610520601f89168261042d565b8355505b6001600288020188555050505b505050505050565b61122f806105486000396000f3fe608060405234801561001057600080fd5b50600436106100a95760003560e01c80633950935111610071578063395093511461016857806370a082311461019857806395d89b41146101c8578063a457c2d7146101e6578063a9059cbb14610216578063dd62ed3e14610246576100a9565b806306fdde03146100ae578063095ea7b3146100cc57806318160ddd146100fc57806323b872dd1461011a578063313ce5671461014a575b600080fd5b6100b6610276565b6040516100c39190610b0c565b60405180910390f35b6100e660048036038101906100e19190610bc7565b610308565b6040516100f39190610c22565b60405180910390f35b61010461032b565b6040516101119190610c4c565b60405180910390f35b610134600480360381019061012f9190610c67565b610335565b6040516101419190610c22565b60405180910390f35b610152610364565b60405161015f9190610cd6565b60405180910390f35b610182600480360381019061017d9190610bc7565b61036d565b60405161018f9190610c22565b60405180910390f35b6101b260048036038101906101ad9190610cf1565b6103a4565b6040516101bf9190610c4c565b60405180910390f35b6101d06103ec565b6040516101dd9190610b0c565b60405180910390f35b61020060048036038101906101fb9190610bc7565b61047e565b60405161020d9190610c22565b60405180910390f35b610230600480360381019061022b9190610bc7565b6104f5565b60405161023d9190610c22565b60405180910390f35b610260600480360381019061025b9190610d1e565b610518565b60405161026d9190610c4c565b60405180910390f35b60606003805461028590610d8d565b80601f01602080910402602001604051908101604052809291908181526020018280546102b190610d8d565b80156102fe5780601f106102d3576101008083540402835291602001916102fe565b820191906000526020600020905b8154815290600101906020018083116102e157829003601f168201915b5050505050905090565b60008061031361059f565b90506103208185856105a7565b600191505092915050565b6000600254905090565b60008061034061059f565b905061034d858285610770565b6103588585856107fc565b60019150509392505050565b60006012905090565b60008061037861059f565b905061039981858561038a8589610518565b6103949190610ded565b6105a7565b600191505092915050565b60008060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050919050565b6060600480546103fb90610d8d565b80601f016020809104026020016040519081016040528092919081815260200182805461042790610d8d565b80156104745780601f1061044957610100808354040283529160200191610474565b820191906000526020600020905b81548152906001019060200180831161045757829003601f168201915b5050505050905090565b60008061048961059f565b905060006104978286610518565b9050838110156104dc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104d390610e93565b60405180910390fd5b6104e982868684036105a7565b60019250505092915050565b60008061050061059f565b905061050d8185856107fc565b600191505092915050565b6000600160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905092915050565b600033905090565b600073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1603610616576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161060d90610f25565b60405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1603610685576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161067c90610fb7565b60405180910390fd5b80600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925836040516107639190610c4c565b60405180910390a3505050565b600061077c8484610518565b90507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81146107f657818110156107e8576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016107df90611023565b60405180910390fd5b6107f584848484036105a7565b5b50505050565b600073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff160361086b576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610862906110b5565b60405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16036108da576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016108d190611147565b60405180910390fd5b6108e5838383610a72565b60008060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205490508181101561096b576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610962906111d9565b60405180910390fd5b8181036000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550816000808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef84604051610a599190610c4c565b60405180910390a3610a6c848484610a77565b50505050565b505050565b505050565b600081519050919050565b600082825260208201905092915050565b60005b83811015610ab6578082015181840152602081019050610a9b565b60008484015250505050565b6000601f19601f8301169050919050565b6000610ade82610a7c565b610ae88185610a87565b9350610af8818560208601610a98565b610b0181610ac2565b840191505092915050565b60006020820190508181036000830152610b268184610ad3565b905092915050565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610b5e82610b33565b9050919050565b610b6e81610b53565b8114610b7957600080fd5b50565b600081359050610b8b81610b65565b92915050565b6000819050919050565b610ba481610b91565b8114610baf57600080fd5b50565b600081359050610bc181610b9b565b92915050565b60008060408385031215610bde57610bdd610b2e565b5b6000610bec85828601610b7c565b9250506020610bfd85828601610bb2565b9150509250929050565b60008115159050919050565b610c1c81610c07565b82525050565b6000602082019050610c376000830184610c13565b92915050565b610c4681610b91565b82525050565b6000602082019050610c616000830184610c3d565b92915050565b600080600060608486031215610c8057610c7f610b2e565b5b6000610c8e86828701610b7c565b9350506020610c9f86828701610b7c565b9250506040610cb086828701610bb2565b9150509250925092565b600060ff82169050919050565b610cd081610cba565b82525050565b6000602082019050610ceb6000830184610cc7565b92915050565b600060208284031215610d0757610d06610b2e565b5b6000610d1584828501610b7c565b91505092915050565b60008060408385031215610d3557610d34610b2e565b5b6000610d4385828601610b7c565b9250506020610d5485828601610b7c565b9150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680610da557607f821691505b602082108103610db857610db7610d5e565b5b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000610df882610b91565b9150610e0383610b91565b9250828201905080821115610e1b57610e1a610dbe565b5b92915050565b7f45524332303a2064656372656173656420616c6c6f77616e63652062656c6f7760008201527f207a65726f000000000000000000000000000000000000000000000000000000602082015250565b6000610e7d602583610a87565b9150610e8882610e21565b604082019050919050565b60006020820190508181036000830152610eac81610e70565b9050919050565b7f45524332303a20617070726f76652066726f6d20746865207a65726f2061646460008201527f7265737300000000000000000000000000000000000000000000000000000000602082015250565b6000610f0f602483610a87565b9150610f1a82610eb3565b604082019050919050565b60006020820190508181036000830152610f3e81610f02565b9050919050565b7f45524332303a20617070726f766520746f20746865207a65726f20616464726560008201527f7373000000000000000000000000000000000000000000000000000000000000602082015250565b6000610fa1602283610a87565b9150610fac82610f45565b604082019050919050565b60006020820190508181036000830152610fd081610f94565b9050919050565b7f45524332303a20696e73756666696369656e7420616c6c6f77616e6365000000600082015250565b600061100d601d83610a87565b915061101882610fd7565b602082019050919050565b6000602082019050818103600083015261103c81611000565b9050919050565b7f45524332303a207472616e736665722066726f6d20746865207a65726f20616460008201527f6472657373000000000000000000000000000000000000000000000000000000602082015250565b600061109f602583610a87565b91506110aa82611043565b604082019050919050565b600060208201905081810360008301526110ce81611092565b9050919050565b7f45524332303a207472616e7366657220746f20746865207a65726f206164647260008201527f6573730000000000000000000000000000000000000000000000000000000000602082015250565b6000611131602383610a87565b915061113c826110d5565b604082019050919050565b6000602082019050818103600083015261116081611124565b9050919050565b7f45524332303a207472616e7366657220616d6f756e742065786365656473206260008201527f616c616e63650000000000000000000000000000000000000000000000000000602082015250565b60006111c3602683610a87565b91506111ce82611167565b604082019050919050565b600060208201905081810360008301526111f2816111b6565b905091905056fea2646970667358221220c02b2a39acab76859bade0cecf97bf76856a692f704aac354de5a91a556a12b864736f6c634300081a0033",
}

// ERC20ABI is the input ABI used to generate the binding from.
// Deprecated: Use ERC20MetaData.ABI instead.
var ERC20ABI = ERC20MetaData.ABI

// ERC20Bin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use ERC20MetaData.Bin instead.
var ERC20Bin = ERC20MetaData.Bin

// DeployERC20 deploys a new Ethereum contract, binding an instance of ERC20 to it.
func DeployERC20(auth *bind.TransactOpts, backend bind.ContractBackend, name_ string, symbol_ string) (common.Address, *types.Transaction, *ERC20, error) {
	parsed, err := ERC20MetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(ERC20Bin), backend, name_, symbol_)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ERC20{ERC20Caller: ERC20Caller{contract: contract}, ERC20Transactor: ERC20Transactor{contract: contract}, ERC20Filterer: ERC20Filterer{contract: contract}}, nil
}

// ERC20 is an auto generated Go binding around an Ethereum contract.
type ERC20 struct {
	ERC20Caller     // Read-only binding to the contract
	ERC20Transactor // Write-only binding to the contract
	ERC20Filterer   // Log filterer for contract events
}

// ERC20Caller is an auto generated read-only Go binding around an Ethereum contract.
type ERC20Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20Transactor is an auto generated write-only Go binding around an Ethereum contract.
type ERC20Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ERC20Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ERC20Session struct {
	Contract     *ERC20            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC20CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ERC20CallerSession struct {
	Contract *ERC20Caller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// ERC20TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ERC20TransactorSession struct {
	Contract     *ERC20Transactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC20Raw is an auto generated low-level Go binding around an Ethereum contract.
type ERC20Raw struct {
	Contract *ERC20 // Generic contract binding to access the raw methods on
}

// ERC20CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ERC20CallerRaw struct {
	Contract *ERC20Caller // Generic read-only contract binding to access the raw methods on
}

// ERC20TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ERC20TransactorRaw struct {
	Contract *ERC20Transactor // Generic write-only contract binding to access the raw methods on
}

// NewERC20 creates a new instance of ERC20, bound to a specific deployed contract.
func NewERC20(address common.Address, backend bind.ContractBackend) (*ERC20, error) {
	contract, err := bindERC20(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC20{ERC20Caller: ERC20Caller{contract: contract}, ERC20Transactor: ERC20Transactor{contract: contract}, ERC20Filterer: ERC20Filterer{contract: contract}}, nil
}

// NewERC20Caller creates a new read-only instance of ERC20, bound to a specific deployed contract.
func NewERC20Caller(address common.Address, caller bind.ContractCaller) (*ERC20Caller, error) {
	contract, err := bindERC20(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20Caller{contract: contract}, nil
}

// NewERC20Transactor creates a new write-only instance of ERC20, bound to a specific deployed contract.
func NewERC20Transactor(address common.Address, transactor bind.ContractTransactor) (*ERC20Transactor, error) {
	contract, err := bindERC20(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20Transactor{contract: contract}, nil
}

// NewERC20Filterer creates a new log filterer instance of ERC20, bound to a specific deployed contract.
func NewERC20Filterer(address common.Address, filterer bind.ContractFilterer) (*ERC20Filterer, error) {
	contract, err := bindERC20(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC20Filterer{contract: contract}, nil
}

// bindERC20 binds a generic wrapper to an already deployed contract.
func bindERC20(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ERC20MetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20 *ERC20Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ERC20.Contract.ERC20Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20 *ERC20Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20.Contract.ERC20Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20 *ERC20Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20.Contract.ERC20Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20 *ERC20CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ERC20.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20 *ERC20TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20 *ERC20TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20 *ERC20Caller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _ERC20.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20 *ERC20Session) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _ERC20.Contract.Allowance(&_ERC20.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20 *ERC20CallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _ERC20.Contract.Allowance(&_ERC20.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20 *ERC20Caller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _ERC20.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20 *ERC20Session) BalanceOf(account common.Address) (*big.Int, error) {
	return _ERC20.Contract.BalanceOf(&_ERC20.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20 *ERC20CallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _ERC20.Contract.BalanceOf(&_ERC20.CallOpts, account)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20 *ERC20Caller) Decimals(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _ERC20.contract.Call(opts, &out, "decimals")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20 *ERC20Session) Decimals() (uint8, error) {
	return _ERC20.Contract.Decimals(&_ERC20.CallOpts)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20 *ERC20CallerSession) Decimals() (uint8, error) {
	return _ERC20.Contract.Decimals(&_ERC20.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20 *ERC20Caller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _ERC20.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20 *ERC20Session) Name() (string, error) {
	return _ERC20.Contract.Name(&_ERC20.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20 *ERC20CallerSession) Name() (string, error) {
	return _ERC20.Contract.Name(&_ERC20.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20 *ERC20Caller) Symbol(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _ERC20.contract.Call(opts, &out, "symbol")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20 *ERC20Session) Symbol() (string, error) {
	return _ERC20.Contract.Symbol(&_ERC20.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20 *ERC20CallerSession) Symbol() (string, error) {
	return _ERC20.Contract.Symbol(&_ERC20.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20 *ERC20Caller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ERC20.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20 *ERC20Session) TotalSupply() (*big.Int, error) {
	return _ERC20.Contract.TotalSupply(&_ERC20.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20 *ERC20CallerSession) TotalSupply() (*big.Int, error) {
	return _ERC20.Contract.TotalSupply(&_ERC20.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20 *ERC20Transactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20 *ERC20Session) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.Approve(&_ERC20.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20 *ERC20TransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.Approve(&_ERC20.TransactOpts, spender, amount)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20 *ERC20Transactor) DecreaseAllowance(opts *bind.TransactOpts, spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20.contract.Transact(opts, "decreaseAllowance", spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20 *ERC20Session) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.DecreaseAllowance(&_ERC20.TransactOpts, spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20 *ERC20TransactorSession) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.DecreaseAllowance(&_ERC20.TransactOpts, spender, subtractedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20 *ERC20Transactor) IncreaseAllowance(opts *bind.TransactOpts, spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20.contract.Transact(opts, "increaseAllowance", spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20 *ERC20Session) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.IncreaseAllowance(&_ERC20.TransactOpts, spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20 *ERC20TransactorSession) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.IncreaseAllowance(&_ERC20.TransactOpts, spender, addedValue)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20 *ERC20Transactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.contract.Transact(opts, "transfer", to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20 *ERC20Session) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.Transfer(&_ERC20.TransactOpts, to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20 *ERC20TransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.Transfer(&_ERC20.TransactOpts, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20 *ERC20Transactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.contract.Transact(opts, "transferFrom", from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20 *ERC20Session) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.TransferFrom(&_ERC20.TransactOpts, from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20 *ERC20TransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.TransferFrom(&_ERC20.TransactOpts, from, to, amount)
}

// ERC20ApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the ERC20 contract.
type ERC20ApprovalIterator struct {
	Event *ERC20Approval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20ApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20Approval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20Approval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20ApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20ApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20Approval represents a Approval event raised by the ERC20 contract.
type ERC20Approval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20 *ERC20Filterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*ERC20ApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _ERC20.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &ERC20ApprovalIterator{contract: _ERC20.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20 *ERC20Filterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *ERC20Approval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _ERC20.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20Approval)
				if err := _ERC20.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20 *ERC20Filterer) ParseApproval(log types.Log) (*ERC20Approval, error) {
	event := new(ERC20Approval)
	if err := _ERC20.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20TransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the ERC20 contract.
type ERC20TransferIterator struct {
	Event *ERC20Transfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20TransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20Transfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20Transfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20TransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20TransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20Transfer represents a Transfer event raised by the ERC20 contract.
type ERC20Transfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20 *ERC20Filterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*ERC20TransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _ERC20.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &ERC20TransferIterator{contract: _ERC20.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20 *ERC20Filterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *ERC20Transfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _ERC20.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20Transfer)
				if err := _ERC20.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20 *ERC20Filterer) ParseTransfer(log types.Log) (*ERC20Transfer, error) {
	event := new(ERC20Transfer)
	if err := _ERC20.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20NativeMinterMetaData contains all meta data concerning the ERC20NativeMinter contract.
var ERC20NativeMinterMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"initSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Mintdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"mintdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"revoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x6080604052730200000000000000000000000000000000000001600760006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555034801561006557600080fd5b50604051612e1c380380612e1c83398181016040528101906100879190610420565b7302000000000000000000000000000000000000016040518060400160405280601681526020017f45524332304e61746976654d696e746572546f6b656e000000000000000000008152506040518060400160405280600481526020017f584d504c0000000000000000000000000000000000000000000000000000000081525081600390816101179190610693565b5080600490816101279190610693565b50505061014661013b6101ab60201b60201c565b6101b360201b60201c565b80600660006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550506101a56101996101ab60201b60201c565b8261027960201b60201c565b5061086f565b600033905090565b6000600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905081600560006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16036102e8576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016102df906107c2565b60405180910390fd5b6102fa600083836103db60201b60201c565b806002600082825461030c9190610811565b92505081905550806000808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508173ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040516103bd9190610854565b60405180910390a36103d7600083836103e060201b60201c565b5050565b505050565b505050565b600080fd5b6000819050919050565b6103fd816103ea565b811461040857600080fd5b50565b60008151905061041a816103f4565b92915050565b600060208284031215610436576104356103e5565b5b60006104448482850161040b565b91505092915050565b600081519050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b600060028204905060018216806104ce57607f821691505b6020821081036104e1576104e0610487565b5b50919050565b60008190508160005260206000209050919050565b60006020601f8301049050919050565b600082821b905092915050565b6000600883026105497fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8261050c565b610553868361050c565b95508019841693508086168417925050509392505050565b6000819050919050565b600061059061058b610586846103ea565b61056b565b6103ea565b9050919050565b6000819050919050565b6105aa83610575565b6105be6105b682610597565b848454610519565b825550505050565b600090565b6105d36105c6565b6105de8184846105a1565b505050565b5b81811015610602576105f76000826105cb565b6001810190506105e4565b5050565b601f82111561064757610618816104e7565b610621846104fc565b81016020851015610630578190505b61064461063c856104fc565b8301826105e3565b50505b505050565b600082821c905092915050565b600061066a6000198460080261064c565b1980831691505092915050565b60006106838383610659565b9150826002028217905092915050565b61069c8261044d565b67ffffffffffffffff8111156106b5576106b4610458565b5b6106bf82546104b6565b6106ca828285610606565b600060209050601f8311600181146106fd57600084156106eb578287015190505b6106f58582610677565b86555061075d565b601f19841661070b866104e7565b60005b828110156107335784890151825560018201915060208501945060208101905061070e565b86831015610750578489015161074c601f891682610659565b8355505b6001600288020188555050505b505050505050565b600082825260208201905092915050565b7f45524332303a206d696e7420746f20746865207a65726f206164647265737300600082015250565b60006107ac601f83610765565b91506107b782610776565b602082019050919050565b600060208201905081810360008301526107db8161079f565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061081c826103ea565b9150610827836103ea565b925082820190508082111561083f5761083e6107e2565b5b92915050565b61084e816103ea565b82525050565b60006020820190506108696000830184610845565b92915050565b61259e8061087e6000396000f3fe6080604052600436106101665760003560e01c8063715018a6116100d1578063a457c2d71161008a578063d0ebdbe711610064578063d0ebdbe714610541578063dd62ed3e1461056a578063f2fde38b146105a7578063f3ae2415146105d057610166565b8063a457c2d7146104bd578063a9059cbb146104fa578063d0e30db01461053757610166565b8063715018a6146103c157806374a8f103146103d85780638da5cb5b146104015780639015d3711461042c57806395d89b41146104695780639dc29fac1461049457610166565b806324d7806c1161012357806324d7806c1461028d578063313ce567146102ca57806339509351146102f557806340c10f1914610332578063704b6c021461035b57806370a082311461038457610166565b80630356b6cd1461016b57806306fdde0314610194578063095ea7b3146101bf5780630aaf7043146101fc57806318160ddd1461022557806323b872dd14610250575b600080fd5b34801561017757600080fd5b50610192600480360381019061018d9190611a6a565b61060d565b005b3480156101a057600080fd5b506101a961070c565b6040516101b69190611b27565b60405180910390f35b3480156101cb57600080fd5b506101e660048036038101906101e19190611ba7565b61079e565b6040516101f39190611c02565b60405180910390f35b34801561020857600080fd5b50610223600480360381019061021e9190611c1d565b6107c1565b005b34801561023157600080fd5b5061023a6107d5565b6040516102479190611c59565b60405180910390f35b34801561025c57600080fd5b5061027760048036038101906102729190611c74565b6107df565b6040516102849190611c02565b60405180910390f35b34801561029957600080fd5b506102b460048036038101906102af9190611c1d565b61080e565b6040516102c19190611c02565b60405180910390f35b3480156102d657600080fd5b506102df6108bb565b6040516102ec9190611ce3565b60405180910390f35b34801561030157600080fd5b5061031c60048036038101906103179190611ba7565b6108c4565b6040516103299190611c02565b60405180910390f35b34801561033e57600080fd5b5061035960048036038101906103549190611ba7565b6108fb565b005b34801561036757600080fd5b50610382600480360381019061037d9190611c1d565b610911565b005b34801561039057600080fd5b506103ab60048036038101906103a69190611c1d565b610925565b6040516103b89190611c59565b60405180910390f35b3480156103cd57600080fd5b506103d661096d565b005b3480156103e457600080fd5b506103ff60048036038101906103fa9190611c1d565b610981565b005b34801561040d57600080fd5b50610416610995565b6040516104239190611d0d565b60405180910390f35b34801561043857600080fd5b50610453600480360381019061044e9190611c1d565b6109bf565b6040516104609190611c02565b60405180910390f35b34801561047557600080fd5b5061047e610a6d565b60405161048b9190611b27565b60405180910390f35b3480156104a057600080fd5b506104bb60048036038101906104b69190611ba7565b610aff565b005b3480156104c957600080fd5b506104e460048036038101906104df9190611ba7565b610b15565b6040516104f19190611c02565b60405180910390f35b34801561050657600080fd5b50610521600480360381019061051c9190611ba7565b610b8c565b60405161052e9190611c02565b60405180910390f35b61053f610baf565b005b34801561054d57600080fd5b5061056860048036038101906105639190611c1d565b610c72565b005b34801561057657600080fd5b50610591600480360381019061058c9190611d28565b610c86565b60405161059e9190611c59565b60405180910390f35b3480156105b357600080fd5b506105ce60048036038101906105c99190611c1d565b610d0d565b005b3480156105dc57600080fd5b506105f760048036038101906105f29190611c1d565b610d90565b6040516106049190611c02565b60405180910390f35b61061e610618610e3d565b82610e45565b600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16634f5aaaba610664610e3d565b836040518363ffffffff1660e01b8152600401610682929190611d68565b600060405180830381600087803b15801561069c57600080fd5b505af11580156106b0573d6000803e3d6000fd5b505050506106bc610e3d565b73ffffffffffffffffffffffffffffffffffffffff167f25bedde6c8ebd3a89b719a16299dbfe271c7bffa42fe1ac1a52e15ab0cb767e6826040516107019190611c59565b60405180910390a250565b60606003805461071b90611dc0565b80601f016020809104026020016040519081016040528092919081815260200182805461074790611dc0565b80156107945780601f1061076957610100808354040283529160200191610794565b820191906000526020600020905b81548152906001019060200180831161077757829003601f168201915b5050505050905090565b6000806107a9610e3d565b90506107b6818585611012565b600191505092915050565b6107c96111db565b6107d281611259565b50565b6000600254905090565b6000806107ea610e3d565b90506107f78582856112e9565b610802858585611375565b60019150509392505050565b600080600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b815260040161086c9190611d0d565b602060405180830381865afa158015610889573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108ad9190611e06565b905060028114915050919050565b60006012905090565b6000806108cf610e3d565b90506108f08185856108e18589610c86565b6108eb9190611e62565b611012565b600191505092915050565b6109036111db565b61090d82826115eb565b5050565b6109196111db565b61092281611741565b50565b60008060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050919050565b6109756111db565b61097f60006117d1565b565b6109896111db565b61099281611897565b50565b6000600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b600080600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b8152600401610a1d9190611d0d565b602060405180830381865afa158015610a3a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a5e9190611e06565b90506000811415915050919050565b606060048054610a7c90611dc0565b80601f0160208091040260200160405190810160405280929190818152602001828054610aa890611dc0565b8015610af55780601f10610aca57610100808354040283529160200191610af5565b820191906000526020600020905b815481529060010190602001808311610ad857829003601f168201915b5050505050905090565b610b076111db565b610b118282610e45565b5050565b600080610b20610e3d565b90506000610b2e8286610c86565b905083811015610b73576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b6a90611f08565b60405180910390fd5b610b808286868403611012565b60019250505092915050565b600080610b97610e3d565b9050610ba4818585611375565b600191505092915050565b73010000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166108fc349081150290604051600060405180830381858888f19350505050158015610c09573d6000803e3d6000fd5b50610c1b610c15610e3d565b346115eb565b610c23610e3d565b73ffffffffffffffffffffffffffffffffffffffff167fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c34604051610c689190611c59565b60405180910390a2565b610c7a6111db565b610c8381611995565b50565b6000600160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905092915050565b610d156111db565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603610d84576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610d7b90611f9a565b60405180910390fd5b610d8d816117d1565b50565b600080600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b8152600401610dee9190611d0d565b602060405180830381865afa158015610e0b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e2f9190611e06565b905060038114915050919050565b600033905090565b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1603610eb4576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610eab9061202c565b60405180910390fd5b610ec082600083611a25565b60008060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905081811015610f46576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610f3d906120be565b60405180910390fd5b8181036000808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555081600260008282540392505081905550600073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef84604051610ff99190611c59565b60405180910390a361100d83600084611a2a565b505050565b600073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1603611081576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161107890612150565b60405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16036110f0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016110e7906121e2565b60405180910390fd5b80600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925836040516111ce9190611c59565b60405180910390a3505050565b6111e3610e3d565b73ffffffffffffffffffffffffffffffffffffffff16611201610995565b73ffffffffffffffffffffffffffffffffffffffff1614611257576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161124e9061224e565b60405180910390fd5b565b600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043826040518263ffffffff1660e01b81526004016112b49190611d0d565b600060405180830381600087803b1580156112ce57600080fd5b505af11580156112e2573d6000803e3d6000fd5b5050505050565b60006112f58484610c86565b90507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff811461136f5781811015611361576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611358906122ba565b60405180910390fd5b61136e8484848403611012565b5b50505050565b600073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16036113e4576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016113db9061234c565b60405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1603611453576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161144a906123de565b60405180910390fd5b61145e838383611a25565b60008060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050818110156114e4576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016114db90612470565b60405180910390fd5b8181036000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550816000808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040516115d29190611c59565b60405180910390a36115e5848484611a2a565b50505050565b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff160361165a576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611651906124dc565b60405180910390fd5b61166660008383611a25565b80600260008282546116789190611e62565b92505081905550806000808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508173ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040516117299190611c59565b60405180910390a361173d60008383611a2a565b5050565b600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663704b6c02826040518263ffffffff1660e01b815260040161179c9190611d0d565b600060405180830381600087803b1580156117b657600080fd5b505af11580156117ca573d6000803e3d6000fd5b5050505050565b6000600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905081600560006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b8073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1603611905576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016118fc90612548565b60405180910390fd5b600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638c6bfb3b826040518263ffffffff1660e01b81526004016119609190611d0d565b600060405180830381600087803b15801561197a57600080fd5b505af115801561198e573d6000803e3d6000fd5b5050505050565b600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d0ebdbe7826040518263ffffffff1660e01b81526004016119f09190611d0d565b600060405180830381600087803b158015611a0a57600080fd5b505af1158015611a1e573d6000803e3d6000fd5b5050505050565b505050565b505050565b600080fd5b6000819050919050565b611a4781611a34565b8114611a5257600080fd5b50565b600081359050611a6481611a3e565b92915050565b600060208284031215611a8057611a7f611a2f565b5b6000611a8e84828501611a55565b91505092915050565b600081519050919050565b600082825260208201905092915050565b60005b83811015611ad1578082015181840152602081019050611ab6565b60008484015250505050565b6000601f19601f8301169050919050565b6000611af982611a97565b611b038185611aa2565b9350611b13818560208601611ab3565b611b1c81611add565b840191505092915050565b60006020820190508181036000830152611b418184611aee565b905092915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000611b7482611b49565b9050919050565b611b8481611b69565b8114611b8f57600080fd5b50565b600081359050611ba181611b7b565b92915050565b60008060408385031215611bbe57611bbd611a2f565b5b6000611bcc85828601611b92565b9250506020611bdd85828601611a55565b9150509250929050565b60008115159050919050565b611bfc81611be7565b82525050565b6000602082019050611c176000830184611bf3565b92915050565b600060208284031215611c3357611c32611a2f565b5b6000611c4184828501611b92565b91505092915050565b611c5381611a34565b82525050565b6000602082019050611c6e6000830184611c4a565b92915050565b600080600060608486031215611c8d57611c8c611a2f565b5b6000611c9b86828701611b92565b9350506020611cac86828701611b92565b9250506040611cbd86828701611a55565b9150509250925092565b600060ff82169050919050565b611cdd81611cc7565b82525050565b6000602082019050611cf86000830184611cd4565b92915050565b611d0781611b69565b82525050565b6000602082019050611d226000830184611cfe565b92915050565b60008060408385031215611d3f57611d3e611a2f565b5b6000611d4d85828601611b92565b9250506020611d5e85828601611b92565b9150509250929050565b6000604082019050611d7d6000830185611cfe565b611d8a6020830184611c4a565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680611dd857607f821691505b602082108103611deb57611dea611d91565b5b50919050565b600081519050611e0081611a3e565b92915050565b600060208284031215611e1c57611e1b611a2f565b5b6000611e2a84828501611df1565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000611e6d82611a34565b9150611e7883611a34565b9250828201905080821115611e9057611e8f611e33565b5b92915050565b7f45524332303a2064656372656173656420616c6c6f77616e63652062656c6f7760008201527f207a65726f000000000000000000000000000000000000000000000000000000602082015250565b6000611ef2602583611aa2565b9150611efd82611e96565b604082019050919050565b60006020820190508181036000830152611f2181611ee5565b9050919050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160008201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b6000611f84602683611aa2565b9150611f8f82611f28565b604082019050919050565b60006020820190508181036000830152611fb381611f77565b9050919050565b7f45524332303a206275726e2066726f6d20746865207a65726f2061646472657360008201527f7300000000000000000000000000000000000000000000000000000000000000602082015250565b6000612016602183611aa2565b915061202182611fba565b604082019050919050565b6000602082019050818103600083015261204581612009565b9050919050565b7f45524332303a206275726e20616d6f756e7420657863656564732062616c616e60008201527f6365000000000000000000000000000000000000000000000000000000000000602082015250565b60006120a8602283611aa2565b91506120b38261204c565b604082019050919050565b600060208201905081810360008301526120d78161209b565b9050919050565b7f45524332303a20617070726f76652066726f6d20746865207a65726f2061646460008201527f7265737300000000000000000000000000000000000000000000000000000000602082015250565b600061213a602483611aa2565b9150612145826120de565b604082019050919050565b600060208201905081810360008301526121698161212d565b9050919050565b7f45524332303a20617070726f766520746f20746865207a65726f20616464726560008201527f7373000000000000000000000000000000000000000000000000000000000000602082015250565b60006121cc602283611aa2565b91506121d782612170565b604082019050919050565b600060208201905081810360008301526121fb816121bf565b9050919050565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572600082015250565b6000612238602083611aa2565b915061224382612202565b602082019050919050565b600060208201905081810360008301526122678161222b565b9050919050565b7f45524332303a20696e73756666696369656e7420616c6c6f77616e6365000000600082015250565b60006122a4601d83611aa2565b91506122af8261226e565b602082019050919050565b600060208201905081810360008301526122d381612297565b9050919050565b7f45524332303a207472616e736665722066726f6d20746865207a65726f20616460008201527f6472657373000000000000000000000000000000000000000000000000000000602082015250565b6000612336602583611aa2565b9150612341826122da565b604082019050919050565b6000602082019050818103600083015261236581612329565b9050919050565b7f45524332303a207472616e7366657220746f20746865207a65726f206164647260008201527f6573730000000000000000000000000000000000000000000000000000000000602082015250565b60006123c8602383611aa2565b91506123d38261236c565b604082019050919050565b600060208201905081810360008301526123f7816123bb565b9050919050565b7f45524332303a207472616e7366657220616d6f756e742065786365656473206260008201527f616c616e63650000000000000000000000000000000000000000000000000000602082015250565b600061245a602683611aa2565b9150612465826123fe565b604082019050919050565b600060208201905081810360008301526124898161244d565b9050919050565b7f45524332303a206d696e7420746f20746865207a65726f206164647265737300600082015250565b60006124c6601f83611aa2565b91506124d182612490565b602082019050919050565b600060208201905081810360008301526124f5816124b9565b9050919050565b7f63616e6e6f74207265766f6b65206f776e20726f6c6500000000000000000000600082015250565b6000612532601683611aa2565b915061253d826124fc565b602082019050919050565b6000602082019050818103600083015261256181612525565b905091905056fea26469706673582212208960f6ed0b8f3e3aed90fcb6ffa061c05a2275fca566a1d5b4d2bbcbf9228ec364736f6c634300081a0033",
}

// ERC20NativeMinterABI is the input ABI used to generate the binding from.
// Deprecated: Use ERC20NativeMinterMetaData.ABI instead.
var ERC20NativeMinterABI = ERC20NativeMinterMetaData.ABI

// ERC20NativeMinterBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use ERC20NativeMinterMetaData.Bin instead.
var ERC20NativeMinterBin = ERC20NativeMinterMetaData.Bin

// DeployERC20NativeMinter deploys a new Ethereum contract, binding an instance of ERC20NativeMinter to it.
func DeployERC20NativeMinter(auth *bind.TransactOpts, backend bind.ContractBackend, initSupply *big.Int) (common.Address, *types.Transaction, *ERC20NativeMinter, error) {
	parsed, err := ERC20NativeMinterMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(ERC20NativeMinterBin), backend, initSupply)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ERC20NativeMinter{ERC20NativeMinterCaller: ERC20NativeMinterCaller{contract: contract}, ERC20NativeMinterTransactor: ERC20NativeMinterTransactor{contract: contract}, ERC20NativeMinterFilterer: ERC20NativeMinterFilterer{contract: contract}}, nil
}

// ERC20NativeMinter is an auto generated Go binding around an Ethereum contract.
type ERC20NativeMinter struct {
	ERC20NativeMinterCaller     // Read-only binding to the contract
	ERC20NativeMinterTransactor // Write-only binding to the contract
	ERC20NativeMinterFilterer   // Log filterer for contract events
}

// ERC20NativeMinterCaller is an auto generated read-only Go binding around an Ethereum contract.
type ERC20NativeMinterCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20NativeMinterTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ERC20NativeMinterTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20NativeMinterFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ERC20NativeMinterFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20NativeMinterSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ERC20NativeMinterSession struct {
	Contract     *ERC20NativeMinter // Generic contract binding to set the session for
	CallOpts     bind.CallOpts      // Call options to use throughout this session
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// ERC20NativeMinterCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ERC20NativeMinterCallerSession struct {
	Contract *ERC20NativeMinterCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts            // Call options to use throughout this session
}

// ERC20NativeMinterTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ERC20NativeMinterTransactorSession struct {
	Contract     *ERC20NativeMinterTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts            // Transaction auth options to use throughout this session
}

// ERC20NativeMinterRaw is an auto generated low-level Go binding around an Ethereum contract.
type ERC20NativeMinterRaw struct {
	Contract *ERC20NativeMinter // Generic contract binding to access the raw methods on
}

// ERC20NativeMinterCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ERC20NativeMinterCallerRaw struct {
	Contract *ERC20NativeMinterCaller // Generic read-only contract binding to access the raw methods on
}

// ERC20NativeMinterTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ERC20NativeMinterTransactorRaw struct {
	Contract *ERC20NativeMinterTransactor // Generic write-only contract binding to access the raw methods on
}

// NewERC20NativeMinter creates a new instance of ERC20NativeMinter, bound to a specific deployed contract.
func NewERC20NativeMinter(address common.Address, backend bind.ContractBackend) (*ERC20NativeMinter, error) {
	contract, err := bindERC20NativeMinter(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinter{ERC20NativeMinterCaller: ERC20NativeMinterCaller{contract: contract}, ERC20NativeMinterTransactor: ERC20NativeMinterTransactor{contract: contract}, ERC20NativeMinterFilterer: ERC20NativeMinterFilterer{contract: contract}}, nil
}

// NewERC20NativeMinterCaller creates a new read-only instance of ERC20NativeMinter, bound to a specific deployed contract.
func NewERC20NativeMinterCaller(address common.Address, caller bind.ContractCaller) (*ERC20NativeMinterCaller, error) {
	contract, err := bindERC20NativeMinter(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterCaller{contract: contract}, nil
}

// NewERC20NativeMinterTransactor creates a new write-only instance of ERC20NativeMinter, bound to a specific deployed contract.
func NewERC20NativeMinterTransactor(address common.Address, transactor bind.ContractTransactor) (*ERC20NativeMinterTransactor, error) {
	contract, err := bindERC20NativeMinter(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterTransactor{contract: contract}, nil
}

// NewERC20NativeMinterFilterer creates a new log filterer instance of ERC20NativeMinter, bound to a specific deployed contract.
func NewERC20NativeMinterFilterer(address common.Address, filterer bind.ContractFilterer) (*ERC20NativeMinterFilterer, error) {
	contract, err := bindERC20NativeMinter(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterFilterer{contract: contract}, nil
}

// bindERC20NativeMinter binds a generic wrapper to an already deployed contract.
func bindERC20NativeMinter(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ERC20NativeMinterMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20NativeMinter *ERC20NativeMinterRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ERC20NativeMinter.Contract.ERC20NativeMinterCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20NativeMinter *ERC20NativeMinterRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.ERC20NativeMinterTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20NativeMinter *ERC20NativeMinterRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.ERC20NativeMinterTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20NativeMinter *ERC20NativeMinterCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ERC20NativeMinter.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20NativeMinter *ERC20NativeMinterTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20NativeMinter *ERC20NativeMinterTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20NativeMinter *ERC20NativeMinterCaller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _ERC20NativeMinter.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20NativeMinter *ERC20NativeMinterSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _ERC20NativeMinter.Contract.Allowance(&_ERC20NativeMinter.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20NativeMinter *ERC20NativeMinterCallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _ERC20NativeMinter.Contract.Allowance(&_ERC20NativeMinter.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20NativeMinter *ERC20NativeMinterCaller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _ERC20NativeMinter.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20NativeMinter *ERC20NativeMinterSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _ERC20NativeMinter.Contract.BalanceOf(&_ERC20NativeMinter.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20NativeMinter *ERC20NativeMinterCallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _ERC20NativeMinter.Contract.BalanceOf(&_ERC20NativeMinter.CallOpts, account)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20NativeMinter *ERC20NativeMinterCaller) Decimals(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _ERC20NativeMinter.contract.Call(opts, &out, "decimals")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20NativeMinter *ERC20NativeMinterSession) Decimals() (uint8, error) {
	return _ERC20NativeMinter.Contract.Decimals(&_ERC20NativeMinter.CallOpts)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20NativeMinter *ERC20NativeMinterCallerSession) Decimals() (uint8, error) {
	return _ERC20NativeMinter.Contract.Decimals(&_ERC20NativeMinter.CallOpts)
}

// IsAdmin is a free data retrieval call binding the contract method 0x24d7806c.
//
// Solidity: function isAdmin(address addr) view returns(bool)
func (_ERC20NativeMinter *ERC20NativeMinterCaller) IsAdmin(opts *bind.CallOpts, addr common.Address) (bool, error) {
	var out []interface{}
	err := _ERC20NativeMinter.contract.Call(opts, &out, "isAdmin", addr)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsAdmin is a free data retrieval call binding the contract method 0x24d7806c.
//
// Solidity: function isAdmin(address addr) view returns(bool)
func (_ERC20NativeMinter *ERC20NativeMinterSession) IsAdmin(addr common.Address) (bool, error) {
	return _ERC20NativeMinter.Contract.IsAdmin(&_ERC20NativeMinter.CallOpts, addr)
}

// IsAdmin is a free data retrieval call binding the contract method 0x24d7806c.
//
// Solidity: function isAdmin(address addr) view returns(bool)
func (_ERC20NativeMinter *ERC20NativeMinterCallerSession) IsAdmin(addr common.Address) (bool, error) {
	return _ERC20NativeMinter.Contract.IsAdmin(&_ERC20NativeMinter.CallOpts, addr)
}

// IsEnabled is a free data retrieval call binding the contract method 0x9015d371.
//
// Solidity: function isEnabled(address addr) view returns(bool)
func (_ERC20NativeMinter *ERC20NativeMinterCaller) IsEnabled(opts *bind.CallOpts, addr common.Address) (bool, error) {
	var out []interface{}
	err := _ERC20NativeMinter.contract.Call(opts, &out, "isEnabled", addr)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsEnabled is a free data retrieval call binding the contract method 0x9015d371.
//
// Solidity: function isEnabled(address addr) view returns(bool)
func (_ERC20NativeMinter *ERC20NativeMinterSession) IsEnabled(addr common.Address) (bool, error) {
	return _ERC20NativeMinter.Contract.IsEnabled(&_ERC20NativeMinter.CallOpts, addr)
}

// IsEnabled is a free data retrieval call binding the contract method 0x9015d371.
//
// Solidity: function isEnabled(address addr) view returns(bool)
func (_ERC20NativeMinter *ERC20NativeMinterCallerSession) IsEnabled(addr common.Address) (bool, error) {
	return _ERC20NativeMinter.Contract.IsEnabled(&_ERC20NativeMinter.CallOpts, addr)
}

// IsManager is a free data retrieval call binding the contract method 0xf3ae2415.
//
// Solidity: function isManager(address addr) view returns(bool)
func (_ERC20NativeMinter *ERC20NativeMinterCaller) IsManager(opts *bind.CallOpts, addr common.Address) (bool, error) {
	var out []interface{}
	err := _ERC20NativeMinter.contract.Call(opts, &out, "isManager", addr)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsManager is a free data retrieval call binding the contract method 0xf3ae2415.
//
// Solidity: function isManager(address addr) view returns(bool)
func (_ERC20NativeMinter *ERC20NativeMinterSession) IsManager(addr common.Address) (bool, error) {
	return _ERC20NativeMinter.Contract.IsManager(&_ERC20NativeMinter.CallOpts, addr)
}

// IsManager is a free data retrieval call binding the contract method 0xf3ae2415.
//
// Solidity: function isManager(address addr) view returns(bool)
func (_ERC20NativeMinter *ERC20NativeMinterCallerSession) IsManager(addr common.Address) (bool, error) {
	return _ERC20NativeMinter.Contract.IsManager(&_ERC20NativeMinter.CallOpts, addr)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20NativeMinter *ERC20NativeMinterCaller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _ERC20NativeMinter.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20NativeMinter *ERC20NativeMinterSession) Name() (string, error) {
	return _ERC20NativeMinter.Contract.Name(&_ERC20NativeMinter.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20NativeMinter *ERC20NativeMinterCallerSession) Name() (string, error) {
	return _ERC20NativeMinter.Contract.Name(&_ERC20NativeMinter.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ERC20NativeMinter *ERC20NativeMinterCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ERC20NativeMinter.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ERC20NativeMinter *ERC20NativeMinterSession) Owner() (common.Address, error) {
	return _ERC20NativeMinter.Contract.Owner(&_ERC20NativeMinter.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ERC20NativeMinter *ERC20NativeMinterCallerSession) Owner() (common.Address, error) {
	return _ERC20NativeMinter.Contract.Owner(&_ERC20NativeMinter.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20NativeMinter *ERC20NativeMinterCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _ERC20NativeMinter.contract.Call(opts, &out, "symbol")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20NativeMinter *ERC20NativeMinterSession) Symbol() (string, error) {
	return _ERC20NativeMinter.Contract.Symbol(&_ERC20NativeMinter.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20NativeMinter *ERC20NativeMinterCallerSession) Symbol() (string, error) {
	return _ERC20NativeMinter.Contract.Symbol(&_ERC20NativeMinter.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20NativeMinter *ERC20NativeMinterCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ERC20NativeMinter.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20NativeMinter *ERC20NativeMinterSession) TotalSupply() (*big.Int, error) {
	return _ERC20NativeMinter.Contract.TotalSupply(&_ERC20NativeMinter.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20NativeMinter *ERC20NativeMinterCallerSession) TotalSupply() (*big.Int, error) {
	return _ERC20NativeMinter.Contract.TotalSupply(&_ERC20NativeMinter.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20NativeMinter *ERC20NativeMinterTransactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20NativeMinter.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20NativeMinter *ERC20NativeMinterSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.Approve(&_ERC20NativeMinter.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20NativeMinter *ERC20NativeMinterTransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.Approve(&_ERC20NativeMinter.TransactOpts, spender, amount)
}

// Burn is a paid mutator transaction binding the contract method 0x9dc29fac.
//
// Solidity: function burn(address from, uint256 amount) returns()
func (_ERC20NativeMinter *ERC20NativeMinterTransactor) Burn(opts *bind.TransactOpts, from common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20NativeMinter.contract.Transact(opts, "burn", from, amount)
}

// Burn is a paid mutator transaction binding the contract method 0x9dc29fac.
//
// Solidity: function burn(address from, uint256 amount) returns()
func (_ERC20NativeMinter *ERC20NativeMinterSession) Burn(from common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.Burn(&_ERC20NativeMinter.TransactOpts, from, amount)
}

// Burn is a paid mutator transaction binding the contract method 0x9dc29fac.
//
// Solidity: function burn(address from, uint256 amount) returns()
func (_ERC20NativeMinter *ERC20NativeMinterTransactorSession) Burn(from common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.Burn(&_ERC20NativeMinter.TransactOpts, from, amount)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20NativeMinter *ERC20NativeMinterTransactor) DecreaseAllowance(opts *bind.TransactOpts, spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20NativeMinter.contract.Transact(opts, "decreaseAllowance", spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20NativeMinter *ERC20NativeMinterSession) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.DecreaseAllowance(&_ERC20NativeMinter.TransactOpts, spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20NativeMinter *ERC20NativeMinterTransactorSession) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.DecreaseAllowance(&_ERC20NativeMinter.TransactOpts, spender, subtractedValue)
}

// Deposit is a paid mutator transaction binding the contract method 0xd0e30db0.
//
// Solidity: function deposit() payable returns()
func (_ERC20NativeMinter *ERC20NativeMinterTransactor) Deposit(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20NativeMinter.contract.Transact(opts, "deposit")
}

// Deposit is a paid mutator transaction binding the contract method 0xd0e30db0.
//
// Solidity: function deposit() payable returns()
func (_ERC20NativeMinter *ERC20NativeMinterSession) Deposit() (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.Deposit(&_ERC20NativeMinter.TransactOpts)
}

// Deposit is a paid mutator transaction binding the contract method 0xd0e30db0.
//
// Solidity: function deposit() payable returns()
func (_ERC20NativeMinter *ERC20NativeMinterTransactorSession) Deposit() (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.Deposit(&_ERC20NativeMinter.TransactOpts)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20NativeMinter *ERC20NativeMinterTransactor) IncreaseAllowance(opts *bind.TransactOpts, spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20NativeMinter.contract.Transact(opts, "increaseAllowance", spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20NativeMinter *ERC20NativeMinterSession) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.IncreaseAllowance(&_ERC20NativeMinter.TransactOpts, spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20NativeMinter *ERC20NativeMinterTransactorSession) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.IncreaseAllowance(&_ERC20NativeMinter.TransactOpts, spender, addedValue)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address to, uint256 amount) returns()
func (_ERC20NativeMinter *ERC20NativeMinterTransactor) Mint(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20NativeMinter.contract.Transact(opts, "mint", to, amount)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address to, uint256 amount) returns()
func (_ERC20NativeMinter *ERC20NativeMinterSession) Mint(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.Mint(&_ERC20NativeMinter.TransactOpts, to, amount)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address to, uint256 amount) returns()
func (_ERC20NativeMinter *ERC20NativeMinterTransactorSession) Mint(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.Mint(&_ERC20NativeMinter.TransactOpts, to, amount)
}

// Mintdraw is a paid mutator transaction binding the contract method 0x0356b6cd.
//
// Solidity: function mintdraw(uint256 wad) returns()
func (_ERC20NativeMinter *ERC20NativeMinterTransactor) Mintdraw(opts *bind.TransactOpts, wad *big.Int) (*types.Transaction, error) {
	return _ERC20NativeMinter.contract.Transact(opts, "mintdraw", wad)
}

// Mintdraw is a paid mutator transaction binding the contract method 0x0356b6cd.
//
// Solidity: function mintdraw(uint256 wad) returns()
func (_ERC20NativeMinter *ERC20NativeMinterSession) Mintdraw(wad *big.Int) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.Mintdraw(&_ERC20NativeMinter.TransactOpts, wad)
}

// Mintdraw is a paid mutator transaction binding the contract method 0x0356b6cd.
//
// Solidity: function mintdraw(uint256 wad) returns()
func (_ERC20NativeMinter *ERC20NativeMinterTransactorSession) Mintdraw(wad *big.Int) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.Mintdraw(&_ERC20NativeMinter.TransactOpts, wad)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_ERC20NativeMinter *ERC20NativeMinterTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20NativeMinter.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_ERC20NativeMinter *ERC20NativeMinterSession) RenounceOwnership() (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.RenounceOwnership(&_ERC20NativeMinter.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_ERC20NativeMinter *ERC20NativeMinterTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.RenounceOwnership(&_ERC20NativeMinter.TransactOpts)
}

// Revoke is a paid mutator transaction binding the contract method 0x74a8f103.
//
// Solidity: function revoke(address addr) returns()
func (_ERC20NativeMinter *ERC20NativeMinterTransactor) Revoke(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _ERC20NativeMinter.contract.Transact(opts, "revoke", addr)
}

// Revoke is a paid mutator transaction binding the contract method 0x74a8f103.
//
// Solidity: function revoke(address addr) returns()
func (_ERC20NativeMinter *ERC20NativeMinterSession) Revoke(addr common.Address) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.Revoke(&_ERC20NativeMinter.TransactOpts, addr)
}

// Revoke is a paid mutator transaction binding the contract method 0x74a8f103.
//
// Solidity: function revoke(address addr) returns()
func (_ERC20NativeMinter *ERC20NativeMinterTransactorSession) Revoke(addr common.Address) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.Revoke(&_ERC20NativeMinter.TransactOpts, addr)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_ERC20NativeMinter *ERC20NativeMinterTransactor) SetAdmin(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _ERC20NativeMinter.contract.Transact(opts, "setAdmin", addr)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_ERC20NativeMinter *ERC20NativeMinterSession) SetAdmin(addr common.Address) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.SetAdmin(&_ERC20NativeMinter.TransactOpts, addr)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_ERC20NativeMinter *ERC20NativeMinterTransactorSession) SetAdmin(addr common.Address) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.SetAdmin(&_ERC20NativeMinter.TransactOpts, addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_ERC20NativeMinter *ERC20NativeMinterTransactor) SetEnabled(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _ERC20NativeMinter.contract.Transact(opts, "setEnabled", addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_ERC20NativeMinter *ERC20NativeMinterSession) SetEnabled(addr common.Address) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.SetEnabled(&_ERC20NativeMinter.TransactOpts, addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_ERC20NativeMinter *ERC20NativeMinterTransactorSession) SetEnabled(addr common.Address) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.SetEnabled(&_ERC20NativeMinter.TransactOpts, addr)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_ERC20NativeMinter *ERC20NativeMinterTransactor) SetManager(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _ERC20NativeMinter.contract.Transact(opts, "setManager", addr)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_ERC20NativeMinter *ERC20NativeMinterSession) SetManager(addr common.Address) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.SetManager(&_ERC20NativeMinter.TransactOpts, addr)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_ERC20NativeMinter *ERC20NativeMinterTransactorSession) SetManager(addr common.Address) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.SetManager(&_ERC20NativeMinter.TransactOpts, addr)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20NativeMinter *ERC20NativeMinterTransactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20NativeMinter.contract.Transact(opts, "transfer", to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20NativeMinter *ERC20NativeMinterSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.Transfer(&_ERC20NativeMinter.TransactOpts, to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20NativeMinter *ERC20NativeMinterTransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.Transfer(&_ERC20NativeMinter.TransactOpts, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20NativeMinter *ERC20NativeMinterTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20NativeMinter.contract.Transact(opts, "transferFrom", from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20NativeMinter *ERC20NativeMinterSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.TransferFrom(&_ERC20NativeMinter.TransactOpts, from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20NativeMinter *ERC20NativeMinterTransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.TransferFrom(&_ERC20NativeMinter.TransactOpts, from, to, amount)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_ERC20NativeMinter *ERC20NativeMinterTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _ERC20NativeMinter.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_ERC20NativeMinter *ERC20NativeMinterSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.TransferOwnership(&_ERC20NativeMinter.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_ERC20NativeMinter *ERC20NativeMinterTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _ERC20NativeMinter.Contract.TransferOwnership(&_ERC20NativeMinter.TransactOpts, newOwner)
}

// ERC20NativeMinterApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the ERC20NativeMinter contract.
type ERC20NativeMinterApprovalIterator struct {
	Event *ERC20NativeMinterApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20NativeMinterApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20NativeMinterApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20NativeMinterApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20NativeMinterApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20NativeMinterApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20NativeMinterApproval represents a Approval event raised by the ERC20NativeMinter contract.
type ERC20NativeMinterApproval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20NativeMinter *ERC20NativeMinterFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*ERC20NativeMinterApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _ERC20NativeMinter.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterApprovalIterator{contract: _ERC20NativeMinter.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20NativeMinter *ERC20NativeMinterFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *ERC20NativeMinterApproval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _ERC20NativeMinter.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20NativeMinterApproval)
				if err := _ERC20NativeMinter.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20NativeMinter *ERC20NativeMinterFilterer) ParseApproval(log types.Log) (*ERC20NativeMinterApproval, error) {
	event := new(ERC20NativeMinterApproval)
	if err := _ERC20NativeMinter.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20NativeMinterDepositIterator is returned from FilterDeposit and is used to iterate over the raw logs and unpacked data for Deposit events raised by the ERC20NativeMinter contract.
type ERC20NativeMinterDepositIterator struct {
	Event *ERC20NativeMinterDeposit // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20NativeMinterDepositIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20NativeMinterDeposit)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20NativeMinterDeposit)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20NativeMinterDepositIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20NativeMinterDepositIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20NativeMinterDeposit represents a Deposit event raised by the ERC20NativeMinter contract.
type ERC20NativeMinterDeposit struct {
	Dst common.Address
	Wad *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterDeposit is a free log retrieval operation binding the contract event 0xe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c.
//
// Solidity: event Deposit(address indexed dst, uint256 wad)
func (_ERC20NativeMinter *ERC20NativeMinterFilterer) FilterDeposit(opts *bind.FilterOpts, dst []common.Address) (*ERC20NativeMinterDepositIterator, error) {

	var dstRule []interface{}
	for _, dstItem := range dst {
		dstRule = append(dstRule, dstItem)
	}

	logs, sub, err := _ERC20NativeMinter.contract.FilterLogs(opts, "Deposit", dstRule)
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterDepositIterator{contract: _ERC20NativeMinter.contract, event: "Deposit", logs: logs, sub: sub}, nil
}

// WatchDeposit is a free log subscription operation binding the contract event 0xe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c.
//
// Solidity: event Deposit(address indexed dst, uint256 wad)
func (_ERC20NativeMinter *ERC20NativeMinterFilterer) WatchDeposit(opts *bind.WatchOpts, sink chan<- *ERC20NativeMinterDeposit, dst []common.Address) (event.Subscription, error) {

	var dstRule []interface{}
	for _, dstItem := range dst {
		dstRule = append(dstRule, dstItem)
	}

	logs, sub, err := _ERC20NativeMinter.contract.WatchLogs(opts, "Deposit", dstRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20NativeMinterDeposit)
				if err := _ERC20NativeMinter.contract.UnpackLog(event, "Deposit", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDeposit is a log parse operation binding the contract event 0xe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c.
//
// Solidity: event Deposit(address indexed dst, uint256 wad)
func (_ERC20NativeMinter *ERC20NativeMinterFilterer) ParseDeposit(log types.Log) (*ERC20NativeMinterDeposit, error) {
	event := new(ERC20NativeMinterDeposit)
	if err := _ERC20NativeMinter.contract.UnpackLog(event, "Deposit", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20NativeMinterMintdrawalIterator is returned from FilterMintdrawal and is used to iterate over the raw logs and unpacked data for Mintdrawal events raised by the ERC20NativeMinter contract.
type ERC20NativeMinterMintdrawalIterator struct {
	Event *ERC20NativeMinterMintdrawal // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20NativeMinterMintdrawalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20NativeMinterMintdrawal)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20NativeMinterMintdrawal)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20NativeMinterMintdrawalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20NativeMinterMintdrawalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20NativeMinterMintdrawal represents a Mintdrawal event raised by the ERC20NativeMinter contract.
type ERC20NativeMinterMintdrawal struct {
	Src common.Address
	Wad *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterMintdrawal is a free log retrieval operation binding the contract event 0x25bedde6c8ebd3a89b719a16299dbfe271c7bffa42fe1ac1a52e15ab0cb767e6.
//
// Solidity: event Mintdrawal(address indexed src, uint256 wad)
func (_ERC20NativeMinter *ERC20NativeMinterFilterer) FilterMintdrawal(opts *bind.FilterOpts, src []common.Address) (*ERC20NativeMinterMintdrawalIterator, error) {

	var srcRule []interface{}
	for _, srcItem := range src {
		srcRule = append(srcRule, srcItem)
	}

	logs, sub, err := _ERC20NativeMinter.contract.FilterLogs(opts, "Mintdrawal", srcRule)
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterMintdrawalIterator{contract: _ERC20NativeMinter.contract, event: "Mintdrawal", logs: logs, sub: sub}, nil
}

// WatchMintdrawal is a free log subscription operation binding the contract event 0x25bedde6c8ebd3a89b719a16299dbfe271c7bffa42fe1ac1a52e15ab0cb767e6.
//
// Solidity: event Mintdrawal(address indexed src, uint256 wad)
func (_ERC20NativeMinter *ERC20NativeMinterFilterer) WatchMintdrawal(opts *bind.WatchOpts, sink chan<- *ERC20NativeMinterMintdrawal, src []common.Address) (event.Subscription, error) {

	var srcRule []interface{}
	for _, srcItem := range src {
		srcRule = append(srcRule, srcItem)
	}

	logs, sub, err := _ERC20NativeMinter.contract.WatchLogs(opts, "Mintdrawal", srcRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20NativeMinterMintdrawal)
				if err := _ERC20NativeMinter.contract.UnpackLog(event, "Mintdrawal", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMintdrawal is a log parse operation binding the contract event 0x25bedde6c8ebd3a89b719a16299dbfe271c7bffa42fe1ac1a52e15ab0cb767e6.
//
// Solidity: event Mintdrawal(address indexed src, uint256 wad)
func (_ERC20NativeMinter *ERC20NativeMinterFilterer) ParseMintdrawal(log types.Log) (*ERC20NativeMinterMintdrawal, error) {
	event := new(ERC20NativeMinterMintdrawal)
	if err := _ERC20NativeMinter.contract.UnpackLog(event, "Mintdrawal", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20NativeMinterOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the ERC20NativeMinter contract.
type ERC20NativeMinterOwnershipTransferredIterator struct {
	Event *ERC20NativeMinterOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20NativeMinterOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20NativeMinterOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20NativeMinterOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20NativeMinterOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20NativeMinterOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20NativeMinterOwnershipTransferred represents a OwnershipTransferred event raised by the ERC20NativeMinter contract.
type ERC20NativeMinterOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_ERC20NativeMinter *ERC20NativeMinterFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*ERC20NativeMinterOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _ERC20NativeMinter.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterOwnershipTransferredIterator{contract: _ERC20NativeMinter.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_ERC20NativeMinter *ERC20NativeMinterFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *ERC20NativeMinterOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _ERC20NativeMinter.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20NativeMinterOwnershipTransferred)
				if err := _ERC20NativeMinter.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_ERC20NativeMinter *ERC20NativeMinterFilterer) ParseOwnershipTransferred(log types.Log) (*ERC20NativeMinterOwnershipTransferred, error) {
	event := new(ERC20NativeMinterOwnershipTransferred)
	if err := _ERC20NativeMinter.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20NativeMinterTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the ERC20NativeMinter contract.
type ERC20NativeMinterTransferIterator struct {
	Event *ERC20NativeMinterTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20NativeMinterTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20NativeMinterTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20NativeMinterTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20NativeMinterTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20NativeMinterTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20NativeMinterTransfer represents a Transfer event raised by the ERC20NativeMinter contract.
type ERC20NativeMinterTransfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20NativeMinter *ERC20NativeMinterFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*ERC20NativeMinterTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _ERC20NativeMinter.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterTransferIterator{contract: _ERC20NativeMinter.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20NativeMinter *ERC20NativeMinterFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *ERC20NativeMinterTransfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _ERC20NativeMinter.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20NativeMinterTransfer)
				if err := _ERC20NativeMinter.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20NativeMinter *ERC20NativeMinterFilterer) ParseTransfer(log types.Log) (*ERC20NativeMinterTransfer, error) {
	event := new(ERC20NativeMinterTransfer)
	if err := _ERC20NativeMinter.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20NativeMinterTestMetaData contains all meta data concerning the ERC20NativeMinterTest contract.
var ERC20NativeMinterTestMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"log_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"log_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"log_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"name\":\"log_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"val\",\"type\":\"address\"}],\"name\":\"log_named_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"val\",\"type\":\"bytes\"}],\"name\":\"log_named_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"val\",\"type\":\"bytes32\"}],\"name\":\"log_named_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"}],\"name\":\"log_named_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"val\",\"type\":\"string\"}],\"name\":\"log_named_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"log_named_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"log_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"logs\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"IS_TEST\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"failed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_addMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_adminMintdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_mintdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_mintdrawFailure\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_minterDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_minterMintdrawFailure\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x608060405260016000806101000a81548160ff021916908315150217905550730200000000000000000000000000000000000001600060026101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550348015607e57600080fd5b50614f0b8061008e6000396000f3fe608060405234801561001057600080fd5b50600436106100935760003560e01c80638aa3c51e116100665780638aa3c51e146100c0578063b1b5e2c0146100ca578063ba414fa6146100d4578063d07ba09b146100f2578063fa7626d4146100fc57610093565b80630a9254e4146100985780631aeb30bf146100a25780631e752c47146100ac5780635a4b3b63146100b6575b600080fd5b6100a061011a565b005b6100aa61011c565b005b6100b4610482565b005b6100be6107c6565b005b6100c861095a565b005b6100d2610b76565b005b6100dc610e7b565b6040516100e991906115ff565b60405180910390f35b6100fa611018565b005b6101046112b6565b60405161011191906115ff565b60405180910390f35b565b60006103e860405161012d906115ca565b6101379190611669565b604051809103906000f080158015610153573d6000803e3d6000fd5b509050600081905060008160405161016a906115d7565b61017491906116c5565b604051809103906000f080158015610190573d6000803e3d6000fd5b5090506000819050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043846040518263ffffffff1660e01b81526004016101f391906116c5565b600060405180830381600087803b15801561020d57600080fd5b505af1158015610221573d6000803e3d6000fd5b50505050600060649050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16634f5aaaba83836040518363ffffffff1660e01b81526004016102889291906116ef565b600060405180830381600087803b1580156102a257600080fd5b505af11580156102b6573d6000803e3d6000fd5b5050505060008573ffffffffffffffffffffffffffffffffffffffff166370a08231846040518263ffffffff1660e01b81526004016102f591906116c5565b602060405180830381865afa158015610312573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103369190611749565b905060008373ffffffffffffffffffffffffffffffffffffffff163190508473ffffffffffffffffffffffffffffffffffffffff1663b6b55f25846040518263ffffffff1660e01b815260040161038d9190611776565b600060405180830381600087803b1580156103a757600080fd5b505af11580156103bb573d6000803e3d6000fd5b5050505061044d8773ffffffffffffffffffffffffffffffffffffffff166370a08231866040518263ffffffff1660e01b81526004016103fb91906116c5565b602060405180830381865afa158015610418573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061043c9190611749565b848461044891906117c0565b6112c7565b6104798473ffffffffffffffffffffffffffffffffffffffff1631848361047491906117f4565b6112c7565b50505050505050565b60006103e8604051610493906115ca565b61049d9190611669565b604051809103906000f0801580156104b9573d6000803e3d6000fd5b50905060008190506000816040516104d0906115d7565b6104da91906116c5565b604051809103906000f0801580156104f6573d6000803e3d6000fd5b5090506000819050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043846040518263ffffffff1660e01b815260040161055991906116c5565b600060405180830381600087803b15801561057357600080fd5b505af1158015610587573d6000803e3d6000fd5b5050505060006064905060008273ffffffffffffffffffffffffffffffffffffffff163190506105b88160006112c7565b8573ffffffffffffffffffffffffffffffffffffffff166340c10f1984846040518363ffffffff1660e01b81526004016105f39291906116ef565b600060405180830381600087803b15801561060d57600080fd5b505af1158015610621573d6000803e3d6000fd5b5050505060008673ffffffffffffffffffffffffffffffffffffffff166370a08231856040518263ffffffff1660e01b815260040161066091906116c5565b602060405180830381865afa15801561067d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106a19190611749565b90506106ad81846112c7565b8473ffffffffffffffffffffffffffffffffffffffff16630356b6cd846040518263ffffffff1660e01b81526004016106e69190611776565b600060405180830381600087803b15801561070057600080fd5b505af1158015610714573d6000803e3d6000fd5b5050505061079c8773ffffffffffffffffffffffffffffffffffffffff166370a08231866040518263ffffffff1660e01b815260040161075491906116c5565b602060405180830381865afa158015610771573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107959190611749565b60006112c7565b6107bd8473ffffffffffffffffffffffffffffffffffffffff1631846112c7565b50505050505050565b60006103e86040516107d7906115ca565b6107e19190611669565b604051809103906000f0801580156107fd573d6000803e3d6000fd5b50905060008190506108ab600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1836040518263ffffffff1660e01b815260040161086391906116c5565b602060405180830381865afa158015610880573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108a49190611749565b600061137e565b8173ffffffffffffffffffffffffffffffffffffffff16630356b6cd60646040518263ffffffff1660e01b81526004016108e59190611863565b600060405180830381600087803b1580156108ff57600080fd5b505af1925050508015610910575060015b156109565761095560006040518060400160405280601481526020017f6d696e74647261772073686f756c64206661696c00000000000000000000000081525061139e565b5b5050565b60006103e860405161096b906115ca565b6109759190611669565b604051809103906000f080158015610991573d6000803e3d6000fd5b5090506000819050610a3f600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1836040518263ffffffff1660e01b81526004016109f791906116c5565b602060405180830381865afa158015610a14573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a389190611749565b600061137e565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043826040518263ffffffff1660e01b8152600401610a9a91906116c5565b600060405180830381600087803b158015610ab457600080fd5b505af1158015610ac8573d6000803e3d6000fd5b50505050610b72600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1836040518263ffffffff1660e01b8152600401610b2a91906116c5565b602060405180830381865afa158015610b47573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b6b9190611749565b600161137e565b5050565b60006103e8604051610b87906115ca565b610b919190611669565b604051809103906000f080158015610bad573d6000803e3d6000fd5b5090506000819050600081604051610bc4906115d7565b610bce91906116c5565b604051809103906000f080158015610bea573d6000803e3d6000fd5b5090506000819050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043846040518263ffffffff1660e01b8152600401610c4d91906116c5565b600060405180830381600087803b158015610c6757600080fd5b505af1158015610c7b573d6000803e3d6000fd5b5050505060008473ffffffffffffffffffffffffffffffffffffffff166370a08231836040518263ffffffff1660e01b8152600401610cba91906116c5565b602060405180830381865afa158015610cd7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cfb9190611749565b905060008273ffffffffffffffffffffffffffffffffffffffff16319050610d248260006112c7565b8373ffffffffffffffffffffffffffffffffffffffff16630356b6cd60646040518263ffffffff1660e01b8152600401610d5e9190611863565b600060405180830381600087803b158015610d7857600080fd5b505af1925050508015610d89575060015b15610dcf57610dce60006040518060400160405280601481526020017f6d696e74647261772073686f756c64206661696c00000000000000000000000081525061139e565b5b610e528673ffffffffffffffffffffffffffffffffffffffff166370a08231856040518263ffffffff1660e01b8152600401610e0b91906116c5565b602060405180830381865afa158015610e28573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e4c9190611749565b836112c7565b610e738373ffffffffffffffffffffffffffffffffffffffff1631826112c7565b505050505050565b60008060019054906101000a900460ff1615610ea857600060019054906101000a900460ff169050611015565b6000610eb26113e8565b156110105760007f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d60001c60601b60601c73ffffffffffffffffffffffffffffffffffffffff167f667f9d70ca411d70ead50d8d5c22070dafc36ad75f3dcf5e7237b22ade9aecc47f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d60001c60601b60601c7f6661696c65640000000000000000000000000000000000000000000000000000604051602001610f76929190611897565b604051602081830303815290604052604051602001610f9692919061197e565b604051602081830303815290604052604051610fb291906119a6565b6000604051808303816000865af19150503d8060008114610fef576040519150601f19603f3d011682016040523d82523d6000602084013e610ff4565b606091505b509150508080602001905181019061100c91906119e9565b9150505b809150505b90565b60006103e8604051611029906115ca565b6110339190611669565b604051809103906000f08015801561104f573d6000803e3d6000fd5b50905060008190506000309050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043836040518263ffffffff1660e01b81526004016110b791906116c5565b600060405180830381600087803b1580156110d157600080fd5b505af11580156110e5573d6000803e3d6000fd5b5050505060008373ffffffffffffffffffffffffffffffffffffffff166370a08231836040518263ffffffff1660e01b815260040161112491906116c5565b602060405180830381865afa158015611141573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111659190611749565b905060008273ffffffffffffffffffffffffffffffffffffffff163190506000606490508573ffffffffffffffffffffffffffffffffffffffff16630356b6cd826040518263ffffffff1660e01b81526004016111c29190611776565b600060405180830381600087803b1580156111dc57600080fd5b505af11580156111f0573d6000803e3d6000fd5b505050506112828673ffffffffffffffffffffffffffffffffffffffff166370a08231866040518263ffffffff1660e01b815260040161123091906116c5565b602060405180830381865afa15801561124d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112719190611749565b828561127d91906117f4565b6112c7565b6112ae8473ffffffffffffffffffffffffffffffffffffffff163182846112a991906117c0565b6112c7565b505050505050565b60008054906101000a900460ff1681565b80821461137a577f41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f506040516112fb90611a99565b60405180910390a17fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8826040516113329190611b05565b60405180910390a17fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8816040516113699190611b7f565b60405180910390a1611379611411565b5b5050565b61139a8282600381111561139557611394611bad565b5b6112c7565b5050565b816113e4577f280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583816040516113d29190611c7d565b60405180910390a16113e382611584565b5b5050565b60008060009050737109709ecfa91a80626ff3989d68f67f5b1dd12d3b90506000811191505090565b6114196113e8565b156115675760007f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d60001c60601b60601c73ffffffffffffffffffffffffffffffffffffffff167f70ca10bbd0dbfd9020a9f4b13402c16cb120705e0d1c0aeab10fa353ae586fc47f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d60001c60601b60601c7f6661696c65640000000000000000000000000000000000000000000000000000600160001b6040516020016114e393929190611cb2565b60405160208183030381529060405260405160200161150392919061197e565b60405160208183030381529060405260405161151f91906119a6565b6000604051808303816000865af19150503d806000811461155c576040519150601f19603f3d011682016040523d82523d6000602084013e611561565b606091505b50509050505b6001600060016101000a81548160ff021916908315150217905550565b806115c7577f41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f506040516115b690611d35565b60405180910390a16115c6611411565b5b50565b612e1c80611d5683390190565b61036480614b7283390190565b60008115159050919050565b6115f9816115e4565b82525050565b600060208201905061161460008301846115f0565b92915050565b6000819050919050565b6000819050919050565b6000819050919050565b600061165361164e6116498461161a565b61162e565b611624565b9050919050565b61166381611638565b82525050565b600060208201905061167e600083018461165a565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006116af82611684565b9050919050565b6116bf816116a4565b82525050565b60006020820190506116da60008301846116b6565b92915050565b6116e981611624565b82525050565b600060408201905061170460008301856116b6565b61171160208301846116e0565b9392505050565b600080fd5b61172681611624565b811461173157600080fd5b50565b6000815190506117438161171d565b92915050565b60006020828403121561175f5761175e611718565b5b600061176d84828501611734565b91505092915050565b600060208201905061178b60008301846116e0565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006117cb82611624565b91506117d683611624565b92508282019050808211156117ee576117ed611791565b5b92915050565b60006117ff82611624565b915061180a83611624565b925082820390508181111561182257611821611791565b5b92915050565b6000819050919050565b600061184d61184861184384611828565b61162e565b611624565b9050919050565b61185d81611832565b82525050565b60006020820190506118786000830184611854565b92915050565b6000819050919050565b6118918161187e565b82525050565b60006040820190506118ac60008301856116b6565b6118b96020830184611888565b9392505050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b6000819050919050565b611907611902826118c0565b6118ec565b82525050565b600081519050919050565b600081905092915050565b60005b83811015611941578082015181840152602081019050611926565b60008484015250505050565b60006119588261190d565b6119628185611918565b9350611972818560208601611923565b80840191505092915050565b600061198a82856118f6565b60048201915061199a828461194d565b91508190509392505050565b60006119b2828461194d565b915081905092915050565b6119c6816115e4565b81146119d157600080fd5b50565b6000815190506119e3816119bd565b92915050565b6000602082840312156119ff576119fe611718565b5b6000611a0d848285016119d4565b91505092915050565b600082825260208201905092915050565b7f4572726f723a2061203d3d2062206e6f7420736174697366696564205b75696e60008201527f745d000000000000000000000000000000000000000000000000000000000000602082015250565b6000611a83602283611a16565b9150611a8e82611a27565b604082019050919050565b60006020820190508181036000830152611ab281611a76565b9050919050565b7f2020202020204c65667400000000000000000000000000000000000000000000600082015250565b6000611aef600a83611a16565b9150611afa82611ab9565b602082019050919050565b60006040820190508181036000830152611b1e81611ae2565b9050611b2d60208301846116e0565b92915050565b7f2020202020526967687400000000000000000000000000000000000000000000600082015250565b6000611b69600a83611a16565b9150611b7482611b33565b602082019050919050565b60006040820190508181036000830152611b9881611b5c565b9050611ba760208301846116e0565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b7f4572726f72000000000000000000000000000000000000000000000000000000600082015250565b6000611c12600583611a16565b9150611c1d82611bdc565b602082019050919050565b600081519050919050565b6000601f19601f8301169050919050565b6000611c4f82611c28565b611c598185611a16565b9350611c69818560208601611923565b611c7281611c33565b840191505092915050565b60006040820190508181036000830152611c9681611c05565b90508181036020830152611caa8184611c44565b905092915050565b6000606082019050611cc760008301866116b6565b611cd46020830185611888565b611ce16040830184611888565b949350505050565b7f4572726f723a20417373657274696f6e204661696c6564000000000000000000600082015250565b6000611d1f601783611a16565b9150611d2a82611ce9565b602082019050919050565b60006020820190508181036000830152611d4e81611d12565b905091905056fe6080604052730200000000000000000000000000000000000001600760006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555034801561006557600080fd5b50604051612e1c380380612e1c83398181016040528101906100879190610420565b7302000000000000000000000000000000000000016040518060400160405280601681526020017f45524332304e61746976654d696e746572546f6b656e000000000000000000008152506040518060400160405280600481526020017f584d504c0000000000000000000000000000000000000000000000000000000081525081600390816101179190610693565b5080600490816101279190610693565b50505061014661013b6101ab60201b60201c565b6101b360201b60201c565b80600660006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550506101a56101996101ab60201b60201c565b8261027960201b60201c565b5061086f565b600033905090565b6000600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905081600560006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16036102e8576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016102df906107c2565b60405180910390fd5b6102fa600083836103db60201b60201c565b806002600082825461030c9190610811565b92505081905550806000808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508173ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040516103bd9190610854565b60405180910390a36103d7600083836103e060201b60201c565b5050565b505050565b505050565b600080fd5b6000819050919050565b6103fd816103ea565b811461040857600080fd5b50565b60008151905061041a816103f4565b92915050565b600060208284031215610436576104356103e5565b5b60006104448482850161040b565b91505092915050565b600081519050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b600060028204905060018216806104ce57607f821691505b6020821081036104e1576104e0610487565b5b50919050565b60008190508160005260206000209050919050565b60006020601f8301049050919050565b600082821b905092915050565b6000600883026105497fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8261050c565b610553868361050c565b95508019841693508086168417925050509392505050565b6000819050919050565b600061059061058b610586846103ea565b61056b565b6103ea565b9050919050565b6000819050919050565b6105aa83610575565b6105be6105b682610597565b848454610519565b825550505050565b600090565b6105d36105c6565b6105de8184846105a1565b505050565b5b81811015610602576105f76000826105cb565b6001810190506105e4565b5050565b601f82111561064757610618816104e7565b610621846104fc565b81016020851015610630578190505b61064461063c856104fc565b8301826105e3565b50505b505050565b600082821c905092915050565b600061066a6000198460080261064c565b1980831691505092915050565b60006106838383610659565b9150826002028217905092915050565b61069c8261044d565b67ffffffffffffffff8111156106b5576106b4610458565b5b6106bf82546104b6565b6106ca828285610606565b600060209050601f8311600181146106fd57600084156106eb578287015190505b6106f58582610677565b86555061075d565b601f19841661070b866104e7565b60005b828110156107335784890151825560018201915060208501945060208101905061070e565b86831015610750578489015161074c601f891682610659565b8355505b6001600288020188555050505b505050505050565b600082825260208201905092915050565b7f45524332303a206d696e7420746f20746865207a65726f206164647265737300600082015250565b60006107ac601f83610765565b91506107b782610776565b602082019050919050565b600060208201905081810360008301526107db8161079f565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061081c826103ea565b9150610827836103ea565b925082820190508082111561083f5761083e6107e2565b5b92915050565b61084e816103ea565b82525050565b60006020820190506108696000830184610845565b92915050565b61259e8061087e6000396000f3fe6080604052600436106101665760003560e01c8063715018a6116100d1578063a457c2d71161008a578063d0ebdbe711610064578063d0ebdbe714610541578063dd62ed3e1461056a578063f2fde38b146105a7578063f3ae2415146105d057610166565b8063a457c2d7146104bd578063a9059cbb146104fa578063d0e30db01461053757610166565b8063715018a6146103c157806374a8f103146103d85780638da5cb5b146104015780639015d3711461042c57806395d89b41146104695780639dc29fac1461049457610166565b806324d7806c1161012357806324d7806c1461028d578063313ce567146102ca57806339509351146102f557806340c10f1914610332578063704b6c021461035b57806370a082311461038457610166565b80630356b6cd1461016b57806306fdde0314610194578063095ea7b3146101bf5780630aaf7043146101fc57806318160ddd1461022557806323b872dd14610250575b600080fd5b34801561017757600080fd5b50610192600480360381019061018d9190611a6a565b61060d565b005b3480156101a057600080fd5b506101a961070c565b6040516101b69190611b27565b60405180910390f35b3480156101cb57600080fd5b506101e660048036038101906101e19190611ba7565b61079e565b6040516101f39190611c02565b60405180910390f35b34801561020857600080fd5b50610223600480360381019061021e9190611c1d565b6107c1565b005b34801561023157600080fd5b5061023a6107d5565b6040516102479190611c59565b60405180910390f35b34801561025c57600080fd5b5061027760048036038101906102729190611c74565b6107df565b6040516102849190611c02565b60405180910390f35b34801561029957600080fd5b506102b460048036038101906102af9190611c1d565b61080e565b6040516102c19190611c02565b60405180910390f35b3480156102d657600080fd5b506102df6108bb565b6040516102ec9190611ce3565b60405180910390f35b34801561030157600080fd5b5061031c60048036038101906103179190611ba7565b6108c4565b6040516103299190611c02565b60405180910390f35b34801561033e57600080fd5b5061035960048036038101906103549190611ba7565b6108fb565b005b34801561036757600080fd5b50610382600480360381019061037d9190611c1d565b610911565b005b34801561039057600080fd5b506103ab60048036038101906103a69190611c1d565b610925565b6040516103b89190611c59565b60405180910390f35b3480156103cd57600080fd5b506103d661096d565b005b3480156103e457600080fd5b506103ff60048036038101906103fa9190611c1d565b610981565b005b34801561040d57600080fd5b50610416610995565b6040516104239190611d0d565b60405180910390f35b34801561043857600080fd5b50610453600480360381019061044e9190611c1d565b6109bf565b6040516104609190611c02565b60405180910390f35b34801561047557600080fd5b5061047e610a6d565b60405161048b9190611b27565b60405180910390f35b3480156104a057600080fd5b506104bb60048036038101906104b69190611ba7565b610aff565b005b3480156104c957600080fd5b506104e460048036038101906104df9190611ba7565b610b15565b6040516104f19190611c02565b60405180910390f35b34801561050657600080fd5b50610521600480360381019061051c9190611ba7565b610b8c565b60405161052e9190611c02565b60405180910390f35b61053f610baf565b005b34801561054d57600080fd5b5061056860048036038101906105639190611c1d565b610c72565b005b34801561057657600080fd5b50610591600480360381019061058c9190611d28565b610c86565b60405161059e9190611c59565b60405180910390f35b3480156105b357600080fd5b506105ce60048036038101906105c99190611c1d565b610d0d565b005b3480156105dc57600080fd5b506105f760048036038101906105f29190611c1d565b610d90565b6040516106049190611c02565b60405180910390f35b61061e610618610e3d565b82610e45565b600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16634f5aaaba610664610e3d565b836040518363ffffffff1660e01b8152600401610682929190611d68565b600060405180830381600087803b15801561069c57600080fd5b505af11580156106b0573d6000803e3d6000fd5b505050506106bc610e3d565b73ffffffffffffffffffffffffffffffffffffffff167f25bedde6c8ebd3a89b719a16299dbfe271c7bffa42fe1ac1a52e15ab0cb767e6826040516107019190611c59565b60405180910390a250565b60606003805461071b90611dc0565b80601f016020809104026020016040519081016040528092919081815260200182805461074790611dc0565b80156107945780601f1061076957610100808354040283529160200191610794565b820191906000526020600020905b81548152906001019060200180831161077757829003601f168201915b5050505050905090565b6000806107a9610e3d565b90506107b6818585611012565b600191505092915050565b6107c96111db565b6107d281611259565b50565b6000600254905090565b6000806107ea610e3d565b90506107f78582856112e9565b610802858585611375565b60019150509392505050565b600080600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b815260040161086c9190611d0d565b602060405180830381865afa158015610889573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108ad9190611e06565b905060028114915050919050565b60006012905090565b6000806108cf610e3d565b90506108f08185856108e18589610c86565b6108eb9190611e62565b611012565b600191505092915050565b6109036111db565b61090d82826115eb565b5050565b6109196111db565b61092281611741565b50565b60008060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050919050565b6109756111db565b61097f60006117d1565b565b6109896111db565b61099281611897565b50565b6000600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b600080600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b8152600401610a1d9190611d0d565b602060405180830381865afa158015610a3a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a5e9190611e06565b90506000811415915050919050565b606060048054610a7c90611dc0565b80601f0160208091040260200160405190810160405280929190818152602001828054610aa890611dc0565b8015610af55780601f10610aca57610100808354040283529160200191610af5565b820191906000526020600020905b815481529060010190602001808311610ad857829003601f168201915b5050505050905090565b610b076111db565b610b118282610e45565b5050565b600080610b20610e3d565b90506000610b2e8286610c86565b905083811015610b73576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b6a90611f08565b60405180910390fd5b610b808286868403611012565b60019250505092915050565b600080610b97610e3d565b9050610ba4818585611375565b600191505092915050565b73010000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166108fc349081150290604051600060405180830381858888f19350505050158015610c09573d6000803e3d6000fd5b50610c1b610c15610e3d565b346115eb565b610c23610e3d565b73ffffffffffffffffffffffffffffffffffffffff167fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c34604051610c689190611c59565b60405180910390a2565b610c7a6111db565b610c8381611995565b50565b6000600160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905092915050565b610d156111db565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603610d84576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610d7b90611f9a565b60405180910390fd5b610d8d816117d1565b50565b600080600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b8152600401610dee9190611d0d565b602060405180830381865afa158015610e0b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e2f9190611e06565b905060038114915050919050565b600033905090565b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1603610eb4576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610eab9061202c565b60405180910390fd5b610ec082600083611a25565b60008060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905081811015610f46576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610f3d906120be565b60405180910390fd5b8181036000808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555081600260008282540392505081905550600073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef84604051610ff99190611c59565b60405180910390a361100d83600084611a2a565b505050565b600073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1603611081576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161107890612150565b60405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16036110f0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016110e7906121e2565b60405180910390fd5b80600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925836040516111ce9190611c59565b60405180910390a3505050565b6111e3610e3d565b73ffffffffffffffffffffffffffffffffffffffff16611201610995565b73ffffffffffffffffffffffffffffffffffffffff1614611257576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161124e9061224e565b60405180910390fd5b565b600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043826040518263ffffffff1660e01b81526004016112b49190611d0d565b600060405180830381600087803b1580156112ce57600080fd5b505af11580156112e2573d6000803e3d6000fd5b5050505050565b60006112f58484610c86565b90507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff811461136f5781811015611361576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611358906122ba565b60405180910390fd5b61136e8484848403611012565b5b50505050565b600073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16036113e4576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016113db9061234c565b60405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1603611453576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161144a906123de565b60405180910390fd5b61145e838383611a25565b60008060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050818110156114e4576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016114db90612470565b60405180910390fd5b8181036000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550816000808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040516115d29190611c59565b60405180910390a36115e5848484611a2a565b50505050565b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff160361165a576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611651906124dc565b60405180910390fd5b61166660008383611a25565b80600260008282546116789190611e62565b92505081905550806000808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508173ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040516117299190611c59565b60405180910390a361173d60008383611a2a565b5050565b600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663704b6c02826040518263ffffffff1660e01b815260040161179c9190611d0d565b600060405180830381600087803b1580156117b657600080fd5b505af11580156117ca573d6000803e3d6000fd5b5050505050565b6000600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905081600560006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b8073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1603611905576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016118fc90612548565b60405180910390fd5b600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638c6bfb3b826040518263ffffffff1660e01b81526004016119609190611d0d565b600060405180830381600087803b15801561197a57600080fd5b505af115801561198e573d6000803e3d6000fd5b5050505050565b600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d0ebdbe7826040518263ffffffff1660e01b81526004016119f09190611d0d565b600060405180830381600087803b158015611a0a57600080fd5b505af1158015611a1e573d6000803e3d6000fd5b5050505050565b505050565b505050565b600080fd5b6000819050919050565b611a4781611a34565b8114611a5257600080fd5b50565b600081359050611a6481611a3e565b92915050565b600060208284031215611a8057611a7f611a2f565b5b6000611a8e84828501611a55565b91505092915050565b600081519050919050565b600082825260208201905092915050565b60005b83811015611ad1578082015181840152602081019050611ab6565b60008484015250505050565b6000601f19601f8301169050919050565b6000611af982611a97565b611b038185611aa2565b9350611b13818560208601611ab3565b611b1c81611add565b840191505092915050565b60006020820190508181036000830152611b418184611aee565b905092915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000611b7482611b49565b9050919050565b611b8481611b69565b8114611b8f57600080fd5b50565b600081359050611ba181611b7b565b92915050565b60008060408385031215611bbe57611bbd611a2f565b5b6000611bcc85828601611b92565b9250506020611bdd85828601611a55565b9150509250929050565b60008115159050919050565b611bfc81611be7565b82525050565b6000602082019050611c176000830184611bf3565b92915050565b600060208284031215611c3357611c32611a2f565b5b6000611c4184828501611b92565b91505092915050565b611c5381611a34565b82525050565b6000602082019050611c6e6000830184611c4a565b92915050565b600080600060608486031215611c8d57611c8c611a2f565b5b6000611c9b86828701611b92565b9350506020611cac86828701611b92565b9250506040611cbd86828701611a55565b9150509250925092565b600060ff82169050919050565b611cdd81611cc7565b82525050565b6000602082019050611cf86000830184611cd4565b92915050565b611d0781611b69565b82525050565b6000602082019050611d226000830184611cfe565b92915050565b60008060408385031215611d3f57611d3e611a2f565b5b6000611d4d85828601611b92565b9250506020611d5e85828601611b92565b9150509250929050565b6000604082019050611d7d6000830185611cfe565b611d8a6020830184611c4a565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680611dd857607f821691505b602082108103611deb57611dea611d91565b5b50919050565b600081519050611e0081611a3e565b92915050565b600060208284031215611e1c57611e1b611a2f565b5b6000611e2a84828501611df1565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000611e6d82611a34565b9150611e7883611a34565b9250828201905080821115611e9057611e8f611e33565b5b92915050565b7f45524332303a2064656372656173656420616c6c6f77616e63652062656c6f7760008201527f207a65726f000000000000000000000000000000000000000000000000000000602082015250565b6000611ef2602583611aa2565b9150611efd82611e96565b604082019050919050565b60006020820190508181036000830152611f2181611ee5565b9050919050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160008201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b6000611f84602683611aa2565b9150611f8f82611f28565b604082019050919050565b60006020820190508181036000830152611fb381611f77565b9050919050565b7f45524332303a206275726e2066726f6d20746865207a65726f2061646472657360008201527f7300000000000000000000000000000000000000000000000000000000000000602082015250565b6000612016602183611aa2565b915061202182611fba565b604082019050919050565b6000602082019050818103600083015261204581612009565b9050919050565b7f45524332303a206275726e20616d6f756e7420657863656564732062616c616e60008201527f6365000000000000000000000000000000000000000000000000000000000000602082015250565b60006120a8602283611aa2565b91506120b38261204c565b604082019050919050565b600060208201905081810360008301526120d78161209b565b9050919050565b7f45524332303a20617070726f76652066726f6d20746865207a65726f2061646460008201527f7265737300000000000000000000000000000000000000000000000000000000602082015250565b600061213a602483611aa2565b9150612145826120de565b604082019050919050565b600060208201905081810360008301526121698161212d565b9050919050565b7f45524332303a20617070726f766520746f20746865207a65726f20616464726560008201527f7373000000000000000000000000000000000000000000000000000000000000602082015250565b60006121cc602283611aa2565b91506121d782612170565b604082019050919050565b600060208201905081810360008301526121fb816121bf565b9050919050565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572600082015250565b6000612238602083611aa2565b915061224382612202565b602082019050919050565b600060208201905081810360008301526122678161222b565b9050919050565b7f45524332303a20696e73756666696369656e7420616c6c6f77616e6365000000600082015250565b60006122a4601d83611aa2565b91506122af8261226e565b602082019050919050565b600060208201905081810360008301526122d381612297565b9050919050565b7f45524332303a207472616e736665722066726f6d20746865207a65726f20616460008201527f6472657373000000000000000000000000000000000000000000000000000000602082015250565b6000612336602583611aa2565b9150612341826122da565b604082019050919050565b6000602082019050818103600083015261236581612329565b9050919050565b7f45524332303a207472616e7366657220746f20746865207a65726f206164647260008201527f6573730000000000000000000000000000000000000000000000000000000000602082015250565b60006123c8602383611aa2565b91506123d38261236c565b604082019050919050565b600060208201905081810360008301526123f7816123bb565b9050919050565b7f45524332303a207472616e7366657220616d6f756e742065786365656473206260008201527f616c616e63650000000000000000000000000000000000000000000000000000602082015250565b600061245a602683611aa2565b9150612465826123fe565b604082019050919050565b600060208201905081810360008301526124898161244d565b9050919050565b7f45524332303a206d696e7420746f20746865207a65726f206164647265737300600082015250565b60006124c6601f83611aa2565b91506124d182612490565b602082019050919050565b600060208201905081810360008301526124f5816124b9565b9050919050565b7f63616e6e6f74207265766f6b65206f776e20726f6c6500000000000000000000600082015250565b6000612532601683611aa2565b915061253d826124fc565b602082019050919050565b6000602082019050818103600083015261256181612525565b905091905056fea26469706673582212208960f6ed0b8f3e3aed90fcb6ffa061c05a2275fca566a1d5b4d2bbcbf9228ec364736f6c634300081a0033608060405234801561001057600080fd5b50604051610364380380610364833981810160405281019061003291906100db565b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050610108565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006100a88261007d565b9050919050565b6100b88161009d565b81146100c357600080fd5b50565b6000815190506100d5816100af565b92915050565b6000602082840312156100f1576100f0610078565b5b60006100ff848285016100c6565b91505092915050565b61024d806101176000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80630356b6cd1461003b578063b6b55f2514610057575b600080fd5b610055600480360381019061005091906101c0565b610073565b005b610071600480360381019061006c91906101c0565b610101565b005b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630356b6cd826040518263ffffffff1660e01b81526004016100cc91906101fc565b600060405180830381600087803b1580156100e657600080fd5b505af11580156100fa573d6000803e3d6000fd5b5050505050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d0e30db0826040518263ffffffff1660e01b81526004016000604051808303818588803b15801561016957600080fd5b505af115801561017d573d6000803e3d6000fd5b505050505050565b600080fd5b6000819050919050565b61019d8161018a565b81146101a857600080fd5b50565b6000813590506101ba81610194565b92915050565b6000602082840312156101d6576101d5610185565b5b60006101e4848285016101ab565b91505092915050565b6101f68161018a565b82525050565b600060208201905061021160008301846101ed565b9291505056fea26469706673582212202f7464e4ba0efd60b76b57adf42e37a8cad238848f0b5f4bedc95eeb8b600dd464736f6c634300081a0033a2646970667358221220eb1b31399e89a4048f34893ac88d26cf70ef1141658b43d7f7af6a79411841e364736f6c634300081a0033",
}

// ERC20NativeMinterTestABI is the input ABI used to generate the binding from.
// Deprecated: Use ERC20NativeMinterTestMetaData.ABI instead.
var ERC20NativeMinterTestABI = ERC20NativeMinterTestMetaData.ABI

// ERC20NativeMinterTestBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use ERC20NativeMinterTestMetaData.Bin instead.
var ERC20NativeMinterTestBin = ERC20NativeMinterTestMetaData.Bin

// DeployERC20NativeMinterTest deploys a new Ethereum contract, binding an instance of ERC20NativeMinterTest to it.
func DeployERC20NativeMinterTest(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ERC20NativeMinterTest, error) {
	parsed, err := ERC20NativeMinterTestMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(ERC20NativeMinterTestBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ERC20NativeMinterTest{ERC20NativeMinterTestCaller: ERC20NativeMinterTestCaller{contract: contract}, ERC20NativeMinterTestTransactor: ERC20NativeMinterTestTransactor{contract: contract}, ERC20NativeMinterTestFilterer: ERC20NativeMinterTestFilterer{contract: contract}}, nil
}

// ERC20NativeMinterTest is an auto generated Go binding around an Ethereum contract.
type ERC20NativeMinterTest struct {
	ERC20NativeMinterTestCaller     // Read-only binding to the contract
	ERC20NativeMinterTestTransactor // Write-only binding to the contract
	ERC20NativeMinterTestFilterer   // Log filterer for contract events
}

// ERC20NativeMinterTestCaller is an auto generated read-only Go binding around an Ethereum contract.
type ERC20NativeMinterTestCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20NativeMinterTestTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ERC20NativeMinterTestTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20NativeMinterTestFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ERC20NativeMinterTestFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20NativeMinterTestSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ERC20NativeMinterTestSession struct {
	Contract     *ERC20NativeMinterTest // Generic contract binding to set the session for
	CallOpts     bind.CallOpts          // Call options to use throughout this session
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// ERC20NativeMinterTestCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ERC20NativeMinterTestCallerSession struct {
	Contract *ERC20NativeMinterTestCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts                // Call options to use throughout this session
}

// ERC20NativeMinterTestTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ERC20NativeMinterTestTransactorSession struct {
	Contract     *ERC20NativeMinterTestTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts                // Transaction auth options to use throughout this session
}

// ERC20NativeMinterTestRaw is an auto generated low-level Go binding around an Ethereum contract.
type ERC20NativeMinterTestRaw struct {
	Contract *ERC20NativeMinterTest // Generic contract binding to access the raw methods on
}

// ERC20NativeMinterTestCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ERC20NativeMinterTestCallerRaw struct {
	Contract *ERC20NativeMinterTestCaller // Generic read-only contract binding to access the raw methods on
}

// ERC20NativeMinterTestTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ERC20NativeMinterTestTransactorRaw struct {
	Contract *ERC20NativeMinterTestTransactor // Generic write-only contract binding to access the raw methods on
}

// NewERC20NativeMinterTest creates a new instance of ERC20NativeMinterTest, bound to a specific deployed contract.
func NewERC20NativeMinterTest(address common.Address, backend bind.ContractBackend) (*ERC20NativeMinterTest, error) {
	contract, err := bindERC20NativeMinterTest(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterTest{ERC20NativeMinterTestCaller: ERC20NativeMinterTestCaller{contract: contract}, ERC20NativeMinterTestTransactor: ERC20NativeMinterTestTransactor{contract: contract}, ERC20NativeMinterTestFilterer: ERC20NativeMinterTestFilterer{contract: contract}}, nil
}

// NewERC20NativeMinterTestCaller creates a new read-only instance of ERC20NativeMinterTest, bound to a specific deployed contract.
func NewERC20NativeMinterTestCaller(address common.Address, caller bind.ContractCaller) (*ERC20NativeMinterTestCaller, error) {
	contract, err := bindERC20NativeMinterTest(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterTestCaller{contract: contract}, nil
}

// NewERC20NativeMinterTestTransactor creates a new write-only instance of ERC20NativeMinterTest, bound to a specific deployed contract.
func NewERC20NativeMinterTestTransactor(address common.Address, transactor bind.ContractTransactor) (*ERC20NativeMinterTestTransactor, error) {
	contract, err := bindERC20NativeMinterTest(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterTestTransactor{contract: contract}, nil
}

// NewERC20NativeMinterTestFilterer creates a new log filterer instance of ERC20NativeMinterTest, bound to a specific deployed contract.
func NewERC20NativeMinterTestFilterer(address common.Address, filterer bind.ContractFilterer) (*ERC20NativeMinterTestFilterer, error) {
	contract, err := bindERC20NativeMinterTest(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterTestFilterer{contract: contract}, nil
}

// bindERC20NativeMinterTest binds a generic wrapper to an already deployed contract.
func bindERC20NativeMinterTest(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ERC20NativeMinterTestMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20NativeMinterTest *ERC20NativeMinterTestRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ERC20NativeMinterTest.Contract.ERC20NativeMinterTestCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20NativeMinterTest *ERC20NativeMinterTestRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20NativeMinterTest.Contract.ERC20NativeMinterTestTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20NativeMinterTest *ERC20NativeMinterTestRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20NativeMinterTest.Contract.ERC20NativeMinterTestTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20NativeMinterTest *ERC20NativeMinterTestCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ERC20NativeMinterTest.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20NativeMinterTest *ERC20NativeMinterTestTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20NativeMinterTest.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20NativeMinterTest *ERC20NativeMinterTestTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20NativeMinterTest.Contract.contract.Transact(opts, method, params...)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestCaller) ISTEST(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _ERC20NativeMinterTest.contract.Call(opts, &out, "IS_TEST")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestSession) ISTEST() (bool, error) {
	return _ERC20NativeMinterTest.Contract.ISTEST(&_ERC20NativeMinterTest.CallOpts)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestCallerSession) ISTEST() (bool, error) {
	return _ERC20NativeMinterTest.Contract.ISTEST(&_ERC20NativeMinterTest.CallOpts)
}

// Failed is a paid mutator transaction binding the contract method 0xba414fa6.
//
// Solidity: function failed() returns(bool)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestTransactor) Failed(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20NativeMinterTest.contract.Transact(opts, "failed")
}

// Failed is a paid mutator transaction binding the contract method 0xba414fa6.
//
// Solidity: function failed() returns(bool)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestSession) Failed() (*types.Transaction, error) {
	return _ERC20NativeMinterTest.Contract.Failed(&_ERC20NativeMinterTest.TransactOpts)
}

// Failed is a paid mutator transaction binding the contract method 0xba414fa6.
//
// Solidity: function failed() returns(bool)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestTransactorSession) Failed() (*types.Transaction, error) {
	return _ERC20NativeMinterTest.Contract.Failed(&_ERC20NativeMinterTest.TransactOpts)
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_ERC20NativeMinterTest *ERC20NativeMinterTestTransactor) SetUp(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20NativeMinterTest.contract.Transact(opts, "setUp")
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_ERC20NativeMinterTest *ERC20NativeMinterTestSession) SetUp() (*types.Transaction, error) {
	return _ERC20NativeMinterTest.Contract.SetUp(&_ERC20NativeMinterTest.TransactOpts)
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_ERC20NativeMinterTest *ERC20NativeMinterTestTransactorSession) SetUp() (*types.Transaction, error) {
	return _ERC20NativeMinterTest.Contract.SetUp(&_ERC20NativeMinterTest.TransactOpts)
}

// StepAddMinter is a paid mutator transaction binding the contract method 0x8aa3c51e.
//
// Solidity: function step_addMinter() returns()
func (_ERC20NativeMinterTest *ERC20NativeMinterTestTransactor) StepAddMinter(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20NativeMinterTest.contract.Transact(opts, "step_addMinter")
}

// StepAddMinter is a paid mutator transaction binding the contract method 0x8aa3c51e.
//
// Solidity: function step_addMinter() returns()
func (_ERC20NativeMinterTest *ERC20NativeMinterTestSession) StepAddMinter() (*types.Transaction, error) {
	return _ERC20NativeMinterTest.Contract.StepAddMinter(&_ERC20NativeMinterTest.TransactOpts)
}

// StepAddMinter is a paid mutator transaction binding the contract method 0x8aa3c51e.
//
// Solidity: function step_addMinter() returns()
func (_ERC20NativeMinterTest *ERC20NativeMinterTestTransactorSession) StepAddMinter() (*types.Transaction, error) {
	return _ERC20NativeMinterTest.Contract.StepAddMinter(&_ERC20NativeMinterTest.TransactOpts)
}

// StepAdminMintdraw is a paid mutator transaction binding the contract method 0xd07ba09b.
//
// Solidity: function step_adminMintdraw() returns()
func (_ERC20NativeMinterTest *ERC20NativeMinterTestTransactor) StepAdminMintdraw(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20NativeMinterTest.contract.Transact(opts, "step_adminMintdraw")
}

// StepAdminMintdraw is a paid mutator transaction binding the contract method 0xd07ba09b.
//
// Solidity: function step_adminMintdraw() returns()
func (_ERC20NativeMinterTest *ERC20NativeMinterTestSession) StepAdminMintdraw() (*types.Transaction, error) {
	return _ERC20NativeMinterTest.Contract.StepAdminMintdraw(&_ERC20NativeMinterTest.TransactOpts)
}

// StepAdminMintdraw is a paid mutator transaction binding the contract method 0xd07ba09b.
//
// Solidity: function step_adminMintdraw() returns()
func (_ERC20NativeMinterTest *ERC20NativeMinterTestTransactorSession) StepAdminMintdraw() (*types.Transaction, error) {
	return _ERC20NativeMinterTest.Contract.StepAdminMintdraw(&_ERC20NativeMinterTest.TransactOpts)
}

// StepMintdraw is a paid mutator transaction binding the contract method 0x1e752c47.
//
// Solidity: function step_mintdraw() returns()
func (_ERC20NativeMinterTest *ERC20NativeMinterTestTransactor) StepMintdraw(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20NativeMinterTest.contract.Transact(opts, "step_mintdraw")
}

// StepMintdraw is a paid mutator transaction binding the contract method 0x1e752c47.
//
// Solidity: function step_mintdraw() returns()
func (_ERC20NativeMinterTest *ERC20NativeMinterTestSession) StepMintdraw() (*types.Transaction, error) {
	return _ERC20NativeMinterTest.Contract.StepMintdraw(&_ERC20NativeMinterTest.TransactOpts)
}

// StepMintdraw is a paid mutator transaction binding the contract method 0x1e752c47.
//
// Solidity: function step_mintdraw() returns()
func (_ERC20NativeMinterTest *ERC20NativeMinterTestTransactorSession) StepMintdraw() (*types.Transaction, error) {
	return _ERC20NativeMinterTest.Contract.StepMintdraw(&_ERC20NativeMinterTest.TransactOpts)
}

// StepMintdrawFailure is a paid mutator transaction binding the contract method 0x5a4b3b63.
//
// Solidity: function step_mintdrawFailure() returns()
func (_ERC20NativeMinterTest *ERC20NativeMinterTestTransactor) StepMintdrawFailure(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20NativeMinterTest.contract.Transact(opts, "step_mintdrawFailure")
}

// StepMintdrawFailure is a paid mutator transaction binding the contract method 0x5a4b3b63.
//
// Solidity: function step_mintdrawFailure() returns()
func (_ERC20NativeMinterTest *ERC20NativeMinterTestSession) StepMintdrawFailure() (*types.Transaction, error) {
	return _ERC20NativeMinterTest.Contract.StepMintdrawFailure(&_ERC20NativeMinterTest.TransactOpts)
}

// StepMintdrawFailure is a paid mutator transaction binding the contract method 0x5a4b3b63.
//
// Solidity: function step_mintdrawFailure() returns()
func (_ERC20NativeMinterTest *ERC20NativeMinterTestTransactorSession) StepMintdrawFailure() (*types.Transaction, error) {
	return _ERC20NativeMinterTest.Contract.StepMintdrawFailure(&_ERC20NativeMinterTest.TransactOpts)
}

// StepMinterDeposit is a paid mutator transaction binding the contract method 0x1aeb30bf.
//
// Solidity: function step_minterDeposit() returns()
func (_ERC20NativeMinterTest *ERC20NativeMinterTestTransactor) StepMinterDeposit(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20NativeMinterTest.contract.Transact(opts, "step_minterDeposit")
}

// StepMinterDeposit is a paid mutator transaction binding the contract method 0x1aeb30bf.
//
// Solidity: function step_minterDeposit() returns()
func (_ERC20NativeMinterTest *ERC20NativeMinterTestSession) StepMinterDeposit() (*types.Transaction, error) {
	return _ERC20NativeMinterTest.Contract.StepMinterDeposit(&_ERC20NativeMinterTest.TransactOpts)
}

// StepMinterDeposit is a paid mutator transaction binding the contract method 0x1aeb30bf.
//
// Solidity: function step_minterDeposit() returns()
func (_ERC20NativeMinterTest *ERC20NativeMinterTestTransactorSession) StepMinterDeposit() (*types.Transaction, error) {
	return _ERC20NativeMinterTest.Contract.StepMinterDeposit(&_ERC20NativeMinterTest.TransactOpts)
}

// StepMinterMintdrawFailure is a paid mutator transaction binding the contract method 0xb1b5e2c0.
//
// Solidity: function step_minterMintdrawFailure() returns()
func (_ERC20NativeMinterTest *ERC20NativeMinterTestTransactor) StepMinterMintdrawFailure(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20NativeMinterTest.contract.Transact(opts, "step_minterMintdrawFailure")
}

// StepMinterMintdrawFailure is a paid mutator transaction binding the contract method 0xb1b5e2c0.
//
// Solidity: function step_minterMintdrawFailure() returns()
func (_ERC20NativeMinterTest *ERC20NativeMinterTestSession) StepMinterMintdrawFailure() (*types.Transaction, error) {
	return _ERC20NativeMinterTest.Contract.StepMinterMintdrawFailure(&_ERC20NativeMinterTest.TransactOpts)
}

// StepMinterMintdrawFailure is a paid mutator transaction binding the contract method 0xb1b5e2c0.
//
// Solidity: function step_minterMintdrawFailure() returns()
func (_ERC20NativeMinterTest *ERC20NativeMinterTestTransactorSession) StepMinterMintdrawFailure() (*types.Transaction, error) {
	return _ERC20NativeMinterTest.Contract.StepMinterMintdrawFailure(&_ERC20NativeMinterTest.TransactOpts)
}

// ERC20NativeMinterTestLogIterator is returned from FilterLog and is used to iterate over the raw logs and unpacked data for Log events raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogIterator struct {
	Event *ERC20NativeMinterTestLog // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20NativeMinterTestLogIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20NativeMinterTestLog)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20NativeMinterTestLog)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20NativeMinterTestLogIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20NativeMinterTestLogIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20NativeMinterTestLog represents a Log event raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLog struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLog is a free log retrieval operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) FilterLog(opts *bind.FilterOpts) (*ERC20NativeMinterTestLogIterator, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.FilterLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterTestLogIterator{contract: _ERC20NativeMinterTest.contract, event: "log", logs: logs, sub: sub}, nil
}

// WatchLog is a free log subscription operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) WatchLog(opts *bind.WatchOpts, sink chan<- *ERC20NativeMinterTestLog) (event.Subscription, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.WatchLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20NativeMinterTestLog)
				if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLog is a log parse operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) ParseLog(log types.Log) (*ERC20NativeMinterTestLog, error) {
	event := new(ERC20NativeMinterTestLog)
	if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20NativeMinterTestLogAddressIterator is returned from FilterLogAddress and is used to iterate over the raw logs and unpacked data for LogAddress events raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogAddressIterator struct {
	Event *ERC20NativeMinterTestLogAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20NativeMinterTestLogAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20NativeMinterTestLogAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20NativeMinterTestLogAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20NativeMinterTestLogAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20NativeMinterTestLogAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20NativeMinterTestLogAddress represents a LogAddress event raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogAddress struct {
	Arg0 common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogAddress is a free log retrieval operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) FilterLogAddress(opts *bind.FilterOpts) (*ERC20NativeMinterTestLogAddressIterator, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.FilterLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterTestLogAddressIterator{contract: _ERC20NativeMinterTest.contract, event: "log_address", logs: logs, sub: sub}, nil
}

// WatchLogAddress is a free log subscription operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) WatchLogAddress(opts *bind.WatchOpts, sink chan<- *ERC20NativeMinterTestLogAddress) (event.Subscription, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.WatchLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20NativeMinterTestLogAddress)
				if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogAddress is a log parse operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) ParseLogAddress(log types.Log) (*ERC20NativeMinterTestLogAddress, error) {
	event := new(ERC20NativeMinterTestLogAddress)
	if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_address", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20NativeMinterTestLogBytesIterator is returned from FilterLogBytes and is used to iterate over the raw logs and unpacked data for LogBytes events raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogBytesIterator struct {
	Event *ERC20NativeMinterTestLogBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20NativeMinterTestLogBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20NativeMinterTestLogBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20NativeMinterTestLogBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20NativeMinterTestLogBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20NativeMinterTestLogBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20NativeMinterTestLogBytes represents a LogBytes event raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogBytes struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes is a free log retrieval operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) FilterLogBytes(opts *bind.FilterOpts) (*ERC20NativeMinterTestLogBytesIterator, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.FilterLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterTestLogBytesIterator{contract: _ERC20NativeMinterTest.contract, event: "log_bytes", logs: logs, sub: sub}, nil
}

// WatchLogBytes is a free log subscription operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) WatchLogBytes(opts *bind.WatchOpts, sink chan<- *ERC20NativeMinterTestLogBytes) (event.Subscription, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.WatchLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20NativeMinterTestLogBytes)
				if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes is a log parse operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) ParseLogBytes(log types.Log) (*ERC20NativeMinterTestLogBytes, error) {
	event := new(ERC20NativeMinterTestLogBytes)
	if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20NativeMinterTestLogBytes32Iterator is returned from FilterLogBytes32 and is used to iterate over the raw logs and unpacked data for LogBytes32 events raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogBytes32Iterator struct {
	Event *ERC20NativeMinterTestLogBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20NativeMinterTestLogBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20NativeMinterTestLogBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20NativeMinterTestLogBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20NativeMinterTestLogBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20NativeMinterTestLogBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20NativeMinterTestLogBytes32 represents a LogBytes32 event raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogBytes32 struct {
	Arg0 [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes32 is a free log retrieval operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) FilterLogBytes32(opts *bind.FilterOpts) (*ERC20NativeMinterTestLogBytes32Iterator, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.FilterLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterTestLogBytes32Iterator{contract: _ERC20NativeMinterTest.contract, event: "log_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogBytes32 is a free log subscription operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) WatchLogBytes32(opts *bind.WatchOpts, sink chan<- *ERC20NativeMinterTestLogBytes32) (event.Subscription, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.WatchLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20NativeMinterTestLogBytes32)
				if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes32 is a log parse operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) ParseLogBytes32(log types.Log) (*ERC20NativeMinterTestLogBytes32, error) {
	event := new(ERC20NativeMinterTestLogBytes32)
	if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20NativeMinterTestLogIntIterator is returned from FilterLogInt and is used to iterate over the raw logs and unpacked data for LogInt events raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogIntIterator struct {
	Event *ERC20NativeMinterTestLogInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20NativeMinterTestLogIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20NativeMinterTestLogInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20NativeMinterTestLogInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20NativeMinterTestLogIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20NativeMinterTestLogIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20NativeMinterTestLogInt represents a LogInt event raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogInt struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogInt is a free log retrieval operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) FilterLogInt(opts *bind.FilterOpts) (*ERC20NativeMinterTestLogIntIterator, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.FilterLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterTestLogIntIterator{contract: _ERC20NativeMinterTest.contract, event: "log_int", logs: logs, sub: sub}, nil
}

// WatchLogInt is a free log subscription operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) WatchLogInt(opts *bind.WatchOpts, sink chan<- *ERC20NativeMinterTestLogInt) (event.Subscription, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.WatchLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20NativeMinterTestLogInt)
				if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogInt is a log parse operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) ParseLogInt(log types.Log) (*ERC20NativeMinterTestLogInt, error) {
	event := new(ERC20NativeMinterTestLogInt)
	if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_int", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20NativeMinterTestLogNamedAddressIterator is returned from FilterLogNamedAddress and is used to iterate over the raw logs and unpacked data for LogNamedAddress events raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogNamedAddressIterator struct {
	Event *ERC20NativeMinterTestLogNamedAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20NativeMinterTestLogNamedAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20NativeMinterTestLogNamedAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20NativeMinterTestLogNamedAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20NativeMinterTestLogNamedAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20NativeMinterTestLogNamedAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20NativeMinterTestLogNamedAddress represents a LogNamedAddress event raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogNamedAddress struct {
	Key string
	Val common.Address
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedAddress is a free log retrieval operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) FilterLogNamedAddress(opts *bind.FilterOpts) (*ERC20NativeMinterTestLogNamedAddressIterator, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.FilterLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterTestLogNamedAddressIterator{contract: _ERC20NativeMinterTest.contract, event: "log_named_address", logs: logs, sub: sub}, nil
}

// WatchLogNamedAddress is a free log subscription operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) WatchLogNamedAddress(opts *bind.WatchOpts, sink chan<- *ERC20NativeMinterTestLogNamedAddress) (event.Subscription, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.WatchLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20NativeMinterTestLogNamedAddress)
				if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedAddress is a log parse operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) ParseLogNamedAddress(log types.Log) (*ERC20NativeMinterTestLogNamedAddress, error) {
	event := new(ERC20NativeMinterTestLogNamedAddress)
	if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20NativeMinterTestLogNamedBytesIterator is returned from FilterLogNamedBytes and is used to iterate over the raw logs and unpacked data for LogNamedBytes events raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogNamedBytesIterator struct {
	Event *ERC20NativeMinterTestLogNamedBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20NativeMinterTestLogNamedBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20NativeMinterTestLogNamedBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20NativeMinterTestLogNamedBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20NativeMinterTestLogNamedBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20NativeMinterTestLogNamedBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20NativeMinterTestLogNamedBytes represents a LogNamedBytes event raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogNamedBytes struct {
	Key string
	Val []byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes is a free log retrieval operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) FilterLogNamedBytes(opts *bind.FilterOpts) (*ERC20NativeMinterTestLogNamedBytesIterator, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.FilterLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterTestLogNamedBytesIterator{contract: _ERC20NativeMinterTest.contract, event: "log_named_bytes", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes is a free log subscription operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) WatchLogNamedBytes(opts *bind.WatchOpts, sink chan<- *ERC20NativeMinterTestLogNamedBytes) (event.Subscription, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.WatchLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20NativeMinterTestLogNamedBytes)
				if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes is a log parse operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) ParseLogNamedBytes(log types.Log) (*ERC20NativeMinterTestLogNamedBytes, error) {
	event := new(ERC20NativeMinterTestLogNamedBytes)
	if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20NativeMinterTestLogNamedBytes32Iterator is returned from FilterLogNamedBytes32 and is used to iterate over the raw logs and unpacked data for LogNamedBytes32 events raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogNamedBytes32Iterator struct {
	Event *ERC20NativeMinterTestLogNamedBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20NativeMinterTestLogNamedBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20NativeMinterTestLogNamedBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20NativeMinterTestLogNamedBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20NativeMinterTestLogNamedBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20NativeMinterTestLogNamedBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20NativeMinterTestLogNamedBytes32 represents a LogNamedBytes32 event raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogNamedBytes32 struct {
	Key string
	Val [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes32 is a free log retrieval operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) FilterLogNamedBytes32(opts *bind.FilterOpts) (*ERC20NativeMinterTestLogNamedBytes32Iterator, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.FilterLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterTestLogNamedBytes32Iterator{contract: _ERC20NativeMinterTest.contract, event: "log_named_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes32 is a free log subscription operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) WatchLogNamedBytes32(opts *bind.WatchOpts, sink chan<- *ERC20NativeMinterTestLogNamedBytes32) (event.Subscription, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.WatchLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20NativeMinterTestLogNamedBytes32)
				if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes32 is a log parse operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) ParseLogNamedBytes32(log types.Log) (*ERC20NativeMinterTestLogNamedBytes32, error) {
	event := new(ERC20NativeMinterTestLogNamedBytes32)
	if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20NativeMinterTestLogNamedDecimalIntIterator is returned from FilterLogNamedDecimalInt and is used to iterate over the raw logs and unpacked data for LogNamedDecimalInt events raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogNamedDecimalIntIterator struct {
	Event *ERC20NativeMinterTestLogNamedDecimalInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20NativeMinterTestLogNamedDecimalIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20NativeMinterTestLogNamedDecimalInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20NativeMinterTestLogNamedDecimalInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20NativeMinterTestLogNamedDecimalIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20NativeMinterTestLogNamedDecimalIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20NativeMinterTestLogNamedDecimalInt represents a LogNamedDecimalInt event raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogNamedDecimalInt struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalInt is a free log retrieval operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) FilterLogNamedDecimalInt(opts *bind.FilterOpts) (*ERC20NativeMinterTestLogNamedDecimalIntIterator, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.FilterLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterTestLogNamedDecimalIntIterator{contract: _ERC20NativeMinterTest.contract, event: "log_named_decimal_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalInt is a free log subscription operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) WatchLogNamedDecimalInt(opts *bind.WatchOpts, sink chan<- *ERC20NativeMinterTestLogNamedDecimalInt) (event.Subscription, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.WatchLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20NativeMinterTestLogNamedDecimalInt)
				if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalInt is a log parse operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) ParseLogNamedDecimalInt(log types.Log) (*ERC20NativeMinterTestLogNamedDecimalInt, error) {
	event := new(ERC20NativeMinterTestLogNamedDecimalInt)
	if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20NativeMinterTestLogNamedDecimalUintIterator is returned from FilterLogNamedDecimalUint and is used to iterate over the raw logs and unpacked data for LogNamedDecimalUint events raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogNamedDecimalUintIterator struct {
	Event *ERC20NativeMinterTestLogNamedDecimalUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20NativeMinterTestLogNamedDecimalUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20NativeMinterTestLogNamedDecimalUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20NativeMinterTestLogNamedDecimalUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20NativeMinterTestLogNamedDecimalUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20NativeMinterTestLogNamedDecimalUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20NativeMinterTestLogNamedDecimalUint represents a LogNamedDecimalUint event raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogNamedDecimalUint struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalUint is a free log retrieval operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) FilterLogNamedDecimalUint(opts *bind.FilterOpts) (*ERC20NativeMinterTestLogNamedDecimalUintIterator, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.FilterLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterTestLogNamedDecimalUintIterator{contract: _ERC20NativeMinterTest.contract, event: "log_named_decimal_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalUint is a free log subscription operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) WatchLogNamedDecimalUint(opts *bind.WatchOpts, sink chan<- *ERC20NativeMinterTestLogNamedDecimalUint) (event.Subscription, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.WatchLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20NativeMinterTestLogNamedDecimalUint)
				if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalUint is a log parse operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) ParseLogNamedDecimalUint(log types.Log) (*ERC20NativeMinterTestLogNamedDecimalUint, error) {
	event := new(ERC20NativeMinterTestLogNamedDecimalUint)
	if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20NativeMinterTestLogNamedIntIterator is returned from FilterLogNamedInt and is used to iterate over the raw logs and unpacked data for LogNamedInt events raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogNamedIntIterator struct {
	Event *ERC20NativeMinterTestLogNamedInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20NativeMinterTestLogNamedIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20NativeMinterTestLogNamedInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20NativeMinterTestLogNamedInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20NativeMinterTestLogNamedIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20NativeMinterTestLogNamedIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20NativeMinterTestLogNamedInt represents a LogNamedInt event raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogNamedInt struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedInt is a free log retrieval operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) FilterLogNamedInt(opts *bind.FilterOpts) (*ERC20NativeMinterTestLogNamedIntIterator, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.FilterLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterTestLogNamedIntIterator{contract: _ERC20NativeMinterTest.contract, event: "log_named_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedInt is a free log subscription operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) WatchLogNamedInt(opts *bind.WatchOpts, sink chan<- *ERC20NativeMinterTestLogNamedInt) (event.Subscription, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.WatchLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20NativeMinterTestLogNamedInt)
				if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedInt is a log parse operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) ParseLogNamedInt(log types.Log) (*ERC20NativeMinterTestLogNamedInt, error) {
	event := new(ERC20NativeMinterTestLogNamedInt)
	if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20NativeMinterTestLogNamedStringIterator is returned from FilterLogNamedString and is used to iterate over the raw logs and unpacked data for LogNamedString events raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogNamedStringIterator struct {
	Event *ERC20NativeMinterTestLogNamedString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20NativeMinterTestLogNamedStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20NativeMinterTestLogNamedString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20NativeMinterTestLogNamedString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20NativeMinterTestLogNamedStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20NativeMinterTestLogNamedStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20NativeMinterTestLogNamedString represents a LogNamedString event raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogNamedString struct {
	Key string
	Val string
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedString is a free log retrieval operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) FilterLogNamedString(opts *bind.FilterOpts) (*ERC20NativeMinterTestLogNamedStringIterator, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.FilterLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterTestLogNamedStringIterator{contract: _ERC20NativeMinterTest.contract, event: "log_named_string", logs: logs, sub: sub}, nil
}

// WatchLogNamedString is a free log subscription operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) WatchLogNamedString(opts *bind.WatchOpts, sink chan<- *ERC20NativeMinterTestLogNamedString) (event.Subscription, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.WatchLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20NativeMinterTestLogNamedString)
				if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedString is a log parse operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) ParseLogNamedString(log types.Log) (*ERC20NativeMinterTestLogNamedString, error) {
	event := new(ERC20NativeMinterTestLogNamedString)
	if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20NativeMinterTestLogNamedUintIterator is returned from FilterLogNamedUint and is used to iterate over the raw logs and unpacked data for LogNamedUint events raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogNamedUintIterator struct {
	Event *ERC20NativeMinterTestLogNamedUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20NativeMinterTestLogNamedUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20NativeMinterTestLogNamedUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20NativeMinterTestLogNamedUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20NativeMinterTestLogNamedUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20NativeMinterTestLogNamedUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20NativeMinterTestLogNamedUint represents a LogNamedUint event raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogNamedUint struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedUint is a free log retrieval operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) FilterLogNamedUint(opts *bind.FilterOpts) (*ERC20NativeMinterTestLogNamedUintIterator, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.FilterLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterTestLogNamedUintIterator{contract: _ERC20NativeMinterTest.contract, event: "log_named_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedUint is a free log subscription operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) WatchLogNamedUint(opts *bind.WatchOpts, sink chan<- *ERC20NativeMinterTestLogNamedUint) (event.Subscription, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.WatchLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20NativeMinterTestLogNamedUint)
				if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedUint is a log parse operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) ParseLogNamedUint(log types.Log) (*ERC20NativeMinterTestLogNamedUint, error) {
	event := new(ERC20NativeMinterTestLogNamedUint)
	if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20NativeMinterTestLogStringIterator is returned from FilterLogString and is used to iterate over the raw logs and unpacked data for LogString events raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogStringIterator struct {
	Event *ERC20NativeMinterTestLogString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20NativeMinterTestLogStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20NativeMinterTestLogString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20NativeMinterTestLogString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20NativeMinterTestLogStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20NativeMinterTestLogStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20NativeMinterTestLogString represents a LogString event raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogString struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogString is a free log retrieval operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) FilterLogString(opts *bind.FilterOpts) (*ERC20NativeMinterTestLogStringIterator, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.FilterLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterTestLogStringIterator{contract: _ERC20NativeMinterTest.contract, event: "log_string", logs: logs, sub: sub}, nil
}

// WatchLogString is a free log subscription operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) WatchLogString(opts *bind.WatchOpts, sink chan<- *ERC20NativeMinterTestLogString) (event.Subscription, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.WatchLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20NativeMinterTestLogString)
				if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogString is a log parse operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) ParseLogString(log types.Log) (*ERC20NativeMinterTestLogString, error) {
	event := new(ERC20NativeMinterTestLogString)
	if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_string", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20NativeMinterTestLogUintIterator is returned from FilterLogUint and is used to iterate over the raw logs and unpacked data for LogUint events raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogUintIterator struct {
	Event *ERC20NativeMinterTestLogUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20NativeMinterTestLogUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20NativeMinterTestLogUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20NativeMinterTestLogUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20NativeMinterTestLogUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20NativeMinterTestLogUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20NativeMinterTestLogUint represents a LogUint event raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogUint struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogUint is a free log retrieval operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) FilterLogUint(opts *bind.FilterOpts) (*ERC20NativeMinterTestLogUintIterator, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.FilterLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterTestLogUintIterator{contract: _ERC20NativeMinterTest.contract, event: "log_uint", logs: logs, sub: sub}, nil
}

// WatchLogUint is a free log subscription operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) WatchLogUint(opts *bind.WatchOpts, sink chan<- *ERC20NativeMinterTestLogUint) (event.Subscription, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.WatchLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20NativeMinterTestLogUint)
				if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogUint is a log parse operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) ParseLogUint(log types.Log) (*ERC20NativeMinterTestLogUint, error) {
	event := new(ERC20NativeMinterTestLogUint)
	if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "log_uint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20NativeMinterTestLogsIterator is returned from FilterLogs and is used to iterate over the raw logs and unpacked data for Logs events raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogsIterator struct {
	Event *ERC20NativeMinterTestLogs // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20NativeMinterTestLogsIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20NativeMinterTestLogs)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20NativeMinterTestLogs)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20NativeMinterTestLogsIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20NativeMinterTestLogsIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20NativeMinterTestLogs represents a Logs event raised by the ERC20NativeMinterTest contract.
type ERC20NativeMinterTestLogs struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogs is a free log retrieval operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) FilterLogs(opts *bind.FilterOpts) (*ERC20NativeMinterTestLogsIterator, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.FilterLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return &ERC20NativeMinterTestLogsIterator{contract: _ERC20NativeMinterTest.contract, event: "logs", logs: logs, sub: sub}, nil
}

// WatchLogs is a free log subscription operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) WatchLogs(opts *bind.WatchOpts, sink chan<- *ERC20NativeMinterTestLogs) (event.Subscription, error) {

	logs, sub, err := _ERC20NativeMinterTest.contract.WatchLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20NativeMinterTestLogs)
				if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "logs", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogs is a log parse operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_ERC20NativeMinterTest *ERC20NativeMinterTestFilterer) ParseLogs(log types.Log) (*ERC20NativeMinterTestLogs, error) {
	event := new(ERC20NativeMinterTestLogs)
	if err := _ERC20NativeMinterTest.contract.UnpackLog(event, "logs", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EmptyMetaData contains all meta data concerning the Empty contract.
var EmptyMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea264697066735822122095e71fe7b8a7d8101f30ba68f5e4e09352023917522f32686f9c7d10ae36668964736f6c634300081a0033",
}

// EmptyABI is the input ABI used to generate the binding from.
// Deprecated: Use EmptyMetaData.ABI instead.
var EmptyABI = EmptyMetaData.ABI

// EmptyBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use EmptyMetaData.Bin instead.
var EmptyBin = EmptyMetaData.Bin

// DeployEmpty deploys a new Ethereum contract, binding an instance of Empty to it.
func DeployEmpty(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Empty, error) {
	parsed, err := EmptyMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(EmptyBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Empty{EmptyCaller: EmptyCaller{contract: contract}, EmptyTransactor: EmptyTransactor{contract: contract}, EmptyFilterer: EmptyFilterer{contract: contract}}, nil
}

// Empty is an auto generated Go binding around an Ethereum contract.
type Empty struct {
	EmptyCaller     // Read-only binding to the contract
	EmptyTransactor // Write-only binding to the contract
	EmptyFilterer   // Log filterer for contract events
}

// EmptyCaller is an auto generated read-only Go binding around an Ethereum contract.
type EmptyCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EmptyTransactor is an auto generated write-only Go binding around an Ethereum contract.
type EmptyTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EmptyFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type EmptyFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EmptySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type EmptySession struct {
	Contract     *Empty            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// EmptyCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type EmptyCallerSession struct {
	Contract *EmptyCaller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// EmptyTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type EmptyTransactorSession struct {
	Contract     *EmptyTransactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// EmptyRaw is an auto generated low-level Go binding around an Ethereum contract.
type EmptyRaw struct {
	Contract *Empty // Generic contract binding to access the raw methods on
}

// EmptyCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type EmptyCallerRaw struct {
	Contract *EmptyCaller // Generic read-only contract binding to access the raw methods on
}

// EmptyTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type EmptyTransactorRaw struct {
	Contract *EmptyTransactor // Generic write-only contract binding to access the raw methods on
}

// NewEmpty creates a new instance of Empty, bound to a specific deployed contract.
func NewEmpty(address common.Address, backend bind.ContractBackend) (*Empty, error) {
	contract, err := bindEmpty(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Empty{EmptyCaller: EmptyCaller{contract: contract}, EmptyTransactor: EmptyTransactor{contract: contract}, EmptyFilterer: EmptyFilterer{contract: contract}}, nil
}

// NewEmptyCaller creates a new read-only instance of Empty, bound to a specific deployed contract.
func NewEmptyCaller(address common.Address, caller bind.ContractCaller) (*EmptyCaller, error) {
	contract, err := bindEmpty(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &EmptyCaller{contract: contract}, nil
}

// NewEmptyTransactor creates a new write-only instance of Empty, bound to a specific deployed contract.
func NewEmptyTransactor(address common.Address, transactor bind.ContractTransactor) (*EmptyTransactor, error) {
	contract, err := bindEmpty(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &EmptyTransactor{contract: contract}, nil
}

// NewEmptyFilterer creates a new log filterer instance of Empty, bound to a specific deployed contract.
func NewEmptyFilterer(address common.Address, filterer bind.ContractFilterer) (*EmptyFilterer, error) {
	contract, err := bindEmpty(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &EmptyFilterer{contract: contract}, nil
}

// bindEmpty binds a generic wrapper to an already deployed contract.
func bindEmpty(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := EmptyMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Empty *EmptyRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Empty.Contract.EmptyCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Empty *EmptyRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Empty.Contract.EmptyTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Empty *EmptyRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Empty.Contract.EmptyTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Empty *EmptyCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Empty.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Empty *EmptyTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Empty.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Empty *EmptyTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Empty.Contract.contract.Transact(opts, method, params...)
}

// ExampleDeployerListMetaData contains all meta data concerning the ExampleDeployerList contract.
var ExampleDeployerListMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"deployContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"revoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x608060405234801561001057600080fd5b5073020000000000000000000000000000000000000061004261003761008960201b60201c565b61009160201b60201c565b80600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050610155565b600033905090565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b610ca4806101646000396000f3fe608060405234801561001057600080fd5b50600436106100a95760003560e01c806374a8f1031161007157806374a8f1031461012a5780638da5cb5b146101465780639015d37114610164578063d0ebdbe714610194578063f2fde38b146101b0578063f3ae2415146101cc576100a9565b80630aaf7043146100ae57806324d7806c146100ca5780636cd5c39b146100fa578063704b6c0214610104578063715018a614610120575b600080fd5b6100c860048036038101906100c391906109a7565b6101fc565b005b6100e460048036038101906100df91906109a7565b610210565b6040516100f191906109ef565b60405180910390f35b6101026102bd565b005b61011e600480360381019061011991906109a7565b6102e9565b005b6101286102fd565b005b610144600480360381019061013f91906109a7565b610311565b005b61014e610325565b60405161015b9190610a19565b60405180910390f35b61017e600480360381019061017991906109a7565b61034e565b60405161018b91906109ef565b60405180910390f35b6101ae60048036038101906101a991906109a7565b6103fc565b005b6101ca60048036038101906101c591906109a7565b610410565b005b6101e660048036038101906101e191906109a7565b610493565b6040516101f391906109ef565b60405180910390f35b610204610540565b61020d816105be565b50565b600080600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b815260040161026e9190610a19565b602060405180830381865afa15801561028b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102af9190610a6a565b905060028114915050919050565b6040516102c990610938565b604051809103906000f0801580156102e5573d6000803e3d6000fd5b5050565b6102f1610540565b6102fa8161064e565b50565b610305610540565b61030f60006106de565b565b610319610540565b610322816107a2565b50565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b600080600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b81526004016103ac9190610a19565b602060405180830381865afa1580156103c9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103ed9190610a6a565b90506000811415915050919050565b610404610540565b61040d816108a0565b50565b610418610540565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603610487576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161047e90610b1a565b60405180910390fd5b610490816106de565b50565b600080600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b81526004016104f19190610a19565b602060405180830381865afa15801561050e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105329190610a6a565b905060038114915050919050565b610548610930565b73ffffffffffffffffffffffffffffffffffffffff16610566610325565b73ffffffffffffffffffffffffffffffffffffffff16146105bc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105b390610b86565b60405180910390fd5b565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043826040518263ffffffff1660e01b81526004016106199190610a19565b600060405180830381600087803b15801561063357600080fd5b505af1158015610647573d6000803e3d6000fd5b5050505050565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663704b6c02826040518263ffffffff1660e01b81526004016106a99190610a19565b600060405180830381600087803b1580156106c357600080fd5b505af11580156106d7573d6000803e3d6000fd5b5050505050565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b8073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1603610810576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161080790610bf2565b60405180910390fd5b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638c6bfb3b826040518263ffffffff1660e01b815260040161086b9190610a19565b600060405180830381600087803b15801561088557600080fd5b505af1158015610899573d6000803e3d6000fd5b5050505050565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d0ebdbe7826040518263ffffffff1660e01b81526004016108fb9190610a19565b600060405180830381600087803b15801561091557600080fd5b505af1158015610929573d6000803e3d6000fd5b5050505050565b600033905090565b605c80610c1383390190565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061097482610949565b9050919050565b61098481610969565b811461098f57600080fd5b50565b6000813590506109a18161097b565b92915050565b6000602082840312156109bd576109bc610944565b5b60006109cb84828501610992565b91505092915050565b60008115159050919050565b6109e9816109d4565b82525050565b6000602082019050610a0460008301846109e0565b92915050565b610a1381610969565b82525050565b6000602082019050610a2e6000830184610a0a565b92915050565b6000819050919050565b610a4781610a34565b8114610a5257600080fd5b50565b600081519050610a6481610a3e565b92915050565b600060208284031215610a8057610a7f610944565b5b6000610a8e84828501610a55565b91505092915050565b600082825260208201905092915050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160008201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b6000610b04602683610a97565b9150610b0f82610aa8565b604082019050919050565b60006020820190508181036000830152610b3381610af7565b9050919050565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572600082015250565b6000610b70602083610a97565b9150610b7b82610b3a565b602082019050919050565b60006020820190508181036000830152610b9f81610b63565b9050919050565b7f63616e6e6f74207265766f6b65206f776e20726f6c6500000000000000000000600082015250565b6000610bdc601683610a97565b9150610be782610ba6565b602082019050919050565b60006020820190508181036000830152610c0b81610bcf565b905091905056fe6080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea264697066735822122095e71fe7b8a7d8101f30ba68f5e4e09352023917522f32686f9c7d10ae36668964736f6c634300081a0033a26469706673582212207fea6cdd540b486d2b9b356a095126d1686420ce9b6521ab2875c7432d6d51f064736f6c634300081a0033",
}

// ExampleDeployerListABI is the input ABI used to generate the binding from.
// Deprecated: Use ExampleDeployerListMetaData.ABI instead.
var ExampleDeployerListABI = ExampleDeployerListMetaData.ABI

// ExampleDeployerListBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use ExampleDeployerListMetaData.Bin instead.
var ExampleDeployerListBin = ExampleDeployerListMetaData.Bin

// DeployExampleDeployerList deploys a new Ethereum contract, binding an instance of ExampleDeployerList to it.
func DeployExampleDeployerList(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ExampleDeployerList, error) {
	parsed, err := ExampleDeployerListMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(ExampleDeployerListBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ExampleDeployerList{ExampleDeployerListCaller: ExampleDeployerListCaller{contract: contract}, ExampleDeployerListTransactor: ExampleDeployerListTransactor{contract: contract}, ExampleDeployerListFilterer: ExampleDeployerListFilterer{contract: contract}}, nil
}

// ExampleDeployerList is an auto generated Go binding around an Ethereum contract.
type ExampleDeployerList struct {
	ExampleDeployerListCaller     // Read-only binding to the contract
	ExampleDeployerListTransactor // Write-only binding to the contract
	ExampleDeployerListFilterer   // Log filterer for contract events
}

// ExampleDeployerListCaller is an auto generated read-only Go binding around an Ethereum contract.
type ExampleDeployerListCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExampleDeployerListTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ExampleDeployerListTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExampleDeployerListFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ExampleDeployerListFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExampleDeployerListSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ExampleDeployerListSession struct {
	Contract     *ExampleDeployerList // Generic contract binding to set the session for
	CallOpts     bind.CallOpts        // Call options to use throughout this session
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// ExampleDeployerListCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ExampleDeployerListCallerSession struct {
	Contract *ExampleDeployerListCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts              // Call options to use throughout this session
}

// ExampleDeployerListTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ExampleDeployerListTransactorSession struct {
	Contract     *ExampleDeployerListTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts              // Transaction auth options to use throughout this session
}

// ExampleDeployerListRaw is an auto generated low-level Go binding around an Ethereum contract.
type ExampleDeployerListRaw struct {
	Contract *ExampleDeployerList // Generic contract binding to access the raw methods on
}

// ExampleDeployerListCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ExampleDeployerListCallerRaw struct {
	Contract *ExampleDeployerListCaller // Generic read-only contract binding to access the raw methods on
}

// ExampleDeployerListTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ExampleDeployerListTransactorRaw struct {
	Contract *ExampleDeployerListTransactor // Generic write-only contract binding to access the raw methods on
}

// NewExampleDeployerList creates a new instance of ExampleDeployerList, bound to a specific deployed contract.
func NewExampleDeployerList(address common.Address, backend bind.ContractBackend) (*ExampleDeployerList, error) {
	contract, err := bindExampleDeployerList(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ExampleDeployerList{ExampleDeployerListCaller: ExampleDeployerListCaller{contract: contract}, ExampleDeployerListTransactor: ExampleDeployerListTransactor{contract: contract}, ExampleDeployerListFilterer: ExampleDeployerListFilterer{contract: contract}}, nil
}

// NewExampleDeployerListCaller creates a new read-only instance of ExampleDeployerList, bound to a specific deployed contract.
func NewExampleDeployerListCaller(address common.Address, caller bind.ContractCaller) (*ExampleDeployerListCaller, error) {
	contract, err := bindExampleDeployerList(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ExampleDeployerListCaller{contract: contract}, nil
}

// NewExampleDeployerListTransactor creates a new write-only instance of ExampleDeployerList, bound to a specific deployed contract.
func NewExampleDeployerListTransactor(address common.Address, transactor bind.ContractTransactor) (*ExampleDeployerListTransactor, error) {
	contract, err := bindExampleDeployerList(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ExampleDeployerListTransactor{contract: contract}, nil
}

// NewExampleDeployerListFilterer creates a new log filterer instance of ExampleDeployerList, bound to a specific deployed contract.
func NewExampleDeployerListFilterer(address common.Address, filterer bind.ContractFilterer) (*ExampleDeployerListFilterer, error) {
	contract, err := bindExampleDeployerList(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ExampleDeployerListFilterer{contract: contract}, nil
}

// bindExampleDeployerList binds a generic wrapper to an already deployed contract.
func bindExampleDeployerList(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ExampleDeployerListMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ExampleDeployerList *ExampleDeployerListRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ExampleDeployerList.Contract.ExampleDeployerListCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ExampleDeployerList *ExampleDeployerListRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleDeployerList.Contract.ExampleDeployerListTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ExampleDeployerList *ExampleDeployerListRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ExampleDeployerList.Contract.ExampleDeployerListTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ExampleDeployerList *ExampleDeployerListCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ExampleDeployerList.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ExampleDeployerList *ExampleDeployerListTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleDeployerList.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ExampleDeployerList *ExampleDeployerListTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ExampleDeployerList.Contract.contract.Transact(opts, method, params...)
}

// IsAdmin is a free data retrieval call binding the contract method 0x24d7806c.
//
// Solidity: function isAdmin(address addr) view returns(bool)
func (_ExampleDeployerList *ExampleDeployerListCaller) IsAdmin(opts *bind.CallOpts, addr common.Address) (bool, error) {
	var out []interface{}
	err := _ExampleDeployerList.contract.Call(opts, &out, "isAdmin", addr)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsAdmin is a free data retrieval call binding the contract method 0x24d7806c.
//
// Solidity: function isAdmin(address addr) view returns(bool)
func (_ExampleDeployerList *ExampleDeployerListSession) IsAdmin(addr common.Address) (bool, error) {
	return _ExampleDeployerList.Contract.IsAdmin(&_ExampleDeployerList.CallOpts, addr)
}

// IsAdmin is a free data retrieval call binding the contract method 0x24d7806c.
//
// Solidity: function isAdmin(address addr) view returns(bool)
func (_ExampleDeployerList *ExampleDeployerListCallerSession) IsAdmin(addr common.Address) (bool, error) {
	return _ExampleDeployerList.Contract.IsAdmin(&_ExampleDeployerList.CallOpts, addr)
}

// IsEnabled is a free data retrieval call binding the contract method 0x9015d371.
//
// Solidity: function isEnabled(address addr) view returns(bool)
func (_ExampleDeployerList *ExampleDeployerListCaller) IsEnabled(opts *bind.CallOpts, addr common.Address) (bool, error) {
	var out []interface{}
	err := _ExampleDeployerList.contract.Call(opts, &out, "isEnabled", addr)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsEnabled is a free data retrieval call binding the contract method 0x9015d371.
//
// Solidity: function isEnabled(address addr) view returns(bool)
func (_ExampleDeployerList *ExampleDeployerListSession) IsEnabled(addr common.Address) (bool, error) {
	return _ExampleDeployerList.Contract.IsEnabled(&_ExampleDeployerList.CallOpts, addr)
}

// IsEnabled is a free data retrieval call binding the contract method 0x9015d371.
//
// Solidity: function isEnabled(address addr) view returns(bool)
func (_ExampleDeployerList *ExampleDeployerListCallerSession) IsEnabled(addr common.Address) (bool, error) {
	return _ExampleDeployerList.Contract.IsEnabled(&_ExampleDeployerList.CallOpts, addr)
}

// IsManager is a free data retrieval call binding the contract method 0xf3ae2415.
//
// Solidity: function isManager(address addr) view returns(bool)
func (_ExampleDeployerList *ExampleDeployerListCaller) IsManager(opts *bind.CallOpts, addr common.Address) (bool, error) {
	var out []interface{}
	err := _ExampleDeployerList.contract.Call(opts, &out, "isManager", addr)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsManager is a free data retrieval call binding the contract method 0xf3ae2415.
//
// Solidity: function isManager(address addr) view returns(bool)
func (_ExampleDeployerList *ExampleDeployerListSession) IsManager(addr common.Address) (bool, error) {
	return _ExampleDeployerList.Contract.IsManager(&_ExampleDeployerList.CallOpts, addr)
}

// IsManager is a free data retrieval call binding the contract method 0xf3ae2415.
//
// Solidity: function isManager(address addr) view returns(bool)
func (_ExampleDeployerList *ExampleDeployerListCallerSession) IsManager(addr common.Address) (bool, error) {
	return _ExampleDeployerList.Contract.IsManager(&_ExampleDeployerList.CallOpts, addr)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ExampleDeployerList *ExampleDeployerListCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ExampleDeployerList.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ExampleDeployerList *ExampleDeployerListSession) Owner() (common.Address, error) {
	return _ExampleDeployerList.Contract.Owner(&_ExampleDeployerList.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ExampleDeployerList *ExampleDeployerListCallerSession) Owner() (common.Address, error) {
	return _ExampleDeployerList.Contract.Owner(&_ExampleDeployerList.CallOpts)
}

// DeployContract is a paid mutator transaction binding the contract method 0x6cd5c39b.
//
// Solidity: function deployContract() returns()
func (_ExampleDeployerList *ExampleDeployerListTransactor) DeployContract(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleDeployerList.contract.Transact(opts, "deployContract")
}

// DeployContract is a paid mutator transaction binding the contract method 0x6cd5c39b.
//
// Solidity: function deployContract() returns()
func (_ExampleDeployerList *ExampleDeployerListSession) DeployContract() (*types.Transaction, error) {
	return _ExampleDeployerList.Contract.DeployContract(&_ExampleDeployerList.TransactOpts)
}

// DeployContract is a paid mutator transaction binding the contract method 0x6cd5c39b.
//
// Solidity: function deployContract() returns()
func (_ExampleDeployerList *ExampleDeployerListTransactorSession) DeployContract() (*types.Transaction, error) {
	return _ExampleDeployerList.Contract.DeployContract(&_ExampleDeployerList.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_ExampleDeployerList *ExampleDeployerListTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleDeployerList.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_ExampleDeployerList *ExampleDeployerListSession) RenounceOwnership() (*types.Transaction, error) {
	return _ExampleDeployerList.Contract.RenounceOwnership(&_ExampleDeployerList.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_ExampleDeployerList *ExampleDeployerListTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _ExampleDeployerList.Contract.RenounceOwnership(&_ExampleDeployerList.TransactOpts)
}

// Revoke is a paid mutator transaction binding the contract method 0x74a8f103.
//
// Solidity: function revoke(address addr) returns()
func (_ExampleDeployerList *ExampleDeployerListTransactor) Revoke(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _ExampleDeployerList.contract.Transact(opts, "revoke", addr)
}

// Revoke is a paid mutator transaction binding the contract method 0x74a8f103.
//
// Solidity: function revoke(address addr) returns()
func (_ExampleDeployerList *ExampleDeployerListSession) Revoke(addr common.Address) (*types.Transaction, error) {
	return _ExampleDeployerList.Contract.Revoke(&_ExampleDeployerList.TransactOpts, addr)
}

// Revoke is a paid mutator transaction binding the contract method 0x74a8f103.
//
// Solidity: function revoke(address addr) returns()
func (_ExampleDeployerList *ExampleDeployerListTransactorSession) Revoke(addr common.Address) (*types.Transaction, error) {
	return _ExampleDeployerList.Contract.Revoke(&_ExampleDeployerList.TransactOpts, addr)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_ExampleDeployerList *ExampleDeployerListTransactor) SetAdmin(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _ExampleDeployerList.contract.Transact(opts, "setAdmin", addr)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_ExampleDeployerList *ExampleDeployerListSession) SetAdmin(addr common.Address) (*types.Transaction, error) {
	return _ExampleDeployerList.Contract.SetAdmin(&_ExampleDeployerList.TransactOpts, addr)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_ExampleDeployerList *ExampleDeployerListTransactorSession) SetAdmin(addr common.Address) (*types.Transaction, error) {
	return _ExampleDeployerList.Contract.SetAdmin(&_ExampleDeployerList.TransactOpts, addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_ExampleDeployerList *ExampleDeployerListTransactor) SetEnabled(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _ExampleDeployerList.contract.Transact(opts, "setEnabled", addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_ExampleDeployerList *ExampleDeployerListSession) SetEnabled(addr common.Address) (*types.Transaction, error) {
	return _ExampleDeployerList.Contract.SetEnabled(&_ExampleDeployerList.TransactOpts, addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_ExampleDeployerList *ExampleDeployerListTransactorSession) SetEnabled(addr common.Address) (*types.Transaction, error) {
	return _ExampleDeployerList.Contract.SetEnabled(&_ExampleDeployerList.TransactOpts, addr)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_ExampleDeployerList *ExampleDeployerListTransactor) SetManager(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _ExampleDeployerList.contract.Transact(opts, "setManager", addr)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_ExampleDeployerList *ExampleDeployerListSession) SetManager(addr common.Address) (*types.Transaction, error) {
	return _ExampleDeployerList.Contract.SetManager(&_ExampleDeployerList.TransactOpts, addr)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_ExampleDeployerList *ExampleDeployerListTransactorSession) SetManager(addr common.Address) (*types.Transaction, error) {
	return _ExampleDeployerList.Contract.SetManager(&_ExampleDeployerList.TransactOpts, addr)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_ExampleDeployerList *ExampleDeployerListTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _ExampleDeployerList.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_ExampleDeployerList *ExampleDeployerListSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _ExampleDeployerList.Contract.TransferOwnership(&_ExampleDeployerList.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_ExampleDeployerList *ExampleDeployerListTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _ExampleDeployerList.Contract.TransferOwnership(&_ExampleDeployerList.TransactOpts, newOwner)
}

// ExampleDeployerListOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the ExampleDeployerList contract.
type ExampleDeployerListOwnershipTransferredIterator struct {
	Event *ExampleDeployerListOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleDeployerListOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleDeployerListOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleDeployerListOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleDeployerListOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleDeployerListOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleDeployerListOwnershipTransferred represents a OwnershipTransferred event raised by the ExampleDeployerList contract.
type ExampleDeployerListOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_ExampleDeployerList *ExampleDeployerListFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*ExampleDeployerListOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _ExampleDeployerList.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &ExampleDeployerListOwnershipTransferredIterator{contract: _ExampleDeployerList.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_ExampleDeployerList *ExampleDeployerListFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *ExampleDeployerListOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _ExampleDeployerList.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleDeployerListOwnershipTransferred)
				if err := _ExampleDeployerList.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_ExampleDeployerList *ExampleDeployerListFilterer) ParseOwnershipTransferred(log types.Log) (*ExampleDeployerListOwnershipTransferred, error) {
	event := new(ExampleDeployerListOwnershipTransferred)
	if err := _ExampleDeployerList.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleDeployerListTestMetaData contains all meta data concerning the ExampleDeployerListTest contract.
var ExampleDeployerListTestMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"log_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"log_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"log_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"name\":\"log_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"val\",\"type\":\"address\"}],\"name\":\"log_named_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"val\",\"type\":\"bytes\"}],\"name\":\"log_named_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"val\",\"type\":\"bytes32\"}],\"name\":\"log_named_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"}],\"name\":\"log_named_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"val\",\"type\":\"string\"}],\"name\":\"log_named_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"log_named_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"log_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"logs\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"IS_TEST\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"failed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_addDeployerThroughContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_adminAddContractAsAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_adminCanRevokeDeployer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_deployerCanDeploy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_newAddressHasNoRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_noRoleCannotDeploy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_noRoleIsNotAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_ownerIsAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_verifySenderIsAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x608060405260016000806101000a81548160ff021916908315150217905550730200000000000000000000000000000000000000600060026101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550348015607e57600080fd5b50612f7d8061008e6000396000f3fe608060405234801561001057600080fd5b50600436106100b45760003560e01c80634c37cc2e116100715780634c37cc2e146100f5578063712268f1146100ff578063ba414fa614610109578063f26c562c14610127578063fa7626d414610131578063ffc46bc21461014f576100b4565b80630a9254e4146100b9578063143cf812146100c35780631d44d2da146100cd57806328002804146100d75780632999b249146100e157806333cb47db146100eb575b600080fd5b6100c1610159565b005b6100cb610265565b005b6100d56103d9565b005b6100df610542565b005b6100e96105ea565b005b6100f3610952565b005b6100fd610a22565b005b610107610dea565b005b610111611285565b60405161011e9190611b7a565b60405180910390f35b61012f611422565b005b610139611597565b6040516101469190611b7a565b60405180910390f35b6101576115a8565b005b60405161016590611b52565b604051809103906000f080158015610181573d6000803e3d6000fd5b50600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638c6bfb3b730fa8ea536be85f32724d57a37758761b864161236040518263ffffffff1660e01b81526004016102319190611bd6565b600060405180830381600087803b15801561024b57600080fd5b505af115801561025f573d6000803e3d6000fd5b50505050565b6000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050610332600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1836040518263ffffffff1660e01b81526004016102ea9190611bd6565b602060405180830381865afa158015610307573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061032b9190611c2c565b600061184f565b6103d6600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166324d7806c306040518263ffffffff1660e01b81526004016103909190611bd6565b602060405180830381865afa1580156103ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103d19190611c85565b61186f565b50565b61047f600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1326040518263ffffffff1660e01b81526004016104379190611bd6565b602060405180830381865afa158015610454573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104789190611c2c565b600061184f565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16636cd5c39b6040518163ffffffff1660e01b8152600401600060405180830381600087803b1580156104e957600080fd5b505af19250505080156104fa575060015b156105405761053f60006040518060400160405280601a81526020017f6465706c6f79436f6e74726163742073686f756c64206661696c0000000000008152506118b5565b5b565b6105e8600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1336040518263ffffffff1660e01b81526004016105a09190611bd6565b602060405180830381865afa1580156105bd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105e19190611c2c565b600261184f565b565b60006040516105f890611b52565b604051809103906000f080158015610614573d6000803e3d6000fd5b5090506000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905060008290506106e9600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b81526004016106a19190611bd6565b602060405180830381865afa1580156106be573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106e29190611c2c565b600061184f565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663704b6c02836040518263ffffffff1660e01b81526004016107449190611bd6565b600060405180830381600087803b15801561075e57600080fd5b505af1158015610772573d6000803e3d6000fd5b5050505061081c600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b81526004016107d49190611bd6565b602060405180830381865afa1580156107f1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108159190611c2c565b600261184f565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043826040518263ffffffff1660e01b81526004016108779190611bd6565b600060405180830381600087803b15801561089157600080fd5b505af11580156108a5573d6000803e3d6000fd5b5050505061094d600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16639015d371836040518263ffffffff1660e01b81526004016109079190611bd6565b602060405180830381865afa158015610924573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109489190611c85565b61186f565b505050565b6000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050610a1f600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1836040518263ffffffff1660e01b81526004016109d79190611bd6565b602060405180830381865afa1580156109f4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a189190611c2c565b600061184f565b50565b6000604051610a3090611b52565b604051809103906000f080158015610a4c573d6000803e3d6000fd5b5090506000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690506000829050610b21600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b8152600401610ad99190611bd6565b602060405180830381865afa158015610af6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b1a9190611c2c565b600061184f565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663704b6c02836040518263ffffffff1660e01b8152600401610b7c9190611bd6565b600060405180830381600087803b158015610b9657600080fd5b505af1158015610baa573d6000803e3d6000fd5b50505050610c54600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b8152600401610c0c9190611bd6565b602060405180830381865afa158015610c29573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c4d9190611c2c565b600261184f565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043826040518263ffffffff1660e01b8152600401610caf9190611bd6565b600060405180830381600087803b158015610cc957600080fd5b505af1158015610cdd573d6000803e3d6000fd5b50505050610d85600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16639015d371836040518263ffffffff1660e01b8152600401610d3f9190611bd6565b602060405180830381865afa158015610d5c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d809190611c85565b61186f565b8273ffffffffffffffffffffffffffffffffffffffff16636cd5c39b6040518163ffffffff1660e01b8152600401600060405180830381600087803b158015610dcd57600080fd5b505af1158015610de1573d6000803e3d6000fd5b50505050505050565b6000604051610df890611b52565b604051809103906000f080158015610e14573d6000803e3d6000fd5b5090506000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690506000829050610ee9600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b8152600401610ea19190611bd6565b602060405180830381865afa158015610ebe573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ee29190611c2c565b600061184f565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663704b6c02836040518263ffffffff1660e01b8152600401610f449190611bd6565b600060405180830381600087803b158015610f5e57600080fd5b505af1158015610f72573d6000803e3d6000fd5b5050505061101c600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b8152600401610fd49190611bd6565b602060405180830381865afa158015610ff1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110159190611c2c565b600261184f565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043826040518263ffffffff1660e01b81526004016110779190611bd6565b600060405180830381600087803b15801561109157600080fd5b505af11580156110a5573d6000803e3d6000fd5b5050505061114d600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16639015d371836040518263ffffffff1660e01b81526004016111079190611bd6565b602060405180830381865afa158015611124573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111489190611c85565b61186f565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166374a8f103826040518263ffffffff1660e01b81526004016111a89190611bd6565b600060405180830381600087803b1580156111c257600080fd5b505af11580156111d6573d6000803e3d6000fd5b50505050611280600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1836040518263ffffffff1660e01b81526004016112389190611bd6565b602060405180830381865afa158015611255573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112799190611c2c565b600061184f565b505050565b60008060019054906101000a900460ff16156112b257600060019054906101000a900460ff16905061141f565b60006112bc6118ff565b1561141a5760007f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d60001c60601b60601c73ffffffffffffffffffffffffffffffffffffffff167f667f9d70ca411d70ead50d8d5c22070dafc36ad75f3dcf5e7237b22ade9aecc47f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d60001c60601b60601c7f6661696c65640000000000000000000000000000000000000000000000000000604051602001611380929190611ccb565b6040516020818303038152906040526040516020016113a0929190611db2565b6040516020818303038152906040526040516113bc9190611dda565b6000604051808303816000865af19150503d80600081146113f9576040519150601f19603f3d011682016040523d82523d6000602084013e6113fe565b606091505b50915050808060200190518101906114169190611c85565b9150505b809150505b90565b6000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690506114ef600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1836040518263ffffffff1660e01b81526004016114a79190611bd6565b602060405180830381865afa1580156114c4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114e89190611c2c565b600061184f565b611594600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166324d7806c836040518263ffffffff1660e01b815260040161154d9190611bd6565b602060405180830381865afa15801561156a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061158e9190611c85565b1561186f565b50565b60008054906101000a900460ff1681565b6000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050611675600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1836040518263ffffffff1660e01b815260040161162d9190611bd6565b602060405180830381865afa15801561164a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061166e9190611c2c565b600061184f565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663704b6c02826040518263ffffffff1660e01b81526004016116d09190611bd6565b600060405180830381600087803b1580156116ea57600080fd5b505af11580156116fe573d6000803e3d6000fd5b505050506117a8600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1836040518263ffffffff1660e01b81526004016117609190611bd6565b602060405180830381865afa15801561177d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117a19190611c2c565b600261184f565b61184c600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166324d7806c836040518263ffffffff1660e01b81526004016118069190611bd6565b602060405180830381865afa158015611823573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118479190611c85565b61186f565b50565b61186b8282600381111561186657611865611df1565b5b611928565b5050565b806118b2577f41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f506040516118a190611e7d565b60405180910390a16118b16119df565b5b50565b816118fb577f280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583816040516118e99190611f3e565b60405180910390a16118fa8261186f565b5b5050565b60008060009050737109709ecfa91a80626ff3989d68f67f5b1dd12d3b90506000811191505090565b8082146119db577f41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f5060405161195c90611fe5565b60405180910390a17fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8826040516119939190612060565b60405180910390a17fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8816040516119ca91906120da565b60405180910390a16119da6119df565b5b5050565b6119e76118ff565b15611b355760007f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d60001c60601b60601c73ffffffffffffffffffffffffffffffffffffffff167f70ca10bbd0dbfd9020a9f4b13402c16cb120705e0d1c0aeab10fa353ae586fc47f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d60001c60601b60601c7f6661696c65640000000000000000000000000000000000000000000000000000600160001b604051602001611ab193929190612108565b604051602081830303815290604052604051602001611ad1929190611db2565b604051602081830303815290604052604051611aed9190611dda565b6000604051808303816000865af19150503d8060008114611b2a576040519150601f19603f3d011682016040523d82523d6000602084013e611b2f565b606091505b50509050505b6001600060016101000a81548160ff021916908315150217905550565b610e088061214083390190565b60008115159050919050565b611b7481611b5f565b82525050565b6000602082019050611b8f6000830184611b6b565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000611bc082611b95565b9050919050565b611bd081611bb5565b82525050565b6000602082019050611beb6000830184611bc7565b92915050565b600080fd5b6000819050919050565b611c0981611bf6565b8114611c1457600080fd5b50565b600081519050611c2681611c00565b92915050565b600060208284031215611c4257611c41611bf1565b5b6000611c5084828501611c17565b91505092915050565b611c6281611b5f565b8114611c6d57600080fd5b50565b600081519050611c7f81611c59565b92915050565b600060208284031215611c9b57611c9a611bf1565b5b6000611ca984828501611c70565b91505092915050565b6000819050919050565b611cc581611cb2565b82525050565b6000604082019050611ce06000830185611bc7565b611ced6020830184611cbc565b9392505050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b6000819050919050565b611d3b611d3682611cf4565b611d20565b82525050565b600081519050919050565b600081905092915050565b60005b83811015611d75578082015181840152602081019050611d5a565b60008484015250505050565b6000611d8c82611d41565b611d968185611d4c565b9350611da6818560208601611d57565b80840191505092915050565b6000611dbe8285611d2a565b600482019150611dce8284611d81565b91508190509392505050565b6000611de68284611d81565b915081905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b600082825260208201905092915050565b7f4572726f723a20417373657274696f6e204661696c6564000000000000000000600082015250565b6000611e67601783611e20565b9150611e7282611e31565b602082019050919050565b60006020820190508181036000830152611e9681611e5a565b9050919050565b7f4572726f72000000000000000000000000000000000000000000000000000000600082015250565b6000611ed3600583611e20565b9150611ede82611e9d565b602082019050919050565b600081519050919050565b6000601f19601f8301169050919050565b6000611f1082611ee9565b611f1a8185611e20565b9350611f2a818560208601611d57565b611f3381611ef4565b840191505092915050565b60006040820190508181036000830152611f5781611ec6565b90508181036020830152611f6b8184611f05565b905092915050565b7f4572726f723a2061203d3d2062206e6f7420736174697366696564205b75696e60008201527f745d000000000000000000000000000000000000000000000000000000000000602082015250565b6000611fcf602283611e20565b9150611fda82611f73565b604082019050919050565b60006020820190508181036000830152611ffe81611fc2565b9050919050565b7f2020202020204c65667400000000000000000000000000000000000000000000600082015250565b600061203b600a83611e20565b915061204682612005565b602082019050919050565b61205a81611bf6565b82525050565b600060408201905081810360008301526120798161202e565b90506120886020830184612051565b92915050565b7f2020202020526967687400000000000000000000000000000000000000000000600082015250565b60006120c4600a83611e20565b91506120cf8261208e565b602082019050919050565b600060408201905081810360008301526120f3816120b7565b90506121026020830184612051565b92915050565b600060608201905061211d6000830186611bc7565b61212a6020830185611cbc565b6121376040830184611cbc565b94935050505056fe608060405234801561001057600080fd5b5073020000000000000000000000000000000000000061004261003761008960201b60201c565b61009160201b60201c565b80600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050610155565b600033905090565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b610ca4806101646000396000f3fe608060405234801561001057600080fd5b50600436106100a95760003560e01c806374a8f1031161007157806374a8f1031461012a5780638da5cb5b146101465780639015d37114610164578063d0ebdbe714610194578063f2fde38b146101b0578063f3ae2415146101cc576100a9565b80630aaf7043146100ae57806324d7806c146100ca5780636cd5c39b146100fa578063704b6c0214610104578063715018a614610120575b600080fd5b6100c860048036038101906100c391906109a7565b6101fc565b005b6100e460048036038101906100df91906109a7565b610210565b6040516100f191906109ef565b60405180910390f35b6101026102bd565b005b61011e600480360381019061011991906109a7565b6102e9565b005b6101286102fd565b005b610144600480360381019061013f91906109a7565b610311565b005b61014e610325565b60405161015b9190610a19565b60405180910390f35b61017e600480360381019061017991906109a7565b61034e565b60405161018b91906109ef565b60405180910390f35b6101ae60048036038101906101a991906109a7565b6103fc565b005b6101ca60048036038101906101c591906109a7565b610410565b005b6101e660048036038101906101e191906109a7565b610493565b6040516101f391906109ef565b60405180910390f35b610204610540565b61020d816105be565b50565b600080600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b815260040161026e9190610a19565b602060405180830381865afa15801561028b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102af9190610a6a565b905060028114915050919050565b6040516102c990610938565b604051809103906000f0801580156102e5573d6000803e3d6000fd5b5050565b6102f1610540565b6102fa8161064e565b50565b610305610540565b61030f60006106de565b565b610319610540565b610322816107a2565b50565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b600080600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b81526004016103ac9190610a19565b602060405180830381865afa1580156103c9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103ed9190610a6a565b90506000811415915050919050565b610404610540565b61040d816108a0565b50565b610418610540565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603610487576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161047e90610b1a565b60405180910390fd5b610490816106de565b50565b600080600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b81526004016104f19190610a19565b602060405180830381865afa15801561050e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105329190610a6a565b905060038114915050919050565b610548610930565b73ffffffffffffffffffffffffffffffffffffffff16610566610325565b73ffffffffffffffffffffffffffffffffffffffff16146105bc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105b390610b86565b60405180910390fd5b565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043826040518263ffffffff1660e01b81526004016106199190610a19565b600060405180830381600087803b15801561063357600080fd5b505af1158015610647573d6000803e3d6000fd5b5050505050565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663704b6c02826040518263ffffffff1660e01b81526004016106a99190610a19565b600060405180830381600087803b1580156106c357600080fd5b505af11580156106d7573d6000803e3d6000fd5b5050505050565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b8073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1603610810576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161080790610bf2565b60405180910390fd5b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638c6bfb3b826040518263ffffffff1660e01b815260040161086b9190610a19565b600060405180830381600087803b15801561088557600080fd5b505af1158015610899573d6000803e3d6000fd5b5050505050565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d0ebdbe7826040518263ffffffff1660e01b81526004016108fb9190610a19565b600060405180830381600087803b15801561091557600080fd5b505af1158015610929573d6000803e3d6000fd5b5050505050565b600033905090565b605c80610c1383390190565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061097482610949565b9050919050565b61098481610969565b811461098f57600080fd5b50565b6000813590506109a18161097b565b92915050565b6000602082840312156109bd576109bc610944565b5b60006109cb84828501610992565b91505092915050565b60008115159050919050565b6109e9816109d4565b82525050565b6000602082019050610a0460008301846109e0565b92915050565b610a1381610969565b82525050565b6000602082019050610a2e6000830184610a0a565b92915050565b6000819050919050565b610a4781610a34565b8114610a5257600080fd5b50565b600081519050610a6481610a3e565b92915050565b600060208284031215610a8057610a7f610944565b5b6000610a8e84828501610a55565b91505092915050565b600082825260208201905092915050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160008201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b6000610b04602683610a97565b9150610b0f82610aa8565b604082019050919050565b60006020820190508181036000830152610b3381610af7565b9050919050565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572600082015250565b6000610b70602083610a97565b9150610b7b82610b3a565b602082019050919050565b60006020820190508181036000830152610b9f81610b63565b9050919050565b7f63616e6e6f74207265766f6b65206f776e20726f6c6500000000000000000000600082015250565b6000610bdc601683610a97565b9150610be782610ba6565b602082019050919050565b60006020820190508181036000830152610c0b81610bcf565b905091905056fe6080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea264697066735822122095e71fe7b8a7d8101f30ba68f5e4e09352023917522f32686f9c7d10ae36668964736f6c634300081a0033a26469706673582212207fea6cdd540b486d2b9b356a095126d1686420ce9b6521ab2875c7432d6d51f064736f6c634300081a0033a264697066735822122033cc03ac5c8fb738f1fb51c5ded3c261a6cea335a51ceabb3c2d244a6783a22f64736f6c634300081a0033",
}

// ExampleDeployerListTestABI is the input ABI used to generate the binding from.
// Deprecated: Use ExampleDeployerListTestMetaData.ABI instead.
var ExampleDeployerListTestABI = ExampleDeployerListTestMetaData.ABI

// ExampleDeployerListTestBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use ExampleDeployerListTestMetaData.Bin instead.
var ExampleDeployerListTestBin = ExampleDeployerListTestMetaData.Bin

// DeployExampleDeployerListTest deploys a new Ethereum contract, binding an instance of ExampleDeployerListTest to it.
func DeployExampleDeployerListTest(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ExampleDeployerListTest, error) {
	parsed, err := ExampleDeployerListTestMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(ExampleDeployerListTestBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ExampleDeployerListTest{ExampleDeployerListTestCaller: ExampleDeployerListTestCaller{contract: contract}, ExampleDeployerListTestTransactor: ExampleDeployerListTestTransactor{contract: contract}, ExampleDeployerListTestFilterer: ExampleDeployerListTestFilterer{contract: contract}}, nil
}

// ExampleDeployerListTest is an auto generated Go binding around an Ethereum contract.
type ExampleDeployerListTest struct {
	ExampleDeployerListTestCaller     // Read-only binding to the contract
	ExampleDeployerListTestTransactor // Write-only binding to the contract
	ExampleDeployerListTestFilterer   // Log filterer for contract events
}

// ExampleDeployerListTestCaller is an auto generated read-only Go binding around an Ethereum contract.
type ExampleDeployerListTestCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExampleDeployerListTestTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ExampleDeployerListTestTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExampleDeployerListTestFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ExampleDeployerListTestFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExampleDeployerListTestSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ExampleDeployerListTestSession struct {
	Contract     *ExampleDeployerListTest // Generic contract binding to set the session for
	CallOpts     bind.CallOpts            // Call options to use throughout this session
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// ExampleDeployerListTestCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ExampleDeployerListTestCallerSession struct {
	Contract *ExampleDeployerListTestCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts                  // Call options to use throughout this session
}

// ExampleDeployerListTestTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ExampleDeployerListTestTransactorSession struct {
	Contract     *ExampleDeployerListTestTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts                  // Transaction auth options to use throughout this session
}

// ExampleDeployerListTestRaw is an auto generated low-level Go binding around an Ethereum contract.
type ExampleDeployerListTestRaw struct {
	Contract *ExampleDeployerListTest // Generic contract binding to access the raw methods on
}

// ExampleDeployerListTestCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ExampleDeployerListTestCallerRaw struct {
	Contract *ExampleDeployerListTestCaller // Generic read-only contract binding to access the raw methods on
}

// ExampleDeployerListTestTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ExampleDeployerListTestTransactorRaw struct {
	Contract *ExampleDeployerListTestTransactor // Generic write-only contract binding to access the raw methods on
}

// NewExampleDeployerListTest creates a new instance of ExampleDeployerListTest, bound to a specific deployed contract.
func NewExampleDeployerListTest(address common.Address, backend bind.ContractBackend) (*ExampleDeployerListTest, error) {
	contract, err := bindExampleDeployerListTest(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ExampleDeployerListTest{ExampleDeployerListTestCaller: ExampleDeployerListTestCaller{contract: contract}, ExampleDeployerListTestTransactor: ExampleDeployerListTestTransactor{contract: contract}, ExampleDeployerListTestFilterer: ExampleDeployerListTestFilterer{contract: contract}}, nil
}

// NewExampleDeployerListTestCaller creates a new read-only instance of ExampleDeployerListTest, bound to a specific deployed contract.
func NewExampleDeployerListTestCaller(address common.Address, caller bind.ContractCaller) (*ExampleDeployerListTestCaller, error) {
	contract, err := bindExampleDeployerListTest(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ExampleDeployerListTestCaller{contract: contract}, nil
}

// NewExampleDeployerListTestTransactor creates a new write-only instance of ExampleDeployerListTest, bound to a specific deployed contract.
func NewExampleDeployerListTestTransactor(address common.Address, transactor bind.ContractTransactor) (*ExampleDeployerListTestTransactor, error) {
	contract, err := bindExampleDeployerListTest(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ExampleDeployerListTestTransactor{contract: contract}, nil
}

// NewExampleDeployerListTestFilterer creates a new log filterer instance of ExampleDeployerListTest, bound to a specific deployed contract.
func NewExampleDeployerListTestFilterer(address common.Address, filterer bind.ContractFilterer) (*ExampleDeployerListTestFilterer, error) {
	contract, err := bindExampleDeployerListTest(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ExampleDeployerListTestFilterer{contract: contract}, nil
}

// bindExampleDeployerListTest binds a generic wrapper to an already deployed contract.
func bindExampleDeployerListTest(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ExampleDeployerListTestMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ExampleDeployerListTest *ExampleDeployerListTestRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ExampleDeployerListTest.Contract.ExampleDeployerListTestCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ExampleDeployerListTest *ExampleDeployerListTestRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleDeployerListTest.Contract.ExampleDeployerListTestTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ExampleDeployerListTest *ExampleDeployerListTestRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ExampleDeployerListTest.Contract.ExampleDeployerListTestTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ExampleDeployerListTest *ExampleDeployerListTestCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ExampleDeployerListTest.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ExampleDeployerListTest *ExampleDeployerListTestTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleDeployerListTest.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ExampleDeployerListTest *ExampleDeployerListTestTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ExampleDeployerListTest.Contract.contract.Transact(opts, method, params...)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_ExampleDeployerListTest *ExampleDeployerListTestCaller) ISTEST(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _ExampleDeployerListTest.contract.Call(opts, &out, "IS_TEST")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_ExampleDeployerListTest *ExampleDeployerListTestSession) ISTEST() (bool, error) {
	return _ExampleDeployerListTest.Contract.ISTEST(&_ExampleDeployerListTest.CallOpts)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_ExampleDeployerListTest *ExampleDeployerListTestCallerSession) ISTEST() (bool, error) {
	return _ExampleDeployerListTest.Contract.ISTEST(&_ExampleDeployerListTest.CallOpts)
}

// Failed is a paid mutator transaction binding the contract method 0xba414fa6.
//
// Solidity: function failed() returns(bool)
func (_ExampleDeployerListTest *ExampleDeployerListTestTransactor) Failed(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleDeployerListTest.contract.Transact(opts, "failed")
}

// Failed is a paid mutator transaction binding the contract method 0xba414fa6.
//
// Solidity: function failed() returns(bool)
func (_ExampleDeployerListTest *ExampleDeployerListTestSession) Failed() (*types.Transaction, error) {
	return _ExampleDeployerListTest.Contract.Failed(&_ExampleDeployerListTest.TransactOpts)
}

// Failed is a paid mutator transaction binding the contract method 0xba414fa6.
//
// Solidity: function failed() returns(bool)
func (_ExampleDeployerListTest *ExampleDeployerListTestTransactorSession) Failed() (*types.Transaction, error) {
	return _ExampleDeployerListTest.Contract.Failed(&_ExampleDeployerListTest.TransactOpts)
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestTransactor) SetUp(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleDeployerListTest.contract.Transact(opts, "setUp")
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestSession) SetUp() (*types.Transaction, error) {
	return _ExampleDeployerListTest.Contract.SetUp(&_ExampleDeployerListTest.TransactOpts)
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestTransactorSession) SetUp() (*types.Transaction, error) {
	return _ExampleDeployerListTest.Contract.SetUp(&_ExampleDeployerListTest.TransactOpts)
}

// StepAddDeployerThroughContract is a paid mutator transaction binding the contract method 0x2999b249.
//
// Solidity: function step_addDeployerThroughContract() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestTransactor) StepAddDeployerThroughContract(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleDeployerListTest.contract.Transact(opts, "step_addDeployerThroughContract")
}

// StepAddDeployerThroughContract is a paid mutator transaction binding the contract method 0x2999b249.
//
// Solidity: function step_addDeployerThroughContract() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestSession) StepAddDeployerThroughContract() (*types.Transaction, error) {
	return _ExampleDeployerListTest.Contract.StepAddDeployerThroughContract(&_ExampleDeployerListTest.TransactOpts)
}

// StepAddDeployerThroughContract is a paid mutator transaction binding the contract method 0x2999b249.
//
// Solidity: function step_addDeployerThroughContract() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestTransactorSession) StepAddDeployerThroughContract() (*types.Transaction, error) {
	return _ExampleDeployerListTest.Contract.StepAddDeployerThroughContract(&_ExampleDeployerListTest.TransactOpts)
}

// StepAdminAddContractAsAdmin is a paid mutator transaction binding the contract method 0xffc46bc2.
//
// Solidity: function step_adminAddContractAsAdmin() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestTransactor) StepAdminAddContractAsAdmin(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleDeployerListTest.contract.Transact(opts, "step_adminAddContractAsAdmin")
}

// StepAdminAddContractAsAdmin is a paid mutator transaction binding the contract method 0xffc46bc2.
//
// Solidity: function step_adminAddContractAsAdmin() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestSession) StepAdminAddContractAsAdmin() (*types.Transaction, error) {
	return _ExampleDeployerListTest.Contract.StepAdminAddContractAsAdmin(&_ExampleDeployerListTest.TransactOpts)
}

// StepAdminAddContractAsAdmin is a paid mutator transaction binding the contract method 0xffc46bc2.
//
// Solidity: function step_adminAddContractAsAdmin() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestTransactorSession) StepAdminAddContractAsAdmin() (*types.Transaction, error) {
	return _ExampleDeployerListTest.Contract.StepAdminAddContractAsAdmin(&_ExampleDeployerListTest.TransactOpts)
}

// StepAdminCanRevokeDeployer is a paid mutator transaction binding the contract method 0x712268f1.
//
// Solidity: function step_adminCanRevokeDeployer() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestTransactor) StepAdminCanRevokeDeployer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleDeployerListTest.contract.Transact(opts, "step_adminCanRevokeDeployer")
}

// StepAdminCanRevokeDeployer is a paid mutator transaction binding the contract method 0x712268f1.
//
// Solidity: function step_adminCanRevokeDeployer() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestSession) StepAdminCanRevokeDeployer() (*types.Transaction, error) {
	return _ExampleDeployerListTest.Contract.StepAdminCanRevokeDeployer(&_ExampleDeployerListTest.TransactOpts)
}

// StepAdminCanRevokeDeployer is a paid mutator transaction binding the contract method 0x712268f1.
//
// Solidity: function step_adminCanRevokeDeployer() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestTransactorSession) StepAdminCanRevokeDeployer() (*types.Transaction, error) {
	return _ExampleDeployerListTest.Contract.StepAdminCanRevokeDeployer(&_ExampleDeployerListTest.TransactOpts)
}

// StepDeployerCanDeploy is a paid mutator transaction binding the contract method 0x4c37cc2e.
//
// Solidity: function step_deployerCanDeploy() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestTransactor) StepDeployerCanDeploy(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleDeployerListTest.contract.Transact(opts, "step_deployerCanDeploy")
}

// StepDeployerCanDeploy is a paid mutator transaction binding the contract method 0x4c37cc2e.
//
// Solidity: function step_deployerCanDeploy() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestSession) StepDeployerCanDeploy() (*types.Transaction, error) {
	return _ExampleDeployerListTest.Contract.StepDeployerCanDeploy(&_ExampleDeployerListTest.TransactOpts)
}

// StepDeployerCanDeploy is a paid mutator transaction binding the contract method 0x4c37cc2e.
//
// Solidity: function step_deployerCanDeploy() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestTransactorSession) StepDeployerCanDeploy() (*types.Transaction, error) {
	return _ExampleDeployerListTest.Contract.StepDeployerCanDeploy(&_ExampleDeployerListTest.TransactOpts)
}

// StepNewAddressHasNoRole is a paid mutator transaction binding the contract method 0x33cb47db.
//
// Solidity: function step_newAddressHasNoRole() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestTransactor) StepNewAddressHasNoRole(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleDeployerListTest.contract.Transact(opts, "step_newAddressHasNoRole")
}

// StepNewAddressHasNoRole is a paid mutator transaction binding the contract method 0x33cb47db.
//
// Solidity: function step_newAddressHasNoRole() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestSession) StepNewAddressHasNoRole() (*types.Transaction, error) {
	return _ExampleDeployerListTest.Contract.StepNewAddressHasNoRole(&_ExampleDeployerListTest.TransactOpts)
}

// StepNewAddressHasNoRole is a paid mutator transaction binding the contract method 0x33cb47db.
//
// Solidity: function step_newAddressHasNoRole() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestTransactorSession) StepNewAddressHasNoRole() (*types.Transaction, error) {
	return _ExampleDeployerListTest.Contract.StepNewAddressHasNoRole(&_ExampleDeployerListTest.TransactOpts)
}

// StepNoRoleCannotDeploy is a paid mutator transaction binding the contract method 0x1d44d2da.
//
// Solidity: function step_noRoleCannotDeploy() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestTransactor) StepNoRoleCannotDeploy(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleDeployerListTest.contract.Transact(opts, "step_noRoleCannotDeploy")
}

// StepNoRoleCannotDeploy is a paid mutator transaction binding the contract method 0x1d44d2da.
//
// Solidity: function step_noRoleCannotDeploy() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestSession) StepNoRoleCannotDeploy() (*types.Transaction, error) {
	return _ExampleDeployerListTest.Contract.StepNoRoleCannotDeploy(&_ExampleDeployerListTest.TransactOpts)
}

// StepNoRoleCannotDeploy is a paid mutator transaction binding the contract method 0x1d44d2da.
//
// Solidity: function step_noRoleCannotDeploy() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestTransactorSession) StepNoRoleCannotDeploy() (*types.Transaction, error) {
	return _ExampleDeployerListTest.Contract.StepNoRoleCannotDeploy(&_ExampleDeployerListTest.TransactOpts)
}

// StepNoRoleIsNotAdmin is a paid mutator transaction binding the contract method 0xf26c562c.
//
// Solidity: function step_noRoleIsNotAdmin() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestTransactor) StepNoRoleIsNotAdmin(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleDeployerListTest.contract.Transact(opts, "step_noRoleIsNotAdmin")
}

// StepNoRoleIsNotAdmin is a paid mutator transaction binding the contract method 0xf26c562c.
//
// Solidity: function step_noRoleIsNotAdmin() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestSession) StepNoRoleIsNotAdmin() (*types.Transaction, error) {
	return _ExampleDeployerListTest.Contract.StepNoRoleIsNotAdmin(&_ExampleDeployerListTest.TransactOpts)
}

// StepNoRoleIsNotAdmin is a paid mutator transaction binding the contract method 0xf26c562c.
//
// Solidity: function step_noRoleIsNotAdmin() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestTransactorSession) StepNoRoleIsNotAdmin() (*types.Transaction, error) {
	return _ExampleDeployerListTest.Contract.StepNoRoleIsNotAdmin(&_ExampleDeployerListTest.TransactOpts)
}

// StepOwnerIsAdmin is a paid mutator transaction binding the contract method 0x143cf812.
//
// Solidity: function step_ownerIsAdmin() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestTransactor) StepOwnerIsAdmin(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleDeployerListTest.contract.Transact(opts, "step_ownerIsAdmin")
}

// StepOwnerIsAdmin is a paid mutator transaction binding the contract method 0x143cf812.
//
// Solidity: function step_ownerIsAdmin() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestSession) StepOwnerIsAdmin() (*types.Transaction, error) {
	return _ExampleDeployerListTest.Contract.StepOwnerIsAdmin(&_ExampleDeployerListTest.TransactOpts)
}

// StepOwnerIsAdmin is a paid mutator transaction binding the contract method 0x143cf812.
//
// Solidity: function step_ownerIsAdmin() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestTransactorSession) StepOwnerIsAdmin() (*types.Transaction, error) {
	return _ExampleDeployerListTest.Contract.StepOwnerIsAdmin(&_ExampleDeployerListTest.TransactOpts)
}

// StepVerifySenderIsAdmin is a paid mutator transaction binding the contract method 0x28002804.
//
// Solidity: function step_verifySenderIsAdmin() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestTransactor) StepVerifySenderIsAdmin(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleDeployerListTest.contract.Transact(opts, "step_verifySenderIsAdmin")
}

// StepVerifySenderIsAdmin is a paid mutator transaction binding the contract method 0x28002804.
//
// Solidity: function step_verifySenderIsAdmin() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestSession) StepVerifySenderIsAdmin() (*types.Transaction, error) {
	return _ExampleDeployerListTest.Contract.StepVerifySenderIsAdmin(&_ExampleDeployerListTest.TransactOpts)
}

// StepVerifySenderIsAdmin is a paid mutator transaction binding the contract method 0x28002804.
//
// Solidity: function step_verifySenderIsAdmin() returns()
func (_ExampleDeployerListTest *ExampleDeployerListTestTransactorSession) StepVerifySenderIsAdmin() (*types.Transaction, error) {
	return _ExampleDeployerListTest.Contract.StepVerifySenderIsAdmin(&_ExampleDeployerListTest.TransactOpts)
}

// ExampleDeployerListTestLogIterator is returned from FilterLog and is used to iterate over the raw logs and unpacked data for Log events raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogIterator struct {
	Event *ExampleDeployerListTestLog // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleDeployerListTestLogIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleDeployerListTestLog)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleDeployerListTestLog)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleDeployerListTestLogIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleDeployerListTestLogIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleDeployerListTestLog represents a Log event raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLog struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLog is a free log retrieval operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) FilterLog(opts *bind.FilterOpts) (*ExampleDeployerListTestLogIterator, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.FilterLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return &ExampleDeployerListTestLogIterator{contract: _ExampleDeployerListTest.contract, event: "log", logs: logs, sub: sub}, nil
}

// WatchLog is a free log subscription operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) WatchLog(opts *bind.WatchOpts, sink chan<- *ExampleDeployerListTestLog) (event.Subscription, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.WatchLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleDeployerListTestLog)
				if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLog is a log parse operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) ParseLog(log types.Log) (*ExampleDeployerListTestLog, error) {
	event := new(ExampleDeployerListTestLog)
	if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleDeployerListTestLogAddressIterator is returned from FilterLogAddress and is used to iterate over the raw logs and unpacked data for LogAddress events raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogAddressIterator struct {
	Event *ExampleDeployerListTestLogAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleDeployerListTestLogAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleDeployerListTestLogAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleDeployerListTestLogAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleDeployerListTestLogAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleDeployerListTestLogAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleDeployerListTestLogAddress represents a LogAddress event raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogAddress struct {
	Arg0 common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogAddress is a free log retrieval operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) FilterLogAddress(opts *bind.FilterOpts) (*ExampleDeployerListTestLogAddressIterator, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.FilterLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return &ExampleDeployerListTestLogAddressIterator{contract: _ExampleDeployerListTest.contract, event: "log_address", logs: logs, sub: sub}, nil
}

// WatchLogAddress is a free log subscription operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) WatchLogAddress(opts *bind.WatchOpts, sink chan<- *ExampleDeployerListTestLogAddress) (event.Subscription, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.WatchLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleDeployerListTestLogAddress)
				if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogAddress is a log parse operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) ParseLogAddress(log types.Log) (*ExampleDeployerListTestLogAddress, error) {
	event := new(ExampleDeployerListTestLogAddress)
	if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_address", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleDeployerListTestLogBytesIterator is returned from FilterLogBytes and is used to iterate over the raw logs and unpacked data for LogBytes events raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogBytesIterator struct {
	Event *ExampleDeployerListTestLogBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleDeployerListTestLogBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleDeployerListTestLogBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleDeployerListTestLogBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleDeployerListTestLogBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleDeployerListTestLogBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleDeployerListTestLogBytes represents a LogBytes event raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogBytes struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes is a free log retrieval operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) FilterLogBytes(opts *bind.FilterOpts) (*ExampleDeployerListTestLogBytesIterator, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.FilterLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return &ExampleDeployerListTestLogBytesIterator{contract: _ExampleDeployerListTest.contract, event: "log_bytes", logs: logs, sub: sub}, nil
}

// WatchLogBytes is a free log subscription operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) WatchLogBytes(opts *bind.WatchOpts, sink chan<- *ExampleDeployerListTestLogBytes) (event.Subscription, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.WatchLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleDeployerListTestLogBytes)
				if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes is a log parse operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) ParseLogBytes(log types.Log) (*ExampleDeployerListTestLogBytes, error) {
	event := new(ExampleDeployerListTestLogBytes)
	if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleDeployerListTestLogBytes32Iterator is returned from FilterLogBytes32 and is used to iterate over the raw logs and unpacked data for LogBytes32 events raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogBytes32Iterator struct {
	Event *ExampleDeployerListTestLogBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleDeployerListTestLogBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleDeployerListTestLogBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleDeployerListTestLogBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleDeployerListTestLogBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleDeployerListTestLogBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleDeployerListTestLogBytes32 represents a LogBytes32 event raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogBytes32 struct {
	Arg0 [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes32 is a free log retrieval operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) FilterLogBytes32(opts *bind.FilterOpts) (*ExampleDeployerListTestLogBytes32Iterator, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.FilterLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return &ExampleDeployerListTestLogBytes32Iterator{contract: _ExampleDeployerListTest.contract, event: "log_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogBytes32 is a free log subscription operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) WatchLogBytes32(opts *bind.WatchOpts, sink chan<- *ExampleDeployerListTestLogBytes32) (event.Subscription, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.WatchLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleDeployerListTestLogBytes32)
				if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes32 is a log parse operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) ParseLogBytes32(log types.Log) (*ExampleDeployerListTestLogBytes32, error) {
	event := new(ExampleDeployerListTestLogBytes32)
	if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleDeployerListTestLogIntIterator is returned from FilterLogInt and is used to iterate over the raw logs and unpacked data for LogInt events raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogIntIterator struct {
	Event *ExampleDeployerListTestLogInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleDeployerListTestLogIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleDeployerListTestLogInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleDeployerListTestLogInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleDeployerListTestLogIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleDeployerListTestLogIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleDeployerListTestLogInt represents a LogInt event raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogInt struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogInt is a free log retrieval operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) FilterLogInt(opts *bind.FilterOpts) (*ExampleDeployerListTestLogIntIterator, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.FilterLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return &ExampleDeployerListTestLogIntIterator{contract: _ExampleDeployerListTest.contract, event: "log_int", logs: logs, sub: sub}, nil
}

// WatchLogInt is a free log subscription operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) WatchLogInt(opts *bind.WatchOpts, sink chan<- *ExampleDeployerListTestLogInt) (event.Subscription, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.WatchLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleDeployerListTestLogInt)
				if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogInt is a log parse operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) ParseLogInt(log types.Log) (*ExampleDeployerListTestLogInt, error) {
	event := new(ExampleDeployerListTestLogInt)
	if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_int", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleDeployerListTestLogNamedAddressIterator is returned from FilterLogNamedAddress and is used to iterate over the raw logs and unpacked data for LogNamedAddress events raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogNamedAddressIterator struct {
	Event *ExampleDeployerListTestLogNamedAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleDeployerListTestLogNamedAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleDeployerListTestLogNamedAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleDeployerListTestLogNamedAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleDeployerListTestLogNamedAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleDeployerListTestLogNamedAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleDeployerListTestLogNamedAddress represents a LogNamedAddress event raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogNamedAddress struct {
	Key string
	Val common.Address
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedAddress is a free log retrieval operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) FilterLogNamedAddress(opts *bind.FilterOpts) (*ExampleDeployerListTestLogNamedAddressIterator, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.FilterLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return &ExampleDeployerListTestLogNamedAddressIterator{contract: _ExampleDeployerListTest.contract, event: "log_named_address", logs: logs, sub: sub}, nil
}

// WatchLogNamedAddress is a free log subscription operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) WatchLogNamedAddress(opts *bind.WatchOpts, sink chan<- *ExampleDeployerListTestLogNamedAddress) (event.Subscription, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.WatchLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleDeployerListTestLogNamedAddress)
				if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedAddress is a log parse operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) ParseLogNamedAddress(log types.Log) (*ExampleDeployerListTestLogNamedAddress, error) {
	event := new(ExampleDeployerListTestLogNamedAddress)
	if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleDeployerListTestLogNamedBytesIterator is returned from FilterLogNamedBytes and is used to iterate over the raw logs and unpacked data for LogNamedBytes events raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogNamedBytesIterator struct {
	Event *ExampleDeployerListTestLogNamedBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleDeployerListTestLogNamedBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleDeployerListTestLogNamedBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleDeployerListTestLogNamedBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleDeployerListTestLogNamedBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleDeployerListTestLogNamedBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleDeployerListTestLogNamedBytes represents a LogNamedBytes event raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogNamedBytes struct {
	Key string
	Val []byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes is a free log retrieval operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) FilterLogNamedBytes(opts *bind.FilterOpts) (*ExampleDeployerListTestLogNamedBytesIterator, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.FilterLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return &ExampleDeployerListTestLogNamedBytesIterator{contract: _ExampleDeployerListTest.contract, event: "log_named_bytes", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes is a free log subscription operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) WatchLogNamedBytes(opts *bind.WatchOpts, sink chan<- *ExampleDeployerListTestLogNamedBytes) (event.Subscription, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.WatchLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleDeployerListTestLogNamedBytes)
				if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes is a log parse operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) ParseLogNamedBytes(log types.Log) (*ExampleDeployerListTestLogNamedBytes, error) {
	event := new(ExampleDeployerListTestLogNamedBytes)
	if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleDeployerListTestLogNamedBytes32Iterator is returned from FilterLogNamedBytes32 and is used to iterate over the raw logs and unpacked data for LogNamedBytes32 events raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogNamedBytes32Iterator struct {
	Event *ExampleDeployerListTestLogNamedBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleDeployerListTestLogNamedBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleDeployerListTestLogNamedBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleDeployerListTestLogNamedBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleDeployerListTestLogNamedBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleDeployerListTestLogNamedBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleDeployerListTestLogNamedBytes32 represents a LogNamedBytes32 event raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogNamedBytes32 struct {
	Key string
	Val [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes32 is a free log retrieval operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) FilterLogNamedBytes32(opts *bind.FilterOpts) (*ExampleDeployerListTestLogNamedBytes32Iterator, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.FilterLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return &ExampleDeployerListTestLogNamedBytes32Iterator{contract: _ExampleDeployerListTest.contract, event: "log_named_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes32 is a free log subscription operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) WatchLogNamedBytes32(opts *bind.WatchOpts, sink chan<- *ExampleDeployerListTestLogNamedBytes32) (event.Subscription, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.WatchLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleDeployerListTestLogNamedBytes32)
				if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes32 is a log parse operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) ParseLogNamedBytes32(log types.Log) (*ExampleDeployerListTestLogNamedBytes32, error) {
	event := new(ExampleDeployerListTestLogNamedBytes32)
	if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleDeployerListTestLogNamedDecimalIntIterator is returned from FilterLogNamedDecimalInt and is used to iterate over the raw logs and unpacked data for LogNamedDecimalInt events raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogNamedDecimalIntIterator struct {
	Event *ExampleDeployerListTestLogNamedDecimalInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleDeployerListTestLogNamedDecimalIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleDeployerListTestLogNamedDecimalInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleDeployerListTestLogNamedDecimalInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleDeployerListTestLogNamedDecimalIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleDeployerListTestLogNamedDecimalIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleDeployerListTestLogNamedDecimalInt represents a LogNamedDecimalInt event raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogNamedDecimalInt struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalInt is a free log retrieval operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) FilterLogNamedDecimalInt(opts *bind.FilterOpts) (*ExampleDeployerListTestLogNamedDecimalIntIterator, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.FilterLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return &ExampleDeployerListTestLogNamedDecimalIntIterator{contract: _ExampleDeployerListTest.contract, event: "log_named_decimal_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalInt is a free log subscription operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) WatchLogNamedDecimalInt(opts *bind.WatchOpts, sink chan<- *ExampleDeployerListTestLogNamedDecimalInt) (event.Subscription, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.WatchLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleDeployerListTestLogNamedDecimalInt)
				if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalInt is a log parse operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) ParseLogNamedDecimalInt(log types.Log) (*ExampleDeployerListTestLogNamedDecimalInt, error) {
	event := new(ExampleDeployerListTestLogNamedDecimalInt)
	if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleDeployerListTestLogNamedDecimalUintIterator is returned from FilterLogNamedDecimalUint and is used to iterate over the raw logs and unpacked data for LogNamedDecimalUint events raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogNamedDecimalUintIterator struct {
	Event *ExampleDeployerListTestLogNamedDecimalUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleDeployerListTestLogNamedDecimalUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleDeployerListTestLogNamedDecimalUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleDeployerListTestLogNamedDecimalUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleDeployerListTestLogNamedDecimalUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleDeployerListTestLogNamedDecimalUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleDeployerListTestLogNamedDecimalUint represents a LogNamedDecimalUint event raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogNamedDecimalUint struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalUint is a free log retrieval operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) FilterLogNamedDecimalUint(opts *bind.FilterOpts) (*ExampleDeployerListTestLogNamedDecimalUintIterator, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.FilterLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return &ExampleDeployerListTestLogNamedDecimalUintIterator{contract: _ExampleDeployerListTest.contract, event: "log_named_decimal_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalUint is a free log subscription operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) WatchLogNamedDecimalUint(opts *bind.WatchOpts, sink chan<- *ExampleDeployerListTestLogNamedDecimalUint) (event.Subscription, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.WatchLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleDeployerListTestLogNamedDecimalUint)
				if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalUint is a log parse operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) ParseLogNamedDecimalUint(log types.Log) (*ExampleDeployerListTestLogNamedDecimalUint, error) {
	event := new(ExampleDeployerListTestLogNamedDecimalUint)
	if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleDeployerListTestLogNamedIntIterator is returned from FilterLogNamedInt and is used to iterate over the raw logs and unpacked data for LogNamedInt events raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogNamedIntIterator struct {
	Event *ExampleDeployerListTestLogNamedInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleDeployerListTestLogNamedIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleDeployerListTestLogNamedInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleDeployerListTestLogNamedInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleDeployerListTestLogNamedIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleDeployerListTestLogNamedIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleDeployerListTestLogNamedInt represents a LogNamedInt event raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogNamedInt struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedInt is a free log retrieval operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) FilterLogNamedInt(opts *bind.FilterOpts) (*ExampleDeployerListTestLogNamedIntIterator, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.FilterLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return &ExampleDeployerListTestLogNamedIntIterator{contract: _ExampleDeployerListTest.contract, event: "log_named_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedInt is a free log subscription operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) WatchLogNamedInt(opts *bind.WatchOpts, sink chan<- *ExampleDeployerListTestLogNamedInt) (event.Subscription, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.WatchLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleDeployerListTestLogNamedInt)
				if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedInt is a log parse operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) ParseLogNamedInt(log types.Log) (*ExampleDeployerListTestLogNamedInt, error) {
	event := new(ExampleDeployerListTestLogNamedInt)
	if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleDeployerListTestLogNamedStringIterator is returned from FilterLogNamedString and is used to iterate over the raw logs and unpacked data for LogNamedString events raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogNamedStringIterator struct {
	Event *ExampleDeployerListTestLogNamedString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleDeployerListTestLogNamedStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleDeployerListTestLogNamedString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleDeployerListTestLogNamedString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleDeployerListTestLogNamedStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleDeployerListTestLogNamedStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleDeployerListTestLogNamedString represents a LogNamedString event raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogNamedString struct {
	Key string
	Val string
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedString is a free log retrieval operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) FilterLogNamedString(opts *bind.FilterOpts) (*ExampleDeployerListTestLogNamedStringIterator, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.FilterLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return &ExampleDeployerListTestLogNamedStringIterator{contract: _ExampleDeployerListTest.contract, event: "log_named_string", logs: logs, sub: sub}, nil
}

// WatchLogNamedString is a free log subscription operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) WatchLogNamedString(opts *bind.WatchOpts, sink chan<- *ExampleDeployerListTestLogNamedString) (event.Subscription, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.WatchLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleDeployerListTestLogNamedString)
				if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedString is a log parse operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) ParseLogNamedString(log types.Log) (*ExampleDeployerListTestLogNamedString, error) {
	event := new(ExampleDeployerListTestLogNamedString)
	if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleDeployerListTestLogNamedUintIterator is returned from FilterLogNamedUint and is used to iterate over the raw logs and unpacked data for LogNamedUint events raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogNamedUintIterator struct {
	Event *ExampleDeployerListTestLogNamedUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleDeployerListTestLogNamedUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleDeployerListTestLogNamedUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleDeployerListTestLogNamedUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleDeployerListTestLogNamedUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleDeployerListTestLogNamedUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleDeployerListTestLogNamedUint represents a LogNamedUint event raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogNamedUint struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedUint is a free log retrieval operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) FilterLogNamedUint(opts *bind.FilterOpts) (*ExampleDeployerListTestLogNamedUintIterator, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.FilterLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return &ExampleDeployerListTestLogNamedUintIterator{contract: _ExampleDeployerListTest.contract, event: "log_named_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedUint is a free log subscription operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) WatchLogNamedUint(opts *bind.WatchOpts, sink chan<- *ExampleDeployerListTestLogNamedUint) (event.Subscription, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.WatchLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleDeployerListTestLogNamedUint)
				if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedUint is a log parse operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) ParseLogNamedUint(log types.Log) (*ExampleDeployerListTestLogNamedUint, error) {
	event := new(ExampleDeployerListTestLogNamedUint)
	if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleDeployerListTestLogStringIterator is returned from FilterLogString and is used to iterate over the raw logs and unpacked data for LogString events raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogStringIterator struct {
	Event *ExampleDeployerListTestLogString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleDeployerListTestLogStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleDeployerListTestLogString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleDeployerListTestLogString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleDeployerListTestLogStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleDeployerListTestLogStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleDeployerListTestLogString represents a LogString event raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogString struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogString is a free log retrieval operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) FilterLogString(opts *bind.FilterOpts) (*ExampleDeployerListTestLogStringIterator, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.FilterLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return &ExampleDeployerListTestLogStringIterator{contract: _ExampleDeployerListTest.contract, event: "log_string", logs: logs, sub: sub}, nil
}

// WatchLogString is a free log subscription operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) WatchLogString(opts *bind.WatchOpts, sink chan<- *ExampleDeployerListTestLogString) (event.Subscription, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.WatchLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleDeployerListTestLogString)
				if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogString is a log parse operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) ParseLogString(log types.Log) (*ExampleDeployerListTestLogString, error) {
	event := new(ExampleDeployerListTestLogString)
	if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_string", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleDeployerListTestLogUintIterator is returned from FilterLogUint and is used to iterate over the raw logs and unpacked data for LogUint events raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogUintIterator struct {
	Event *ExampleDeployerListTestLogUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleDeployerListTestLogUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleDeployerListTestLogUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleDeployerListTestLogUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleDeployerListTestLogUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleDeployerListTestLogUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleDeployerListTestLogUint represents a LogUint event raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogUint struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogUint is a free log retrieval operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) FilterLogUint(opts *bind.FilterOpts) (*ExampleDeployerListTestLogUintIterator, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.FilterLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return &ExampleDeployerListTestLogUintIterator{contract: _ExampleDeployerListTest.contract, event: "log_uint", logs: logs, sub: sub}, nil
}

// WatchLogUint is a free log subscription operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) WatchLogUint(opts *bind.WatchOpts, sink chan<- *ExampleDeployerListTestLogUint) (event.Subscription, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.WatchLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleDeployerListTestLogUint)
				if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogUint is a log parse operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) ParseLogUint(log types.Log) (*ExampleDeployerListTestLogUint, error) {
	event := new(ExampleDeployerListTestLogUint)
	if err := _ExampleDeployerListTest.contract.UnpackLog(event, "log_uint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleDeployerListTestLogsIterator is returned from FilterLogs and is used to iterate over the raw logs and unpacked data for Logs events raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogsIterator struct {
	Event *ExampleDeployerListTestLogs // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleDeployerListTestLogsIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleDeployerListTestLogs)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleDeployerListTestLogs)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleDeployerListTestLogsIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleDeployerListTestLogsIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleDeployerListTestLogs represents a Logs event raised by the ExampleDeployerListTest contract.
type ExampleDeployerListTestLogs struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogs is a free log retrieval operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) FilterLogs(opts *bind.FilterOpts) (*ExampleDeployerListTestLogsIterator, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.FilterLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return &ExampleDeployerListTestLogsIterator{contract: _ExampleDeployerListTest.contract, event: "logs", logs: logs, sub: sub}, nil
}

// WatchLogs is a free log subscription operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) WatchLogs(opts *bind.WatchOpts, sink chan<- *ExampleDeployerListTestLogs) (event.Subscription, error) {

	logs, sub, err := _ExampleDeployerListTest.contract.WatchLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleDeployerListTestLogs)
				if err := _ExampleDeployerListTest.contract.UnpackLog(event, "logs", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogs is a log parse operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_ExampleDeployerListTest *ExampleDeployerListTestFilterer) ParseLogs(log types.Log) (*ExampleDeployerListTestLogs, error) {
	event := new(ExampleDeployerListTestLogs)
	if err := _ExampleDeployerListTest.contract.UnpackLog(event, "logs", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleFeeManagerMetaData contains all meta data concerning the ExampleFeeManager contract.
var ExampleFeeManagerMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"enableCChainFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetBlockRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBaseFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseFeeChangeDenominator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBlockGasCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBlockGasCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockGasCostStep\",\"type\":\"uint256\"}],\"internalType\":\"structFeeConfig\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"enableCustomFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableWAGMIFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentFeeConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetBlockRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBaseFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseFeeChangeDenominator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBlockGasCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBlockGasCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockGasCostStep\",\"type\":\"uint256\"}],\"internalType\":\"structFeeConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeConfigLastChangedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"revoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x6080604052730200000000000000000000000000000000000003600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555034801561006557600080fd5b5073020000000000000000000000000000000000000361009761008c6100de60201b60201c565b6100e660201b60201c565b80600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550506101aa565b600033905090565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b6115c4806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100f55760003560e01c806374a8f103116100975780639e05549a116100665780639e05549a14610224578063d0ebdbe714610242578063f2fde38b1461025e578063f3ae24151461027a576100f5565b806374a8f103146101b057806385c1b4ac146101cc5780638da5cb5b146101d65780639015d371146101f4576100f5565b806352965cfc116100d357806352965cfc146101645780636f0edc9d14610180578063704b6c021461018a578063715018a6146101a6576100f5565b80630aaf7043146100fa57806324d7806c1461011657806341f5772814610146575b600080fd5b610114600480360381019061010f9190610eee565b6102aa565b005b610130600480360381019061012b9190610eee565b6102be565b60405161013d9190610f36565b60405180910390f35b61014e61036b565b60405161015b919061100c565b60405180910390f35b61017e600480360381019061017991906111af565b61045c565b005b610188610562565b005b6101a4600480360381019061019f9190610eee565b61065c565b005b6101ae610670565b005b6101ca60048036038101906101c59190610eee565b610684565b005b6101d4610698565b005b6101de610791565b6040516101eb91906111ec565b60405180910390f35b61020e60048036038101906102099190610eee565b6107ba565b60405161021b9190610f36565b60405180910390f35b61022c610868565b6040516102399190611216565b60405180910390f35b61025c60048036038101906102579190610eee565b610900565b005b61027860048036038101906102739190610eee565b610914565b005b610294600480360381019061028f9190610eee565b610997565b6040516102a19190610f36565b60405180910390f35b6102b2610a44565b6102bb81610ac2565b50565b600080600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b815260040161031c91906111ec565b602060405180830381865afa158015610339573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061035d9190611246565b905060028114915050919050565b610373610e3c565b61037b610e3c565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16635fbbc0d26040518163ffffffff1660e01b815260040161010060405180830381865afa1580156103e9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061040d9190611273565b88600001896020018a6040018b6060018c6080018d60a0018e60c0018f60e001888152508881525088815250888152508881525088815250888152508881525050505050505050508091505090565b610465336107ba565b6104a4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161049b90611386565b60405180910390fd5b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638f10b586826000015183602001518460400151856060015186608001518760a001518860c001518960e001516040518963ffffffff1660e01b815260040161052d9897969594939291906113a6565b600060405180830381600087803b15801561054757600080fd5b505af115801561055b573d6000803e3d6000fd5b5050505050565b61056b336107ba565b6105aa576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105a190611386565b60405180910390fd5b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638f10b5866301312d006002633b9aca006305f5e10060306000629896806207a1206040518963ffffffff1660e01b81526004016106289897969594939291906113a6565b600060405180830381600087803b15801561064257600080fd5b505af1158015610656573d6000803e3d6000fd5b50505050565b610664610a44565b61066d81610b52565b50565b610678610a44565b6106826000610be2565b565b61068c610a44565b61069581610ca6565b50565b6106a1336107ba565b6106e0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106d790611386565b60405180910390fd5b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638f10b586627a120060026405d21dba0062e4e1c060246000620f4240620186a06040518963ffffffff1660e01b815260040161075d9897969594939291906113a6565b600060405180830381600087803b15801561077757600080fd5b505af115801561078b573d6000803e3d6000fd5b50505050565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b600080600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b815260040161081891906111ec565b602060405180830381865afa158015610835573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108599190611246565b90506000811415915050919050565b6000600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16639e05549a6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156108d7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108fb9190611246565b905090565b610908610a44565b61091181610da4565b50565b61091c610a44565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff160361098b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161098290611496565b60405180910390fd5b61099481610be2565b50565b600080600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b81526004016109f591906111ec565b602060405180830381865afa158015610a12573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a369190611246565b905060038114915050919050565b610a4c610e34565b73ffffffffffffffffffffffffffffffffffffffff16610a6a610791565b73ffffffffffffffffffffffffffffffffffffffff1614610ac0576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ab790611502565b60405180910390fd5b565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043826040518263ffffffff1660e01b8152600401610b1d91906111ec565b600060405180830381600087803b158015610b3757600080fd5b505af1158015610b4b573d6000803e3d6000fd5b5050505050565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663704b6c02826040518263ffffffff1660e01b8152600401610bad91906111ec565b600060405180830381600087803b158015610bc757600080fd5b505af1158015610bdb573d6000803e3d6000fd5b5050505050565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b8073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1603610d14576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610d0b9061156e565b60405180910390fd5b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638c6bfb3b826040518263ffffffff1660e01b8152600401610d6f91906111ec565b600060405180830381600087803b158015610d8957600080fd5b505af1158015610d9d573d6000803e3d6000fd5b5050505050565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d0ebdbe7826040518263ffffffff1660e01b8152600401610dff91906111ec565b600060405180830381600087803b158015610e1957600080fd5b505af1158015610e2d573d6000803e3d6000fd5b5050505050565b600033905090565b60405180610100016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6000604051905090565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610ebb82610e90565b9050919050565b610ecb81610eb0565b8114610ed657600080fd5b50565b600081359050610ee881610ec2565b92915050565b600060208284031215610f0457610f03610e8b565b5b6000610f1284828501610ed9565b91505092915050565b60008115159050919050565b610f3081610f1b565b82525050565b6000602082019050610f4b6000830184610f27565b92915050565b6000819050919050565b610f6481610f51565b82525050565b61010082016000820151610f816000850182610f5b565b506020820151610f946020850182610f5b565b506040820151610fa76040850182610f5b565b506060820151610fba6060850182610f5b565b506080820151610fcd6080850182610f5b565b5060a0820151610fe060a0850182610f5b565b5060c0820151610ff360c0850182610f5b565b5060e082015161100660e0850182610f5b565b50505050565b6000610100820190506110226000830184610f6a565b92915050565b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6110768261102d565b810181811067ffffffffffffffff821117156110955761109461103e565b5b80604052505050565b60006110a8610e81565b90506110b4828261106d565b919050565b6110c281610f51565b81146110cd57600080fd5b50565b6000813590506110df816110b9565b92915050565b600061010082840312156110fc576110fb611028565b5b61110761010061109e565b90506000611117848285016110d0565b600083015250602061112b848285016110d0565b602083015250604061113f848285016110d0565b6040830152506060611153848285016110d0565b6060830152506080611167848285016110d0565b60808301525060a061117b848285016110d0565b60a08301525060c061118f848285016110d0565b60c08301525060e06111a3848285016110d0565b60e08301525092915050565b600061010082840312156111c6576111c5610e8b565b5b60006111d4848285016110e5565b91505092915050565b6111e681610eb0565b82525050565b600060208201905061120160008301846111dd565b92915050565b61121081610f51565b82525050565b600060208201905061122b6000830184611207565b92915050565b600081519050611240816110b9565b92915050565b60006020828403121561125c5761125b610e8b565b5b600061126a84828501611231565b91505092915050565b600080600080600080600080610100898b03121561129457611293610e8b565b5b60006112a28b828c01611231565b98505060206112b38b828c01611231565b97505060406112c48b828c01611231565b96505060606112d58b828c01611231565b95505060806112e68b828c01611231565b94505060a06112f78b828c01611231565b93505060c06113088b828c01611231565b92505060e06113198b828c01611231565b9150509295985092959890939650565b600082825260208201905092915050565b7f6e6f7420656e61626c6564000000000000000000000000000000000000000000600082015250565b6000611370600b83611329565b915061137b8261133a565b602082019050919050565b6000602082019050818103600083015261139f81611363565b9050919050565b6000610100820190506113bc600083018b611207565b6113c9602083018a611207565b6113d66040830189611207565b6113e36060830188611207565b6113f06080830187611207565b6113fd60a0830186611207565b61140a60c0830185611207565b61141760e0830184611207565b9998505050505050505050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160008201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b6000611480602683611329565b915061148b82611424565b604082019050919050565b600060208201905081810360008301526114af81611473565b9050919050565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572600082015250565b60006114ec602083611329565b91506114f7826114b6565b602082019050919050565b6000602082019050818103600083015261151b816114df565b9050919050565b7f63616e6e6f74207265766f6b65206f776e20726f6c6500000000000000000000600082015250565b6000611558601683611329565b915061156382611522565b602082019050919050565b600060208201905081810360008301526115878161154b565b905091905056fea2646970667358221220fe9811b144e1be1ad9892305ffac1890a4c810b3282d472939ec7a2a4741a1f764736f6c634300081a0033",
}

// ExampleFeeManagerABI is the input ABI used to generate the binding from.
// Deprecated: Use ExampleFeeManagerMetaData.ABI instead.
var ExampleFeeManagerABI = ExampleFeeManagerMetaData.ABI

// ExampleFeeManagerBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use ExampleFeeManagerMetaData.Bin instead.
var ExampleFeeManagerBin = ExampleFeeManagerMetaData.Bin

// DeployExampleFeeManager deploys a new Ethereum contract, binding an instance of ExampleFeeManager to it.
func DeployExampleFeeManager(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ExampleFeeManager, error) {
	parsed, err := ExampleFeeManagerMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(ExampleFeeManagerBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ExampleFeeManager{ExampleFeeManagerCaller: ExampleFeeManagerCaller{contract: contract}, ExampleFeeManagerTransactor: ExampleFeeManagerTransactor{contract: contract}, ExampleFeeManagerFilterer: ExampleFeeManagerFilterer{contract: contract}}, nil
}

// ExampleFeeManager is an auto generated Go binding around an Ethereum contract.
type ExampleFeeManager struct {
	ExampleFeeManagerCaller     // Read-only binding to the contract
	ExampleFeeManagerTransactor // Write-only binding to the contract
	ExampleFeeManagerFilterer   // Log filterer for contract events
}

// ExampleFeeManagerCaller is an auto generated read-only Go binding around an Ethereum contract.
type ExampleFeeManagerCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExampleFeeManagerTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ExampleFeeManagerTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExampleFeeManagerFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ExampleFeeManagerFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExampleFeeManagerSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ExampleFeeManagerSession struct {
	Contract     *ExampleFeeManager // Generic contract binding to set the session for
	CallOpts     bind.CallOpts      // Call options to use throughout this session
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// ExampleFeeManagerCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ExampleFeeManagerCallerSession struct {
	Contract *ExampleFeeManagerCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts            // Call options to use throughout this session
}

// ExampleFeeManagerTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ExampleFeeManagerTransactorSession struct {
	Contract     *ExampleFeeManagerTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts            // Transaction auth options to use throughout this session
}

// ExampleFeeManagerRaw is an auto generated low-level Go binding around an Ethereum contract.
type ExampleFeeManagerRaw struct {
	Contract *ExampleFeeManager // Generic contract binding to access the raw methods on
}

// ExampleFeeManagerCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ExampleFeeManagerCallerRaw struct {
	Contract *ExampleFeeManagerCaller // Generic read-only contract binding to access the raw methods on
}

// ExampleFeeManagerTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ExampleFeeManagerTransactorRaw struct {
	Contract *ExampleFeeManagerTransactor // Generic write-only contract binding to access the raw methods on
}

// NewExampleFeeManager creates a new instance of ExampleFeeManager, bound to a specific deployed contract.
func NewExampleFeeManager(address common.Address, backend bind.ContractBackend) (*ExampleFeeManager, error) {
	contract, err := bindExampleFeeManager(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ExampleFeeManager{ExampleFeeManagerCaller: ExampleFeeManagerCaller{contract: contract}, ExampleFeeManagerTransactor: ExampleFeeManagerTransactor{contract: contract}, ExampleFeeManagerFilterer: ExampleFeeManagerFilterer{contract: contract}}, nil
}

// NewExampleFeeManagerCaller creates a new read-only instance of ExampleFeeManager, bound to a specific deployed contract.
func NewExampleFeeManagerCaller(address common.Address, caller bind.ContractCaller) (*ExampleFeeManagerCaller, error) {
	contract, err := bindExampleFeeManager(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ExampleFeeManagerCaller{contract: contract}, nil
}

// NewExampleFeeManagerTransactor creates a new write-only instance of ExampleFeeManager, bound to a specific deployed contract.
func NewExampleFeeManagerTransactor(address common.Address, transactor bind.ContractTransactor) (*ExampleFeeManagerTransactor, error) {
	contract, err := bindExampleFeeManager(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ExampleFeeManagerTransactor{contract: contract}, nil
}

// NewExampleFeeManagerFilterer creates a new log filterer instance of ExampleFeeManager, bound to a specific deployed contract.
func NewExampleFeeManagerFilterer(address common.Address, filterer bind.ContractFilterer) (*ExampleFeeManagerFilterer, error) {
	contract, err := bindExampleFeeManager(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ExampleFeeManagerFilterer{contract: contract}, nil
}

// bindExampleFeeManager binds a generic wrapper to an already deployed contract.
func bindExampleFeeManager(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ExampleFeeManagerMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ExampleFeeManager *ExampleFeeManagerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ExampleFeeManager.Contract.ExampleFeeManagerCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ExampleFeeManager *ExampleFeeManagerRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleFeeManager.Contract.ExampleFeeManagerTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ExampleFeeManager *ExampleFeeManagerRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ExampleFeeManager.Contract.ExampleFeeManagerTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ExampleFeeManager *ExampleFeeManagerCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ExampleFeeManager.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ExampleFeeManager *ExampleFeeManagerTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleFeeManager.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ExampleFeeManager *ExampleFeeManagerTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ExampleFeeManager.Contract.contract.Transact(opts, method, params...)
}

// GetCurrentFeeConfig is a free data retrieval call binding the contract method 0x41f57728.
//
// Solidity: function getCurrentFeeConfig() view returns((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))
func (_ExampleFeeManager *ExampleFeeManagerCaller) GetCurrentFeeConfig(opts *bind.CallOpts) (FeeConfig, error) {
	var out []interface{}
	err := _ExampleFeeManager.contract.Call(opts, &out, "getCurrentFeeConfig")

	if err != nil {
		return *new(FeeConfig), err
	}

	out0 := *abi.ConvertType(out[0], new(FeeConfig)).(*FeeConfig)

	return out0, err

}

// GetCurrentFeeConfig is a free data retrieval call binding the contract method 0x41f57728.
//
// Solidity: function getCurrentFeeConfig() view returns((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))
func (_ExampleFeeManager *ExampleFeeManagerSession) GetCurrentFeeConfig() (FeeConfig, error) {
	return _ExampleFeeManager.Contract.GetCurrentFeeConfig(&_ExampleFeeManager.CallOpts)
}

// GetCurrentFeeConfig is a free data retrieval call binding the contract method 0x41f57728.
//
// Solidity: function getCurrentFeeConfig() view returns((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))
func (_ExampleFeeManager *ExampleFeeManagerCallerSession) GetCurrentFeeConfig() (FeeConfig, error) {
	return _ExampleFeeManager.Contract.GetCurrentFeeConfig(&_ExampleFeeManager.CallOpts)
}

// GetFeeConfigLastChangedAt is a free data retrieval call binding the contract method 0x9e05549a.
//
// Solidity: function getFeeConfigLastChangedAt() view returns(uint256)
func (_ExampleFeeManager *ExampleFeeManagerCaller) GetFeeConfigLastChangedAt(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ExampleFeeManager.contract.Call(opts, &out, "getFeeConfigLastChangedAt")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetFeeConfigLastChangedAt is a free data retrieval call binding the contract method 0x9e05549a.
//
// Solidity: function getFeeConfigLastChangedAt() view returns(uint256)
func (_ExampleFeeManager *ExampleFeeManagerSession) GetFeeConfigLastChangedAt() (*big.Int, error) {
	return _ExampleFeeManager.Contract.GetFeeConfigLastChangedAt(&_ExampleFeeManager.CallOpts)
}

// GetFeeConfigLastChangedAt is a free data retrieval call binding the contract method 0x9e05549a.
//
// Solidity: function getFeeConfigLastChangedAt() view returns(uint256)
func (_ExampleFeeManager *ExampleFeeManagerCallerSession) GetFeeConfigLastChangedAt() (*big.Int, error) {
	return _ExampleFeeManager.Contract.GetFeeConfigLastChangedAt(&_ExampleFeeManager.CallOpts)
}

// IsAdmin is a free data retrieval call binding the contract method 0x24d7806c.
//
// Solidity: function isAdmin(address addr) view returns(bool)
func (_ExampleFeeManager *ExampleFeeManagerCaller) IsAdmin(opts *bind.CallOpts, addr common.Address) (bool, error) {
	var out []interface{}
	err := _ExampleFeeManager.contract.Call(opts, &out, "isAdmin", addr)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsAdmin is a free data retrieval call binding the contract method 0x24d7806c.
//
// Solidity: function isAdmin(address addr) view returns(bool)
func (_ExampleFeeManager *ExampleFeeManagerSession) IsAdmin(addr common.Address) (bool, error) {
	return _ExampleFeeManager.Contract.IsAdmin(&_ExampleFeeManager.CallOpts, addr)
}

// IsAdmin is a free data retrieval call binding the contract method 0x24d7806c.
//
// Solidity: function isAdmin(address addr) view returns(bool)
func (_ExampleFeeManager *ExampleFeeManagerCallerSession) IsAdmin(addr common.Address) (bool, error) {
	return _ExampleFeeManager.Contract.IsAdmin(&_ExampleFeeManager.CallOpts, addr)
}

// IsEnabled is a free data retrieval call binding the contract method 0x9015d371.
//
// Solidity: function isEnabled(address addr) view returns(bool)
func (_ExampleFeeManager *ExampleFeeManagerCaller) IsEnabled(opts *bind.CallOpts, addr common.Address) (bool, error) {
	var out []interface{}
	err := _ExampleFeeManager.contract.Call(opts, &out, "isEnabled", addr)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsEnabled is a free data retrieval call binding the contract method 0x9015d371.
//
// Solidity: function isEnabled(address addr) view returns(bool)
func (_ExampleFeeManager *ExampleFeeManagerSession) IsEnabled(addr common.Address) (bool, error) {
	return _ExampleFeeManager.Contract.IsEnabled(&_ExampleFeeManager.CallOpts, addr)
}

// IsEnabled is a free data retrieval call binding the contract method 0x9015d371.
//
// Solidity: function isEnabled(address addr) view returns(bool)
func (_ExampleFeeManager *ExampleFeeManagerCallerSession) IsEnabled(addr common.Address) (bool, error) {
	return _ExampleFeeManager.Contract.IsEnabled(&_ExampleFeeManager.CallOpts, addr)
}

// IsManager is a free data retrieval call binding the contract method 0xf3ae2415.
//
// Solidity: function isManager(address addr) view returns(bool)
func (_ExampleFeeManager *ExampleFeeManagerCaller) IsManager(opts *bind.CallOpts, addr common.Address) (bool, error) {
	var out []interface{}
	err := _ExampleFeeManager.contract.Call(opts, &out, "isManager", addr)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsManager is a free data retrieval call binding the contract method 0xf3ae2415.
//
// Solidity: function isManager(address addr) view returns(bool)
func (_ExampleFeeManager *ExampleFeeManagerSession) IsManager(addr common.Address) (bool, error) {
	return _ExampleFeeManager.Contract.IsManager(&_ExampleFeeManager.CallOpts, addr)
}

// IsManager is a free data retrieval call binding the contract method 0xf3ae2415.
//
// Solidity: function isManager(address addr) view returns(bool)
func (_ExampleFeeManager *ExampleFeeManagerCallerSession) IsManager(addr common.Address) (bool, error) {
	return _ExampleFeeManager.Contract.IsManager(&_ExampleFeeManager.CallOpts, addr)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ExampleFeeManager *ExampleFeeManagerCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ExampleFeeManager.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ExampleFeeManager *ExampleFeeManagerSession) Owner() (common.Address, error) {
	return _ExampleFeeManager.Contract.Owner(&_ExampleFeeManager.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ExampleFeeManager *ExampleFeeManagerCallerSession) Owner() (common.Address, error) {
	return _ExampleFeeManager.Contract.Owner(&_ExampleFeeManager.CallOpts)
}

// EnableCChainFees is a paid mutator transaction binding the contract method 0x85c1b4ac.
//
// Solidity: function enableCChainFees() returns()
func (_ExampleFeeManager *ExampleFeeManagerTransactor) EnableCChainFees(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleFeeManager.contract.Transact(opts, "enableCChainFees")
}

// EnableCChainFees is a paid mutator transaction binding the contract method 0x85c1b4ac.
//
// Solidity: function enableCChainFees() returns()
func (_ExampleFeeManager *ExampleFeeManagerSession) EnableCChainFees() (*types.Transaction, error) {
	return _ExampleFeeManager.Contract.EnableCChainFees(&_ExampleFeeManager.TransactOpts)
}

// EnableCChainFees is a paid mutator transaction binding the contract method 0x85c1b4ac.
//
// Solidity: function enableCChainFees() returns()
func (_ExampleFeeManager *ExampleFeeManagerTransactorSession) EnableCChainFees() (*types.Transaction, error) {
	return _ExampleFeeManager.Contract.EnableCChainFees(&_ExampleFeeManager.TransactOpts)
}

// EnableCustomFees is a paid mutator transaction binding the contract method 0x52965cfc.
//
// Solidity: function enableCustomFees((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256) config) returns()
func (_ExampleFeeManager *ExampleFeeManagerTransactor) EnableCustomFees(opts *bind.TransactOpts, config FeeConfig) (*types.Transaction, error) {
	return _ExampleFeeManager.contract.Transact(opts, "enableCustomFees", config)
}

// EnableCustomFees is a paid mutator transaction binding the contract method 0x52965cfc.
//
// Solidity: function enableCustomFees((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256) config) returns()
func (_ExampleFeeManager *ExampleFeeManagerSession) EnableCustomFees(config FeeConfig) (*types.Transaction, error) {
	return _ExampleFeeManager.Contract.EnableCustomFees(&_ExampleFeeManager.TransactOpts, config)
}

// EnableCustomFees is a paid mutator transaction binding the contract method 0x52965cfc.
//
// Solidity: function enableCustomFees((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256) config) returns()
func (_ExampleFeeManager *ExampleFeeManagerTransactorSession) EnableCustomFees(config FeeConfig) (*types.Transaction, error) {
	return _ExampleFeeManager.Contract.EnableCustomFees(&_ExampleFeeManager.TransactOpts, config)
}

// EnableWAGMIFees is a paid mutator transaction binding the contract method 0x6f0edc9d.
//
// Solidity: function enableWAGMIFees() returns()
func (_ExampleFeeManager *ExampleFeeManagerTransactor) EnableWAGMIFees(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleFeeManager.contract.Transact(opts, "enableWAGMIFees")
}

// EnableWAGMIFees is a paid mutator transaction binding the contract method 0x6f0edc9d.
//
// Solidity: function enableWAGMIFees() returns()
func (_ExampleFeeManager *ExampleFeeManagerSession) EnableWAGMIFees() (*types.Transaction, error) {
	return _ExampleFeeManager.Contract.EnableWAGMIFees(&_ExampleFeeManager.TransactOpts)
}

// EnableWAGMIFees is a paid mutator transaction binding the contract method 0x6f0edc9d.
//
// Solidity: function enableWAGMIFees() returns()
func (_ExampleFeeManager *ExampleFeeManagerTransactorSession) EnableWAGMIFees() (*types.Transaction, error) {
	return _ExampleFeeManager.Contract.EnableWAGMIFees(&_ExampleFeeManager.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_ExampleFeeManager *ExampleFeeManagerTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleFeeManager.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_ExampleFeeManager *ExampleFeeManagerSession) RenounceOwnership() (*types.Transaction, error) {
	return _ExampleFeeManager.Contract.RenounceOwnership(&_ExampleFeeManager.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_ExampleFeeManager *ExampleFeeManagerTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _ExampleFeeManager.Contract.RenounceOwnership(&_ExampleFeeManager.TransactOpts)
}

// Revoke is a paid mutator transaction binding the contract method 0x74a8f103.
//
// Solidity: function revoke(address addr) returns()
func (_ExampleFeeManager *ExampleFeeManagerTransactor) Revoke(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _ExampleFeeManager.contract.Transact(opts, "revoke", addr)
}

// Revoke is a paid mutator transaction binding the contract method 0x74a8f103.
//
// Solidity: function revoke(address addr) returns()
func (_ExampleFeeManager *ExampleFeeManagerSession) Revoke(addr common.Address) (*types.Transaction, error) {
	return _ExampleFeeManager.Contract.Revoke(&_ExampleFeeManager.TransactOpts, addr)
}

// Revoke is a paid mutator transaction binding the contract method 0x74a8f103.
//
// Solidity: function revoke(address addr) returns()
func (_ExampleFeeManager *ExampleFeeManagerTransactorSession) Revoke(addr common.Address) (*types.Transaction, error) {
	return _ExampleFeeManager.Contract.Revoke(&_ExampleFeeManager.TransactOpts, addr)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_ExampleFeeManager *ExampleFeeManagerTransactor) SetAdmin(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _ExampleFeeManager.contract.Transact(opts, "setAdmin", addr)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_ExampleFeeManager *ExampleFeeManagerSession) SetAdmin(addr common.Address) (*types.Transaction, error) {
	return _ExampleFeeManager.Contract.SetAdmin(&_ExampleFeeManager.TransactOpts, addr)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_ExampleFeeManager *ExampleFeeManagerTransactorSession) SetAdmin(addr common.Address) (*types.Transaction, error) {
	return _ExampleFeeManager.Contract.SetAdmin(&_ExampleFeeManager.TransactOpts, addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_ExampleFeeManager *ExampleFeeManagerTransactor) SetEnabled(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _ExampleFeeManager.contract.Transact(opts, "setEnabled", addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_ExampleFeeManager *ExampleFeeManagerSession) SetEnabled(addr common.Address) (*types.Transaction, error) {
	return _ExampleFeeManager.Contract.SetEnabled(&_ExampleFeeManager.TransactOpts, addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_ExampleFeeManager *ExampleFeeManagerTransactorSession) SetEnabled(addr common.Address) (*types.Transaction, error) {
	return _ExampleFeeManager.Contract.SetEnabled(&_ExampleFeeManager.TransactOpts, addr)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_ExampleFeeManager *ExampleFeeManagerTransactor) SetManager(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _ExampleFeeManager.contract.Transact(opts, "setManager", addr)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_ExampleFeeManager *ExampleFeeManagerSession) SetManager(addr common.Address) (*types.Transaction, error) {
	return _ExampleFeeManager.Contract.SetManager(&_ExampleFeeManager.TransactOpts, addr)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_ExampleFeeManager *ExampleFeeManagerTransactorSession) SetManager(addr common.Address) (*types.Transaction, error) {
	return _ExampleFeeManager.Contract.SetManager(&_ExampleFeeManager.TransactOpts, addr)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_ExampleFeeManager *ExampleFeeManagerTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _ExampleFeeManager.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_ExampleFeeManager *ExampleFeeManagerSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _ExampleFeeManager.Contract.TransferOwnership(&_ExampleFeeManager.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_ExampleFeeManager *ExampleFeeManagerTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _ExampleFeeManager.Contract.TransferOwnership(&_ExampleFeeManager.TransactOpts, newOwner)
}

// ExampleFeeManagerOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the ExampleFeeManager contract.
type ExampleFeeManagerOwnershipTransferredIterator struct {
	Event *ExampleFeeManagerOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleFeeManagerOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleFeeManagerOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleFeeManagerOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleFeeManagerOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleFeeManagerOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleFeeManagerOwnershipTransferred represents a OwnershipTransferred event raised by the ExampleFeeManager contract.
type ExampleFeeManagerOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_ExampleFeeManager *ExampleFeeManagerFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*ExampleFeeManagerOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _ExampleFeeManager.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &ExampleFeeManagerOwnershipTransferredIterator{contract: _ExampleFeeManager.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_ExampleFeeManager *ExampleFeeManagerFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *ExampleFeeManagerOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _ExampleFeeManager.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleFeeManagerOwnershipTransferred)
				if err := _ExampleFeeManager.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_ExampleFeeManager *ExampleFeeManagerFilterer) ParseOwnershipTransferred(log types.Log) (*ExampleFeeManagerOwnershipTransferred, error) {
	event := new(ExampleFeeManagerOwnershipTransferred)
	if err := _ExampleFeeManager.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleFeeManagerTestMetaData contains all meta data concerning the ExampleFeeManagerTest contract.
var ExampleFeeManagerTestMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"log_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"log_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"log_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"name\":\"log_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"val\",\"type\":\"address\"}],\"name\":\"log_named_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"val\",\"type\":\"bytes\"}],\"name\":\"log_named_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"val\",\"type\":\"bytes32\"}],\"name\":\"log_named_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"}],\"name\":\"log_named_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"val\",\"type\":\"string\"}],\"name\":\"log_named_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"log_named_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"log_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"logs\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"IS_TEST\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"failed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_addContractDeployerAsOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_addContractToManagerList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_changeFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_enableWAGMIFeesFailure\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_lowerMinFeeByOne\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_minFeeTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_raiseMinFeeByOne\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x608060405260016000806101000a81548160ff021916908315150217905550730200000000000000000000000000000000000003600060026101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550348015607e57600080fd5b506136f08061008e6000396000f3fe608060405234801561001057600080fd5b506004361061009e5760003560e01c8063ba414fa611610066578063ba414fa6146100d5578063bdae085b146100f3578063d1c196a0146100fd578063f39337b714610107578063fa7626d4146101115761009e565b80630a9254e4146100a35780630c64059f146100ad57806332545cb7146100b75780637ed971a0146100c157806394ac63a3146100cb575b600080fd5b6100ab61012f565b005b6100b5610131565b005b6100bf61034c565b005b6100c9610767565b005b6100d361080f565b005b6100dd6109cc565b6040516100ea91906114b9565b60405180910390f35b6100fb610b69565b005b610105610d26565b005b61010f610d28565b005b610119610fe3565b60405161012691906114b9565b60405180910390f35b565b600060405161013f90611491565b604051809103906000f08015801561015b573d6000803e3d6000fd5b509050610204600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1306040518263ffffffff1660e01b81526004016101bc9190611515565b602060405180830381865afa1580156101d9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101fd9190611575565b6002610ff4565b6102aa600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1836040518263ffffffff1660e01b81526004016102629190611515565b602060405180830381865afa15801561027f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102a39190611575565b6000610ff4565b8073ffffffffffffffffffffffffffffffffffffffff16636f0edc9d6040518163ffffffff1660e01b8152600401600060405180830381600087803b1580156102f257600080fd5b505af1925050508015610303575060015b156103495761034860006040518060400160405280601b81526020017f656e61626c655741474d49466565732073686f756c64206661696c0000000000815250611014565b5b50565b600060405161035a90611491565b604051809103906000f080158015610376573d6000803e3d6000fd5b5090506000819050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043826040518263ffffffff1660e01b81526004016103d99190611515565b600060405180830381600087803b1580156103f357600080fd5b505af1158015610407573d6000803e3d6000fd5b5050505060008273ffffffffffffffffffffffffffffffffffffffff166341f577286040518163ffffffff1660e01b815260040161010060405180830381865afa158015610459573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061047d91906116fd565b90506000604051806101000160405280627a12008152602001600281526020016405d21dba00815260200162e4e1c081526020016024815260200160008152602001620f42408152602001620186a081525090506104e38260000151826000015161105e565b6104f58260400151826040015161105e565b6105078260600151826060015161105e565b6105198260800151826080015161105e565b61052b8260c001518260c0015161105e565b61053d8260e001518260e0015161105e565b8373ffffffffffffffffffffffffffffffffffffffff166385c1b4ac6040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561058557600080fd5b505af1158015610599573d6000803e3d6000fd5b5050505060008473ffffffffffffffffffffffffffffffffffffffff166341f577286040518163ffffffff1660e01b815260040161010060405180830381865afa1580156105eb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061060f91906116fd565b905061062381600001518360000151611115565b61063581604001518360400151611115565b61064781606001518360600151611115565b61065981608001518360800151611115565b61066b8160c001518360c00151611115565b61067d8160e001518360e00151611115565b6106f58573ffffffffffffffffffffffffffffffffffffffff16639e05549a6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156106cb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106ef9190611575565b43611115565b8473ffffffffffffffffffffffffffffffffffffffff166352965cfc846040518263ffffffff1660e01b815260040161072e91906117dc565b600060405180830381600087803b15801561074857600080fd5b505af115801561075c573d6000803e3d6000fd5b505050505050505050565b600060405161077590611491565b604051809103906000f080158015610791573d6000803e3d6000fd5b50905061080c308273ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156107e3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108079190611824565b6111cc565b50565b600060405161081d90611491565b604051809103906000f080158015610839573d6000803e3d6000fd5b5090506000819050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043826040518263ffffffff1660e01b815260040161089c9190611515565b600060405180830381600087803b1580156108b657600080fd5b505af11580156108ca573d6000803e3d6000fd5b5050505060008273ffffffffffffffffffffffffffffffffffffffff166341f577286040518163ffffffff1660e01b815260040161010060405180830381865afa15801561091c573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061094091906116fd565b9050600181604001516109539190611880565b8160400181815250508273ffffffffffffffffffffffffffffffffffffffff166352965cfc826040518263ffffffff1660e01b815260040161099591906117dc565b600060405180830381600087803b1580156109af57600080fd5b505af11580156109c3573d6000803e3d6000fd5b50505050505050565b60008060019054906101000a900460ff16156109f957600060019054906101000a900460ff169050610b66565b6000610a036112af565b15610b615760007f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d60001c60601b60601c73ffffffffffffffffffffffffffffffffffffffff167f667f9d70ca411d70ead50d8d5c22070dafc36ad75f3dcf5e7237b22ade9aecc47f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d60001c60601b60601c7f6661696c65640000000000000000000000000000000000000000000000000000604051602001610ac79291906118cd565b604051602081830303815290604052604051602001610ae79291906119b4565b604051602081830303815290604052604051610b0391906119dc565b6000604051808303816000865af19150503d8060008114610b40576040519150601f19603f3d011682016040523d82523d6000602084013e610b45565b606091505b5091505080806020019051810190610b5d9190611a1f565b9150505b809150505b90565b6000604051610b7790611491565b604051809103906000f080158015610b93573d6000803e3d6000fd5b5090506000819050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043826040518263ffffffff1660e01b8152600401610bf69190611515565b600060405180830381600087803b158015610c1057600080fd5b505af1158015610c24573d6000803e3d6000fd5b5050505060008273ffffffffffffffffffffffffffffffffffffffff166341f577286040518163ffffffff1660e01b815260040161010060405180830381865afa158015610c76573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c9a91906116fd565b905060018160400151610cad9190611a4c565b8160400181815250508273ffffffffffffffffffffffffffffffffffffffff166352965cfc826040518263ffffffff1660e01b8152600401610cef91906117dc565b600060405180830381600087803b158015610d0957600080fd5b505af1158015610d1d573d6000803e3d6000fd5b50505050505050565b565b6000604051610d3690611491565b604051809103906000f080158015610d52573d6000803e3d6000fd5b50905060008190506000309050610e05600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1836040518263ffffffff1660e01b8152600401610dbd9190611515565b602060405180830381865afa158015610dda573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dfe9190611575565b6002610ff4565b610eab600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b8152600401610e639190611515565b602060405180830381865afa158015610e80573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ea49190611575565b6000610ff4565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043836040518263ffffffff1660e01b8152600401610f069190611515565b600060405180830381600087803b158015610f2057600080fd5b505af1158015610f34573d6000803e3d6000fd5b50505050610fde600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b8152600401610f969190611515565b602060405180830381865afa158015610fb3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fd79190611575565b6001610ff4565b505050565b60008054906101000a900460ff1681565b6110108282600381111561100b5761100a611a80565b5b611115565b5050565b8161105a577f280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583816040516110489190611b50565b60405180910390a1611059826112d8565b5b5050565b808203611111577f41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f5060405161109290611bf7565b60405180910390a17fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8826040516110c99190611c72565b60405180910390a17fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8816040516111009190611cec565b60405180910390a161111061131e565b5b5050565b8082146111c8577f41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f5060405161114990611d8c565b60405180910390a17fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8826040516111809190611c72565b60405180910390a17fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8816040516111b79190611cec565b60405180910390a16111c761131e565b5b5050565b8073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16146112ab577f41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f5060405161122c90611e1e565b60405180910390a17f9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f826040516112639190611e3e565b60405180910390a17f9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f8160405161129a9190611e6c565b60405180910390a16112aa61131e565b5b5050565b60008060009050737109709ecfa91a80626ff3989d68f67f5b1dd12d3b90506000811191505090565b8061131b577f41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f5060405161130a90611ee6565b60405180910390a161131a61131e565b5b50565b6113266112af565b156114745760007f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d60001c60601b60601c73ffffffffffffffffffffffffffffffffffffffff167f70ca10bbd0dbfd9020a9f4b13402c16cb120705e0d1c0aeab10fa353ae586fc47f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d60001c60601b60601c7f6661696c65640000000000000000000000000000000000000000000000000000600160001b6040516020016113f093929190611f06565b6040516020818303038152906040526040516020016114109291906119b4565b60405160208183030381529060405260405161142c91906119dc565b6000604051808303816000865af19150503d8060008114611469576040519150601f19603f3d011682016040523d82523d6000602084013e61146e565b606091505b50509050505b6001600060016101000a81548160ff021916908315150217905550565b61177d80611f3e83390190565b60008115159050919050565b6114b38161149e565b82525050565b60006020820190506114ce60008301846114aa565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006114ff826114d4565b9050919050565b61150f816114f4565b82525050565b600060208201905061152a6000830184611506565b92915050565b6000604051905090565b600080fd5b6000819050919050565b6115528161153f565b811461155d57600080fd5b50565b60008151905061156f81611549565b92915050565b60006020828403121561158b5761158a61153a565b5b600061159984828501611560565b91505092915050565b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6115f0826115a7565b810181811067ffffffffffffffff8211171561160f5761160e6115b8565b5b80604052505050565b6000611622611530565b905061162e82826115e7565b919050565b6000610100828403121561164a576116496115a2565b5b611655610100611618565b9050600061166584828501611560565b600083015250602061167984828501611560565b602083015250604061168d84828501611560565b60408301525060606116a184828501611560565b60608301525060806116b584828501611560565b60808301525060a06116c984828501611560565b60a08301525060c06116dd84828501611560565b60c08301525060e06116f184828501611560565b60e08301525092915050565b600061010082840312156117145761171361153a565b5b600061172284828501611633565b91505092915050565b6117348161153f565b82525050565b61010082016000820151611751600085018261172b565b506020820151611764602085018261172b565b506040820151611777604085018261172b565b50606082015161178a606085018261172b565b50608082015161179d608085018261172b565b5060a08201516117b060a085018261172b565b5060c08201516117c360c085018261172b565b5060e08201516117d660e085018261172b565b50505050565b6000610100820190506117f2600083018461173a565b92915050565b611801816114f4565b811461180c57600080fd5b50565b60008151905061181e816117f8565b92915050565b60006020828403121561183a5761183961153a565b5b60006118488482850161180f565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061188b8261153f565b91506118968361153f565b92508282039050818111156118ae576118ad611851565b5b92915050565b6000819050919050565b6118c7816118b4565b82525050565b60006040820190506118e26000830185611506565b6118ef60208301846118be565b9392505050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b6000819050919050565b61193d611938826118f6565b611922565b82525050565b600081519050919050565b600081905092915050565b60005b8381101561197757808201518184015260208101905061195c565b60008484015250505050565b600061198e82611943565b611998818561194e565b93506119a8818560208601611959565b80840191505092915050565b60006119c0828561192c565b6004820191506119d08284611983565b91508190509392505050565b60006119e88284611983565b915081905092915050565b6119fc8161149e565b8114611a0757600080fd5b50565b600081519050611a19816119f3565b92915050565b600060208284031215611a3557611a3461153a565b5b6000611a4384828501611a0a565b91505092915050565b6000611a578261153f565b9150611a628361153f565b9250828201905080821115611a7a57611a79611851565b5b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b600082825260208201905092915050565b7f4572726f72000000000000000000000000000000000000000000000000000000600082015250565b6000611af6600583611aaf565b9150611b0182611ac0565b602082019050919050565b600081519050919050565b6000611b2282611b0c565b611b2c8185611aaf565b9350611b3c818560208601611959565b611b45816115a7565b840191505092915050565b60006040820190508181036000830152611b6981611ae9565b90508181036020830152611b7d8184611b17565b905092915050565b7f4572726f723a206120213d2062206e6f7420736174697366696564205b75696e60008201527f745d000000000000000000000000000000000000000000000000000000000000602082015250565b6000611be1602283611aaf565b9150611bec82611b85565b604082019050919050565b60006020820190508181036000830152611c1081611bd4565b9050919050565b7f2020202020204c65667400000000000000000000000000000000000000000000600082015250565b6000611c4d600a83611aaf565b9150611c5882611c17565b602082019050919050565b611c6c8161153f565b82525050565b60006040820190508181036000830152611c8b81611c40565b9050611c9a6020830184611c63565b92915050565b7f2020202020526967687400000000000000000000000000000000000000000000600082015250565b6000611cd6600a83611aaf565b9150611ce182611ca0565b602082019050919050565b60006040820190508181036000830152611d0581611cc9565b9050611d146020830184611c63565b92915050565b7f4572726f723a2061203d3d2062206e6f7420736174697366696564205b75696e60008201527f745d000000000000000000000000000000000000000000000000000000000000602082015250565b6000611d76602283611aaf565b9150611d8182611d1a565b604082019050919050565b60006020820190508181036000830152611da581611d69565b9050919050565b7f4572726f723a2061203d3d2062206e6f7420736174697366696564205b61646460008201527f726573735d000000000000000000000000000000000000000000000000000000602082015250565b6000611e08602583611aaf565b9150611e1382611dac565b604082019050919050565b60006020820190508181036000830152611e3781611dfb565b9050919050565b60006040820190508181036000830152611e5781611c40565b9050611e666020830184611506565b92915050565b60006040820190508181036000830152611e8581611cc9565b9050611e946020830184611506565b92915050565b7f4572726f723a20417373657274696f6e204661696c6564000000000000000000600082015250565b6000611ed0601783611aaf565b9150611edb82611e9a565b602082019050919050565b60006020820190508181036000830152611eff81611ec3565b9050919050565b6000606082019050611f1b6000830186611506565b611f2860208301856118be565b611f3560408301846118be565b94935050505056fe6080604052730200000000000000000000000000000000000003600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555034801561006557600080fd5b5073020000000000000000000000000000000000000361009761008c6100de60201b60201c565b6100e660201b60201c565b80600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550506101aa565b600033905090565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b6115c4806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100f55760003560e01c806374a8f103116100975780639e05549a116100665780639e05549a14610224578063d0ebdbe714610242578063f2fde38b1461025e578063f3ae24151461027a576100f5565b806374a8f103146101b057806385c1b4ac146101cc5780638da5cb5b146101d65780639015d371146101f4576100f5565b806352965cfc116100d357806352965cfc146101645780636f0edc9d14610180578063704b6c021461018a578063715018a6146101a6576100f5565b80630aaf7043146100fa57806324d7806c1461011657806341f5772814610146575b600080fd5b610114600480360381019061010f9190610eee565b6102aa565b005b610130600480360381019061012b9190610eee565b6102be565b60405161013d9190610f36565b60405180910390f35b61014e61036b565b60405161015b919061100c565b60405180910390f35b61017e600480360381019061017991906111af565b61045c565b005b610188610562565b005b6101a4600480360381019061019f9190610eee565b61065c565b005b6101ae610670565b005b6101ca60048036038101906101c59190610eee565b610684565b005b6101d4610698565b005b6101de610791565b6040516101eb91906111ec565b60405180910390f35b61020e60048036038101906102099190610eee565b6107ba565b60405161021b9190610f36565b60405180910390f35b61022c610868565b6040516102399190611216565b60405180910390f35b61025c60048036038101906102579190610eee565b610900565b005b61027860048036038101906102739190610eee565b610914565b005b610294600480360381019061028f9190610eee565b610997565b6040516102a19190610f36565b60405180910390f35b6102b2610a44565b6102bb81610ac2565b50565b600080600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b815260040161031c91906111ec565b602060405180830381865afa158015610339573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061035d9190611246565b905060028114915050919050565b610373610e3c565b61037b610e3c565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16635fbbc0d26040518163ffffffff1660e01b815260040161010060405180830381865afa1580156103e9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061040d9190611273565b88600001896020018a6040018b6060018c6080018d60a0018e60c0018f60e001888152508881525088815250888152508881525088815250888152508881525050505050505050508091505090565b610465336107ba565b6104a4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161049b90611386565b60405180910390fd5b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638f10b586826000015183602001518460400151856060015186608001518760a001518860c001518960e001516040518963ffffffff1660e01b815260040161052d9897969594939291906113a6565b600060405180830381600087803b15801561054757600080fd5b505af115801561055b573d6000803e3d6000fd5b5050505050565b61056b336107ba565b6105aa576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105a190611386565b60405180910390fd5b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638f10b5866301312d006002633b9aca006305f5e10060306000629896806207a1206040518963ffffffff1660e01b81526004016106289897969594939291906113a6565b600060405180830381600087803b15801561064257600080fd5b505af1158015610656573d6000803e3d6000fd5b50505050565b610664610a44565b61066d81610b52565b50565b610678610a44565b6106826000610be2565b565b61068c610a44565b61069581610ca6565b50565b6106a1336107ba565b6106e0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106d790611386565b60405180910390fd5b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638f10b586627a120060026405d21dba0062e4e1c060246000620f4240620186a06040518963ffffffff1660e01b815260040161075d9897969594939291906113a6565b600060405180830381600087803b15801561077757600080fd5b505af115801561078b573d6000803e3d6000fd5b50505050565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b600080600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b815260040161081891906111ec565b602060405180830381865afa158015610835573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108599190611246565b90506000811415915050919050565b6000600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16639e05549a6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156108d7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108fb9190611246565b905090565b610908610a44565b61091181610da4565b50565b61091c610a44565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff160361098b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161098290611496565b60405180910390fd5b61099481610be2565b50565b600080600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b81526004016109f591906111ec565b602060405180830381865afa158015610a12573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a369190611246565b905060038114915050919050565b610a4c610e34565b73ffffffffffffffffffffffffffffffffffffffff16610a6a610791565b73ffffffffffffffffffffffffffffffffffffffff1614610ac0576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ab790611502565b60405180910390fd5b565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043826040518263ffffffff1660e01b8152600401610b1d91906111ec565b600060405180830381600087803b158015610b3757600080fd5b505af1158015610b4b573d6000803e3d6000fd5b5050505050565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663704b6c02826040518263ffffffff1660e01b8152600401610bad91906111ec565b600060405180830381600087803b158015610bc757600080fd5b505af1158015610bdb573d6000803e3d6000fd5b5050505050565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b8073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1603610d14576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610d0b9061156e565b60405180910390fd5b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638c6bfb3b826040518263ffffffff1660e01b8152600401610d6f91906111ec565b600060405180830381600087803b158015610d8957600080fd5b505af1158015610d9d573d6000803e3d6000fd5b5050505050565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d0ebdbe7826040518263ffffffff1660e01b8152600401610dff91906111ec565b600060405180830381600087803b158015610e1957600080fd5b505af1158015610e2d573d6000803e3d6000fd5b5050505050565b600033905090565b60405180610100016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6000604051905090565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610ebb82610e90565b9050919050565b610ecb81610eb0565b8114610ed657600080fd5b50565b600081359050610ee881610ec2565b92915050565b600060208284031215610f0457610f03610e8b565b5b6000610f1284828501610ed9565b91505092915050565b60008115159050919050565b610f3081610f1b565b82525050565b6000602082019050610f4b6000830184610f27565b92915050565b6000819050919050565b610f6481610f51565b82525050565b61010082016000820151610f816000850182610f5b565b506020820151610f946020850182610f5b565b506040820151610fa76040850182610f5b565b506060820151610fba6060850182610f5b565b506080820151610fcd6080850182610f5b565b5060a0820151610fe060a0850182610f5b565b5060c0820151610ff360c0850182610f5b565b5060e082015161100660e0850182610f5b565b50505050565b6000610100820190506110226000830184610f6a565b92915050565b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6110768261102d565b810181811067ffffffffffffffff821117156110955761109461103e565b5b80604052505050565b60006110a8610e81565b90506110b4828261106d565b919050565b6110c281610f51565b81146110cd57600080fd5b50565b6000813590506110df816110b9565b92915050565b600061010082840312156110fc576110fb611028565b5b61110761010061109e565b90506000611117848285016110d0565b600083015250602061112b848285016110d0565b602083015250604061113f848285016110d0565b6040830152506060611153848285016110d0565b6060830152506080611167848285016110d0565b60808301525060a061117b848285016110d0565b60a08301525060c061118f848285016110d0565b60c08301525060e06111a3848285016110d0565b60e08301525092915050565b600061010082840312156111c6576111c5610e8b565b5b60006111d4848285016110e5565b91505092915050565b6111e681610eb0565b82525050565b600060208201905061120160008301846111dd565b92915050565b61121081610f51565b82525050565b600060208201905061122b6000830184611207565b92915050565b600081519050611240816110b9565b92915050565b60006020828403121561125c5761125b610e8b565b5b600061126a84828501611231565b91505092915050565b600080600080600080600080610100898b03121561129457611293610e8b565b5b60006112a28b828c01611231565b98505060206112b38b828c01611231565b97505060406112c48b828c01611231565b96505060606112d58b828c01611231565b95505060806112e68b828c01611231565b94505060a06112f78b828c01611231565b93505060c06113088b828c01611231565b92505060e06113198b828c01611231565b9150509295985092959890939650565b600082825260208201905092915050565b7f6e6f7420656e61626c6564000000000000000000000000000000000000000000600082015250565b6000611370600b83611329565b915061137b8261133a565b602082019050919050565b6000602082019050818103600083015261139f81611363565b9050919050565b6000610100820190506113bc600083018b611207565b6113c9602083018a611207565b6113d66040830189611207565b6113e36060830188611207565b6113f06080830187611207565b6113fd60a0830186611207565b61140a60c0830185611207565b61141760e0830184611207565b9998505050505050505050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160008201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b6000611480602683611329565b915061148b82611424565b604082019050919050565b600060208201905081810360008301526114af81611473565b9050919050565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572600082015250565b60006114ec602083611329565b91506114f7826114b6565b602082019050919050565b6000602082019050818103600083015261151b816114df565b9050919050565b7f63616e6e6f74207265766f6b65206f776e20726f6c6500000000000000000000600082015250565b6000611558601683611329565b915061156382611522565b602082019050919050565b600060208201905081810360008301526115878161154b565b905091905056fea2646970667358221220fe9811b144e1be1ad9892305ffac1890a4c810b3282d472939ec7a2a4741a1f764736f6c634300081a0033a26469706673582212209fed7f28fd7fa895138ffd5b1f09a9299d8190012f3dee77808e5ae05e47c03264736f6c634300081a0033",
}

// ExampleFeeManagerTestABI is the input ABI used to generate the binding from.
// Deprecated: Use ExampleFeeManagerTestMetaData.ABI instead.
var ExampleFeeManagerTestABI = ExampleFeeManagerTestMetaData.ABI

// ExampleFeeManagerTestBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use ExampleFeeManagerTestMetaData.Bin instead.
var ExampleFeeManagerTestBin = ExampleFeeManagerTestMetaData.Bin

// DeployExampleFeeManagerTest deploys a new Ethereum contract, binding an instance of ExampleFeeManagerTest to it.
func DeployExampleFeeManagerTest(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ExampleFeeManagerTest, error) {
	parsed, err := ExampleFeeManagerTestMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(ExampleFeeManagerTestBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ExampleFeeManagerTest{ExampleFeeManagerTestCaller: ExampleFeeManagerTestCaller{contract: contract}, ExampleFeeManagerTestTransactor: ExampleFeeManagerTestTransactor{contract: contract}, ExampleFeeManagerTestFilterer: ExampleFeeManagerTestFilterer{contract: contract}}, nil
}

// ExampleFeeManagerTest is an auto generated Go binding around an Ethereum contract.
type ExampleFeeManagerTest struct {
	ExampleFeeManagerTestCaller     // Read-only binding to the contract
	ExampleFeeManagerTestTransactor // Write-only binding to the contract
	ExampleFeeManagerTestFilterer   // Log filterer for contract events
}

// ExampleFeeManagerTestCaller is an auto generated read-only Go binding around an Ethereum contract.
type ExampleFeeManagerTestCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExampleFeeManagerTestTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ExampleFeeManagerTestTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExampleFeeManagerTestFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ExampleFeeManagerTestFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExampleFeeManagerTestSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ExampleFeeManagerTestSession struct {
	Contract     *ExampleFeeManagerTest // Generic contract binding to set the session for
	CallOpts     bind.CallOpts          // Call options to use throughout this session
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// ExampleFeeManagerTestCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ExampleFeeManagerTestCallerSession struct {
	Contract *ExampleFeeManagerTestCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts                // Call options to use throughout this session
}

// ExampleFeeManagerTestTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ExampleFeeManagerTestTransactorSession struct {
	Contract     *ExampleFeeManagerTestTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts                // Transaction auth options to use throughout this session
}

// ExampleFeeManagerTestRaw is an auto generated low-level Go binding around an Ethereum contract.
type ExampleFeeManagerTestRaw struct {
	Contract *ExampleFeeManagerTest // Generic contract binding to access the raw methods on
}

// ExampleFeeManagerTestCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ExampleFeeManagerTestCallerRaw struct {
	Contract *ExampleFeeManagerTestCaller // Generic read-only contract binding to access the raw methods on
}

// ExampleFeeManagerTestTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ExampleFeeManagerTestTransactorRaw struct {
	Contract *ExampleFeeManagerTestTransactor // Generic write-only contract binding to access the raw methods on
}

// NewExampleFeeManagerTest creates a new instance of ExampleFeeManagerTest, bound to a specific deployed contract.
func NewExampleFeeManagerTest(address common.Address, backend bind.ContractBackend) (*ExampleFeeManagerTest, error) {
	contract, err := bindExampleFeeManagerTest(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ExampleFeeManagerTest{ExampleFeeManagerTestCaller: ExampleFeeManagerTestCaller{contract: contract}, ExampleFeeManagerTestTransactor: ExampleFeeManagerTestTransactor{contract: contract}, ExampleFeeManagerTestFilterer: ExampleFeeManagerTestFilterer{contract: contract}}, nil
}

// NewExampleFeeManagerTestCaller creates a new read-only instance of ExampleFeeManagerTest, bound to a specific deployed contract.
func NewExampleFeeManagerTestCaller(address common.Address, caller bind.ContractCaller) (*ExampleFeeManagerTestCaller, error) {
	contract, err := bindExampleFeeManagerTest(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ExampleFeeManagerTestCaller{contract: contract}, nil
}

// NewExampleFeeManagerTestTransactor creates a new write-only instance of ExampleFeeManagerTest, bound to a specific deployed contract.
func NewExampleFeeManagerTestTransactor(address common.Address, transactor bind.ContractTransactor) (*ExampleFeeManagerTestTransactor, error) {
	contract, err := bindExampleFeeManagerTest(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ExampleFeeManagerTestTransactor{contract: contract}, nil
}

// NewExampleFeeManagerTestFilterer creates a new log filterer instance of ExampleFeeManagerTest, bound to a specific deployed contract.
func NewExampleFeeManagerTestFilterer(address common.Address, filterer bind.ContractFilterer) (*ExampleFeeManagerTestFilterer, error) {
	contract, err := bindExampleFeeManagerTest(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ExampleFeeManagerTestFilterer{contract: contract}, nil
}

// bindExampleFeeManagerTest binds a generic wrapper to an already deployed contract.
func bindExampleFeeManagerTest(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ExampleFeeManagerTestMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ExampleFeeManagerTest *ExampleFeeManagerTestRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ExampleFeeManagerTest.Contract.ExampleFeeManagerTestCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ExampleFeeManagerTest *ExampleFeeManagerTestRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleFeeManagerTest.Contract.ExampleFeeManagerTestTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ExampleFeeManagerTest *ExampleFeeManagerTestRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ExampleFeeManagerTest.Contract.ExampleFeeManagerTestTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ExampleFeeManagerTest *ExampleFeeManagerTestCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ExampleFeeManagerTest.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ExampleFeeManagerTest *ExampleFeeManagerTestTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleFeeManagerTest.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ExampleFeeManagerTest *ExampleFeeManagerTestTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ExampleFeeManagerTest.Contract.contract.Transact(opts, method, params...)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestCaller) ISTEST(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _ExampleFeeManagerTest.contract.Call(opts, &out, "IS_TEST")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestSession) ISTEST() (bool, error) {
	return _ExampleFeeManagerTest.Contract.ISTEST(&_ExampleFeeManagerTest.CallOpts)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestCallerSession) ISTEST() (bool, error) {
	return _ExampleFeeManagerTest.Contract.ISTEST(&_ExampleFeeManagerTest.CallOpts)
}

// Failed is a paid mutator transaction binding the contract method 0xba414fa6.
//
// Solidity: function failed() returns(bool)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestTransactor) Failed(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleFeeManagerTest.contract.Transact(opts, "failed")
}

// Failed is a paid mutator transaction binding the contract method 0xba414fa6.
//
// Solidity: function failed() returns(bool)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestSession) Failed() (*types.Transaction, error) {
	return _ExampleFeeManagerTest.Contract.Failed(&_ExampleFeeManagerTest.TransactOpts)
}

// Failed is a paid mutator transaction binding the contract method 0xba414fa6.
//
// Solidity: function failed() returns(bool)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestTransactorSession) Failed() (*types.Transaction, error) {
	return _ExampleFeeManagerTest.Contract.Failed(&_ExampleFeeManagerTest.TransactOpts)
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_ExampleFeeManagerTest *ExampleFeeManagerTestTransactor) SetUp(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleFeeManagerTest.contract.Transact(opts, "setUp")
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_ExampleFeeManagerTest *ExampleFeeManagerTestSession) SetUp() (*types.Transaction, error) {
	return _ExampleFeeManagerTest.Contract.SetUp(&_ExampleFeeManagerTest.TransactOpts)
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_ExampleFeeManagerTest *ExampleFeeManagerTestTransactorSession) SetUp() (*types.Transaction, error) {
	return _ExampleFeeManagerTest.Contract.SetUp(&_ExampleFeeManagerTest.TransactOpts)
}

// StepAddContractDeployerAsOwner is a paid mutator transaction binding the contract method 0x7ed971a0.
//
// Solidity: function step_addContractDeployerAsOwner() returns()
func (_ExampleFeeManagerTest *ExampleFeeManagerTestTransactor) StepAddContractDeployerAsOwner(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleFeeManagerTest.contract.Transact(opts, "step_addContractDeployerAsOwner")
}

// StepAddContractDeployerAsOwner is a paid mutator transaction binding the contract method 0x7ed971a0.
//
// Solidity: function step_addContractDeployerAsOwner() returns()
func (_ExampleFeeManagerTest *ExampleFeeManagerTestSession) StepAddContractDeployerAsOwner() (*types.Transaction, error) {
	return _ExampleFeeManagerTest.Contract.StepAddContractDeployerAsOwner(&_ExampleFeeManagerTest.TransactOpts)
}

// StepAddContractDeployerAsOwner is a paid mutator transaction binding the contract method 0x7ed971a0.
//
// Solidity: function step_addContractDeployerAsOwner() returns()
func (_ExampleFeeManagerTest *ExampleFeeManagerTestTransactorSession) StepAddContractDeployerAsOwner() (*types.Transaction, error) {
	return _ExampleFeeManagerTest.Contract.StepAddContractDeployerAsOwner(&_ExampleFeeManagerTest.TransactOpts)
}

// StepAddContractToManagerList is a paid mutator transaction binding the contract method 0xf39337b7.
//
// Solidity: function step_addContractToManagerList() returns()
func (_ExampleFeeManagerTest *ExampleFeeManagerTestTransactor) StepAddContractToManagerList(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleFeeManagerTest.contract.Transact(opts, "step_addContractToManagerList")
}

// StepAddContractToManagerList is a paid mutator transaction binding the contract method 0xf39337b7.
//
// Solidity: function step_addContractToManagerList() returns()
func (_ExampleFeeManagerTest *ExampleFeeManagerTestSession) StepAddContractToManagerList() (*types.Transaction, error) {
	return _ExampleFeeManagerTest.Contract.StepAddContractToManagerList(&_ExampleFeeManagerTest.TransactOpts)
}

// StepAddContractToManagerList is a paid mutator transaction binding the contract method 0xf39337b7.
//
// Solidity: function step_addContractToManagerList() returns()
func (_ExampleFeeManagerTest *ExampleFeeManagerTestTransactorSession) StepAddContractToManagerList() (*types.Transaction, error) {
	return _ExampleFeeManagerTest.Contract.StepAddContractToManagerList(&_ExampleFeeManagerTest.TransactOpts)
}

// StepChangeFees is a paid mutator transaction binding the contract method 0x32545cb7.
//
// Solidity: function step_changeFees() returns()
func (_ExampleFeeManagerTest *ExampleFeeManagerTestTransactor) StepChangeFees(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleFeeManagerTest.contract.Transact(opts, "step_changeFees")
}

// StepChangeFees is a paid mutator transaction binding the contract method 0x32545cb7.
//
// Solidity: function step_changeFees() returns()
func (_ExampleFeeManagerTest *ExampleFeeManagerTestSession) StepChangeFees() (*types.Transaction, error) {
	return _ExampleFeeManagerTest.Contract.StepChangeFees(&_ExampleFeeManagerTest.TransactOpts)
}

// StepChangeFees is a paid mutator transaction binding the contract method 0x32545cb7.
//
// Solidity: function step_changeFees() returns()
func (_ExampleFeeManagerTest *ExampleFeeManagerTestTransactorSession) StepChangeFees() (*types.Transaction, error) {
	return _ExampleFeeManagerTest.Contract.StepChangeFees(&_ExampleFeeManagerTest.TransactOpts)
}

// StepEnableWAGMIFeesFailure is a paid mutator transaction binding the contract method 0x0c64059f.
//
// Solidity: function step_enableWAGMIFeesFailure() returns()
func (_ExampleFeeManagerTest *ExampleFeeManagerTestTransactor) StepEnableWAGMIFeesFailure(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleFeeManagerTest.contract.Transact(opts, "step_enableWAGMIFeesFailure")
}

// StepEnableWAGMIFeesFailure is a paid mutator transaction binding the contract method 0x0c64059f.
//
// Solidity: function step_enableWAGMIFeesFailure() returns()
func (_ExampleFeeManagerTest *ExampleFeeManagerTestSession) StepEnableWAGMIFeesFailure() (*types.Transaction, error) {
	return _ExampleFeeManagerTest.Contract.StepEnableWAGMIFeesFailure(&_ExampleFeeManagerTest.TransactOpts)
}

// StepEnableWAGMIFeesFailure is a paid mutator transaction binding the contract method 0x0c64059f.
//
// Solidity: function step_enableWAGMIFeesFailure() returns()
func (_ExampleFeeManagerTest *ExampleFeeManagerTestTransactorSession) StepEnableWAGMIFeesFailure() (*types.Transaction, error) {
	return _ExampleFeeManagerTest.Contract.StepEnableWAGMIFeesFailure(&_ExampleFeeManagerTest.TransactOpts)
}

// StepLowerMinFeeByOne is a paid mutator transaction binding the contract method 0x94ac63a3.
//
// Solidity: function step_lowerMinFeeByOne() returns()
func (_ExampleFeeManagerTest *ExampleFeeManagerTestTransactor) StepLowerMinFeeByOne(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleFeeManagerTest.contract.Transact(opts, "step_lowerMinFeeByOne")
}

// StepLowerMinFeeByOne is a paid mutator transaction binding the contract method 0x94ac63a3.
//
// Solidity: function step_lowerMinFeeByOne() returns()
func (_ExampleFeeManagerTest *ExampleFeeManagerTestSession) StepLowerMinFeeByOne() (*types.Transaction, error) {
	return _ExampleFeeManagerTest.Contract.StepLowerMinFeeByOne(&_ExampleFeeManagerTest.TransactOpts)
}

// StepLowerMinFeeByOne is a paid mutator transaction binding the contract method 0x94ac63a3.
//
// Solidity: function step_lowerMinFeeByOne() returns()
func (_ExampleFeeManagerTest *ExampleFeeManagerTestTransactorSession) StepLowerMinFeeByOne() (*types.Transaction, error) {
	return _ExampleFeeManagerTest.Contract.StepLowerMinFeeByOne(&_ExampleFeeManagerTest.TransactOpts)
}

// StepMinFeeTransaction is a paid mutator transaction binding the contract method 0xd1c196a0.
//
// Solidity: function step_minFeeTransaction() returns()
func (_ExampleFeeManagerTest *ExampleFeeManagerTestTransactor) StepMinFeeTransaction(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleFeeManagerTest.contract.Transact(opts, "step_minFeeTransaction")
}

// StepMinFeeTransaction is a paid mutator transaction binding the contract method 0xd1c196a0.
//
// Solidity: function step_minFeeTransaction() returns()
func (_ExampleFeeManagerTest *ExampleFeeManagerTestSession) StepMinFeeTransaction() (*types.Transaction, error) {
	return _ExampleFeeManagerTest.Contract.StepMinFeeTransaction(&_ExampleFeeManagerTest.TransactOpts)
}

// StepMinFeeTransaction is a paid mutator transaction binding the contract method 0xd1c196a0.
//
// Solidity: function step_minFeeTransaction() returns()
func (_ExampleFeeManagerTest *ExampleFeeManagerTestTransactorSession) StepMinFeeTransaction() (*types.Transaction, error) {
	return _ExampleFeeManagerTest.Contract.StepMinFeeTransaction(&_ExampleFeeManagerTest.TransactOpts)
}

// StepRaiseMinFeeByOne is a paid mutator transaction binding the contract method 0xbdae085b.
//
// Solidity: function step_raiseMinFeeByOne() returns()
func (_ExampleFeeManagerTest *ExampleFeeManagerTestTransactor) StepRaiseMinFeeByOne(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleFeeManagerTest.contract.Transact(opts, "step_raiseMinFeeByOne")
}

// StepRaiseMinFeeByOne is a paid mutator transaction binding the contract method 0xbdae085b.
//
// Solidity: function step_raiseMinFeeByOne() returns()
func (_ExampleFeeManagerTest *ExampleFeeManagerTestSession) StepRaiseMinFeeByOne() (*types.Transaction, error) {
	return _ExampleFeeManagerTest.Contract.StepRaiseMinFeeByOne(&_ExampleFeeManagerTest.TransactOpts)
}

// StepRaiseMinFeeByOne is a paid mutator transaction binding the contract method 0xbdae085b.
//
// Solidity: function step_raiseMinFeeByOne() returns()
func (_ExampleFeeManagerTest *ExampleFeeManagerTestTransactorSession) StepRaiseMinFeeByOne() (*types.Transaction, error) {
	return _ExampleFeeManagerTest.Contract.StepRaiseMinFeeByOne(&_ExampleFeeManagerTest.TransactOpts)
}

// ExampleFeeManagerTestLogIterator is returned from FilterLog and is used to iterate over the raw logs and unpacked data for Log events raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogIterator struct {
	Event *ExampleFeeManagerTestLog // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleFeeManagerTestLogIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleFeeManagerTestLog)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleFeeManagerTestLog)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleFeeManagerTestLogIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleFeeManagerTestLogIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleFeeManagerTestLog represents a Log event raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLog struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLog is a free log retrieval operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) FilterLog(opts *bind.FilterOpts) (*ExampleFeeManagerTestLogIterator, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.FilterLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return &ExampleFeeManagerTestLogIterator{contract: _ExampleFeeManagerTest.contract, event: "log", logs: logs, sub: sub}, nil
}

// WatchLog is a free log subscription operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) WatchLog(opts *bind.WatchOpts, sink chan<- *ExampleFeeManagerTestLog) (event.Subscription, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.WatchLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleFeeManagerTestLog)
				if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLog is a log parse operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) ParseLog(log types.Log) (*ExampleFeeManagerTestLog, error) {
	event := new(ExampleFeeManagerTestLog)
	if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleFeeManagerTestLogAddressIterator is returned from FilterLogAddress and is used to iterate over the raw logs and unpacked data for LogAddress events raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogAddressIterator struct {
	Event *ExampleFeeManagerTestLogAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleFeeManagerTestLogAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleFeeManagerTestLogAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleFeeManagerTestLogAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleFeeManagerTestLogAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleFeeManagerTestLogAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleFeeManagerTestLogAddress represents a LogAddress event raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogAddress struct {
	Arg0 common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogAddress is a free log retrieval operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) FilterLogAddress(opts *bind.FilterOpts) (*ExampleFeeManagerTestLogAddressIterator, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.FilterLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return &ExampleFeeManagerTestLogAddressIterator{contract: _ExampleFeeManagerTest.contract, event: "log_address", logs: logs, sub: sub}, nil
}

// WatchLogAddress is a free log subscription operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) WatchLogAddress(opts *bind.WatchOpts, sink chan<- *ExampleFeeManagerTestLogAddress) (event.Subscription, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.WatchLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleFeeManagerTestLogAddress)
				if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogAddress is a log parse operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) ParseLogAddress(log types.Log) (*ExampleFeeManagerTestLogAddress, error) {
	event := new(ExampleFeeManagerTestLogAddress)
	if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_address", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleFeeManagerTestLogBytesIterator is returned from FilterLogBytes and is used to iterate over the raw logs and unpacked data for LogBytes events raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogBytesIterator struct {
	Event *ExampleFeeManagerTestLogBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleFeeManagerTestLogBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleFeeManagerTestLogBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleFeeManagerTestLogBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleFeeManagerTestLogBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleFeeManagerTestLogBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleFeeManagerTestLogBytes represents a LogBytes event raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogBytes struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes is a free log retrieval operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) FilterLogBytes(opts *bind.FilterOpts) (*ExampleFeeManagerTestLogBytesIterator, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.FilterLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return &ExampleFeeManagerTestLogBytesIterator{contract: _ExampleFeeManagerTest.contract, event: "log_bytes", logs: logs, sub: sub}, nil
}

// WatchLogBytes is a free log subscription operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) WatchLogBytes(opts *bind.WatchOpts, sink chan<- *ExampleFeeManagerTestLogBytes) (event.Subscription, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.WatchLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleFeeManagerTestLogBytes)
				if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes is a log parse operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) ParseLogBytes(log types.Log) (*ExampleFeeManagerTestLogBytes, error) {
	event := new(ExampleFeeManagerTestLogBytes)
	if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleFeeManagerTestLogBytes32Iterator is returned from FilterLogBytes32 and is used to iterate over the raw logs and unpacked data for LogBytes32 events raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogBytes32Iterator struct {
	Event *ExampleFeeManagerTestLogBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleFeeManagerTestLogBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleFeeManagerTestLogBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleFeeManagerTestLogBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleFeeManagerTestLogBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleFeeManagerTestLogBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleFeeManagerTestLogBytes32 represents a LogBytes32 event raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogBytes32 struct {
	Arg0 [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes32 is a free log retrieval operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) FilterLogBytes32(opts *bind.FilterOpts) (*ExampleFeeManagerTestLogBytes32Iterator, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.FilterLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return &ExampleFeeManagerTestLogBytes32Iterator{contract: _ExampleFeeManagerTest.contract, event: "log_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogBytes32 is a free log subscription operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) WatchLogBytes32(opts *bind.WatchOpts, sink chan<- *ExampleFeeManagerTestLogBytes32) (event.Subscription, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.WatchLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleFeeManagerTestLogBytes32)
				if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes32 is a log parse operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) ParseLogBytes32(log types.Log) (*ExampleFeeManagerTestLogBytes32, error) {
	event := new(ExampleFeeManagerTestLogBytes32)
	if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleFeeManagerTestLogIntIterator is returned from FilterLogInt and is used to iterate over the raw logs and unpacked data for LogInt events raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogIntIterator struct {
	Event *ExampleFeeManagerTestLogInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleFeeManagerTestLogIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleFeeManagerTestLogInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleFeeManagerTestLogInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleFeeManagerTestLogIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleFeeManagerTestLogIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleFeeManagerTestLogInt represents a LogInt event raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogInt struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogInt is a free log retrieval operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) FilterLogInt(opts *bind.FilterOpts) (*ExampleFeeManagerTestLogIntIterator, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.FilterLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return &ExampleFeeManagerTestLogIntIterator{contract: _ExampleFeeManagerTest.contract, event: "log_int", logs: logs, sub: sub}, nil
}

// WatchLogInt is a free log subscription operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) WatchLogInt(opts *bind.WatchOpts, sink chan<- *ExampleFeeManagerTestLogInt) (event.Subscription, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.WatchLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleFeeManagerTestLogInt)
				if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogInt is a log parse operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) ParseLogInt(log types.Log) (*ExampleFeeManagerTestLogInt, error) {
	event := new(ExampleFeeManagerTestLogInt)
	if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_int", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleFeeManagerTestLogNamedAddressIterator is returned from FilterLogNamedAddress and is used to iterate over the raw logs and unpacked data for LogNamedAddress events raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogNamedAddressIterator struct {
	Event *ExampleFeeManagerTestLogNamedAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleFeeManagerTestLogNamedAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleFeeManagerTestLogNamedAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleFeeManagerTestLogNamedAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleFeeManagerTestLogNamedAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleFeeManagerTestLogNamedAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleFeeManagerTestLogNamedAddress represents a LogNamedAddress event raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogNamedAddress struct {
	Key string
	Val common.Address
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedAddress is a free log retrieval operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) FilterLogNamedAddress(opts *bind.FilterOpts) (*ExampleFeeManagerTestLogNamedAddressIterator, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.FilterLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return &ExampleFeeManagerTestLogNamedAddressIterator{contract: _ExampleFeeManagerTest.contract, event: "log_named_address", logs: logs, sub: sub}, nil
}

// WatchLogNamedAddress is a free log subscription operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) WatchLogNamedAddress(opts *bind.WatchOpts, sink chan<- *ExampleFeeManagerTestLogNamedAddress) (event.Subscription, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.WatchLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleFeeManagerTestLogNamedAddress)
				if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedAddress is a log parse operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) ParseLogNamedAddress(log types.Log) (*ExampleFeeManagerTestLogNamedAddress, error) {
	event := new(ExampleFeeManagerTestLogNamedAddress)
	if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleFeeManagerTestLogNamedBytesIterator is returned from FilterLogNamedBytes and is used to iterate over the raw logs and unpacked data for LogNamedBytes events raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogNamedBytesIterator struct {
	Event *ExampleFeeManagerTestLogNamedBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleFeeManagerTestLogNamedBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleFeeManagerTestLogNamedBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleFeeManagerTestLogNamedBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleFeeManagerTestLogNamedBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleFeeManagerTestLogNamedBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleFeeManagerTestLogNamedBytes represents a LogNamedBytes event raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogNamedBytes struct {
	Key string
	Val []byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes is a free log retrieval operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) FilterLogNamedBytes(opts *bind.FilterOpts) (*ExampleFeeManagerTestLogNamedBytesIterator, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.FilterLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return &ExampleFeeManagerTestLogNamedBytesIterator{contract: _ExampleFeeManagerTest.contract, event: "log_named_bytes", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes is a free log subscription operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) WatchLogNamedBytes(opts *bind.WatchOpts, sink chan<- *ExampleFeeManagerTestLogNamedBytes) (event.Subscription, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.WatchLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleFeeManagerTestLogNamedBytes)
				if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes is a log parse operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) ParseLogNamedBytes(log types.Log) (*ExampleFeeManagerTestLogNamedBytes, error) {
	event := new(ExampleFeeManagerTestLogNamedBytes)
	if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleFeeManagerTestLogNamedBytes32Iterator is returned from FilterLogNamedBytes32 and is used to iterate over the raw logs and unpacked data for LogNamedBytes32 events raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogNamedBytes32Iterator struct {
	Event *ExampleFeeManagerTestLogNamedBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleFeeManagerTestLogNamedBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleFeeManagerTestLogNamedBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleFeeManagerTestLogNamedBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleFeeManagerTestLogNamedBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleFeeManagerTestLogNamedBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleFeeManagerTestLogNamedBytes32 represents a LogNamedBytes32 event raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogNamedBytes32 struct {
	Key string
	Val [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes32 is a free log retrieval operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) FilterLogNamedBytes32(opts *bind.FilterOpts) (*ExampleFeeManagerTestLogNamedBytes32Iterator, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.FilterLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return &ExampleFeeManagerTestLogNamedBytes32Iterator{contract: _ExampleFeeManagerTest.contract, event: "log_named_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes32 is a free log subscription operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) WatchLogNamedBytes32(opts *bind.WatchOpts, sink chan<- *ExampleFeeManagerTestLogNamedBytes32) (event.Subscription, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.WatchLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleFeeManagerTestLogNamedBytes32)
				if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes32 is a log parse operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) ParseLogNamedBytes32(log types.Log) (*ExampleFeeManagerTestLogNamedBytes32, error) {
	event := new(ExampleFeeManagerTestLogNamedBytes32)
	if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleFeeManagerTestLogNamedDecimalIntIterator is returned from FilterLogNamedDecimalInt and is used to iterate over the raw logs and unpacked data for LogNamedDecimalInt events raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogNamedDecimalIntIterator struct {
	Event *ExampleFeeManagerTestLogNamedDecimalInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleFeeManagerTestLogNamedDecimalIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleFeeManagerTestLogNamedDecimalInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleFeeManagerTestLogNamedDecimalInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleFeeManagerTestLogNamedDecimalIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleFeeManagerTestLogNamedDecimalIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleFeeManagerTestLogNamedDecimalInt represents a LogNamedDecimalInt event raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogNamedDecimalInt struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalInt is a free log retrieval operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) FilterLogNamedDecimalInt(opts *bind.FilterOpts) (*ExampleFeeManagerTestLogNamedDecimalIntIterator, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.FilterLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return &ExampleFeeManagerTestLogNamedDecimalIntIterator{contract: _ExampleFeeManagerTest.contract, event: "log_named_decimal_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalInt is a free log subscription operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) WatchLogNamedDecimalInt(opts *bind.WatchOpts, sink chan<- *ExampleFeeManagerTestLogNamedDecimalInt) (event.Subscription, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.WatchLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleFeeManagerTestLogNamedDecimalInt)
				if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalInt is a log parse operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) ParseLogNamedDecimalInt(log types.Log) (*ExampleFeeManagerTestLogNamedDecimalInt, error) {
	event := new(ExampleFeeManagerTestLogNamedDecimalInt)
	if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleFeeManagerTestLogNamedDecimalUintIterator is returned from FilterLogNamedDecimalUint and is used to iterate over the raw logs and unpacked data for LogNamedDecimalUint events raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogNamedDecimalUintIterator struct {
	Event *ExampleFeeManagerTestLogNamedDecimalUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleFeeManagerTestLogNamedDecimalUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleFeeManagerTestLogNamedDecimalUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleFeeManagerTestLogNamedDecimalUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleFeeManagerTestLogNamedDecimalUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleFeeManagerTestLogNamedDecimalUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleFeeManagerTestLogNamedDecimalUint represents a LogNamedDecimalUint event raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogNamedDecimalUint struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalUint is a free log retrieval operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) FilterLogNamedDecimalUint(opts *bind.FilterOpts) (*ExampleFeeManagerTestLogNamedDecimalUintIterator, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.FilterLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return &ExampleFeeManagerTestLogNamedDecimalUintIterator{contract: _ExampleFeeManagerTest.contract, event: "log_named_decimal_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalUint is a free log subscription operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) WatchLogNamedDecimalUint(opts *bind.WatchOpts, sink chan<- *ExampleFeeManagerTestLogNamedDecimalUint) (event.Subscription, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.WatchLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleFeeManagerTestLogNamedDecimalUint)
				if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalUint is a log parse operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) ParseLogNamedDecimalUint(log types.Log) (*ExampleFeeManagerTestLogNamedDecimalUint, error) {
	event := new(ExampleFeeManagerTestLogNamedDecimalUint)
	if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleFeeManagerTestLogNamedIntIterator is returned from FilterLogNamedInt and is used to iterate over the raw logs and unpacked data for LogNamedInt events raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogNamedIntIterator struct {
	Event *ExampleFeeManagerTestLogNamedInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleFeeManagerTestLogNamedIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleFeeManagerTestLogNamedInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleFeeManagerTestLogNamedInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleFeeManagerTestLogNamedIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleFeeManagerTestLogNamedIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleFeeManagerTestLogNamedInt represents a LogNamedInt event raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogNamedInt struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedInt is a free log retrieval operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) FilterLogNamedInt(opts *bind.FilterOpts) (*ExampleFeeManagerTestLogNamedIntIterator, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.FilterLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return &ExampleFeeManagerTestLogNamedIntIterator{contract: _ExampleFeeManagerTest.contract, event: "log_named_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedInt is a free log subscription operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) WatchLogNamedInt(opts *bind.WatchOpts, sink chan<- *ExampleFeeManagerTestLogNamedInt) (event.Subscription, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.WatchLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleFeeManagerTestLogNamedInt)
				if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedInt is a log parse operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) ParseLogNamedInt(log types.Log) (*ExampleFeeManagerTestLogNamedInt, error) {
	event := new(ExampleFeeManagerTestLogNamedInt)
	if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleFeeManagerTestLogNamedStringIterator is returned from FilterLogNamedString and is used to iterate over the raw logs and unpacked data for LogNamedString events raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogNamedStringIterator struct {
	Event *ExampleFeeManagerTestLogNamedString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleFeeManagerTestLogNamedStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleFeeManagerTestLogNamedString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleFeeManagerTestLogNamedString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleFeeManagerTestLogNamedStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleFeeManagerTestLogNamedStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleFeeManagerTestLogNamedString represents a LogNamedString event raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogNamedString struct {
	Key string
	Val string
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedString is a free log retrieval operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) FilterLogNamedString(opts *bind.FilterOpts) (*ExampleFeeManagerTestLogNamedStringIterator, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.FilterLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return &ExampleFeeManagerTestLogNamedStringIterator{contract: _ExampleFeeManagerTest.contract, event: "log_named_string", logs: logs, sub: sub}, nil
}

// WatchLogNamedString is a free log subscription operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) WatchLogNamedString(opts *bind.WatchOpts, sink chan<- *ExampleFeeManagerTestLogNamedString) (event.Subscription, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.WatchLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleFeeManagerTestLogNamedString)
				if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedString is a log parse operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) ParseLogNamedString(log types.Log) (*ExampleFeeManagerTestLogNamedString, error) {
	event := new(ExampleFeeManagerTestLogNamedString)
	if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleFeeManagerTestLogNamedUintIterator is returned from FilterLogNamedUint and is used to iterate over the raw logs and unpacked data for LogNamedUint events raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogNamedUintIterator struct {
	Event *ExampleFeeManagerTestLogNamedUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleFeeManagerTestLogNamedUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleFeeManagerTestLogNamedUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleFeeManagerTestLogNamedUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleFeeManagerTestLogNamedUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleFeeManagerTestLogNamedUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleFeeManagerTestLogNamedUint represents a LogNamedUint event raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogNamedUint struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedUint is a free log retrieval operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) FilterLogNamedUint(opts *bind.FilterOpts) (*ExampleFeeManagerTestLogNamedUintIterator, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.FilterLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return &ExampleFeeManagerTestLogNamedUintIterator{contract: _ExampleFeeManagerTest.contract, event: "log_named_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedUint is a free log subscription operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) WatchLogNamedUint(opts *bind.WatchOpts, sink chan<- *ExampleFeeManagerTestLogNamedUint) (event.Subscription, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.WatchLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleFeeManagerTestLogNamedUint)
				if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedUint is a log parse operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) ParseLogNamedUint(log types.Log) (*ExampleFeeManagerTestLogNamedUint, error) {
	event := new(ExampleFeeManagerTestLogNamedUint)
	if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleFeeManagerTestLogStringIterator is returned from FilterLogString and is used to iterate over the raw logs and unpacked data for LogString events raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogStringIterator struct {
	Event *ExampleFeeManagerTestLogString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleFeeManagerTestLogStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleFeeManagerTestLogString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleFeeManagerTestLogString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleFeeManagerTestLogStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleFeeManagerTestLogStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleFeeManagerTestLogString represents a LogString event raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogString struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogString is a free log retrieval operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) FilterLogString(opts *bind.FilterOpts) (*ExampleFeeManagerTestLogStringIterator, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.FilterLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return &ExampleFeeManagerTestLogStringIterator{contract: _ExampleFeeManagerTest.contract, event: "log_string", logs: logs, sub: sub}, nil
}

// WatchLogString is a free log subscription operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) WatchLogString(opts *bind.WatchOpts, sink chan<- *ExampleFeeManagerTestLogString) (event.Subscription, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.WatchLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleFeeManagerTestLogString)
				if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogString is a log parse operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) ParseLogString(log types.Log) (*ExampleFeeManagerTestLogString, error) {
	event := new(ExampleFeeManagerTestLogString)
	if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_string", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleFeeManagerTestLogUintIterator is returned from FilterLogUint and is used to iterate over the raw logs and unpacked data for LogUint events raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogUintIterator struct {
	Event *ExampleFeeManagerTestLogUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleFeeManagerTestLogUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleFeeManagerTestLogUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleFeeManagerTestLogUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleFeeManagerTestLogUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleFeeManagerTestLogUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleFeeManagerTestLogUint represents a LogUint event raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogUint struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogUint is a free log retrieval operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) FilterLogUint(opts *bind.FilterOpts) (*ExampleFeeManagerTestLogUintIterator, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.FilterLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return &ExampleFeeManagerTestLogUintIterator{contract: _ExampleFeeManagerTest.contract, event: "log_uint", logs: logs, sub: sub}, nil
}

// WatchLogUint is a free log subscription operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) WatchLogUint(opts *bind.WatchOpts, sink chan<- *ExampleFeeManagerTestLogUint) (event.Subscription, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.WatchLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleFeeManagerTestLogUint)
				if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogUint is a log parse operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) ParseLogUint(log types.Log) (*ExampleFeeManagerTestLogUint, error) {
	event := new(ExampleFeeManagerTestLogUint)
	if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "log_uint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleFeeManagerTestLogsIterator is returned from FilterLogs and is used to iterate over the raw logs and unpacked data for Logs events raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogsIterator struct {
	Event *ExampleFeeManagerTestLogs // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleFeeManagerTestLogsIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleFeeManagerTestLogs)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleFeeManagerTestLogs)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleFeeManagerTestLogsIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleFeeManagerTestLogsIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleFeeManagerTestLogs represents a Logs event raised by the ExampleFeeManagerTest contract.
type ExampleFeeManagerTestLogs struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogs is a free log retrieval operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) FilterLogs(opts *bind.FilterOpts) (*ExampleFeeManagerTestLogsIterator, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.FilterLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return &ExampleFeeManagerTestLogsIterator{contract: _ExampleFeeManagerTest.contract, event: "logs", logs: logs, sub: sub}, nil
}

// WatchLogs is a free log subscription operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) WatchLogs(opts *bind.WatchOpts, sink chan<- *ExampleFeeManagerTestLogs) (event.Subscription, error) {

	logs, sub, err := _ExampleFeeManagerTest.contract.WatchLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleFeeManagerTestLogs)
				if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "logs", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogs is a log parse operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_ExampleFeeManagerTest *ExampleFeeManagerTestFilterer) ParseLogs(log types.Log) (*ExampleFeeManagerTestLogs, error) {
	event := new(ExampleFeeManagerTestLogs)
	if err := _ExampleFeeManagerTest.contract.UnpackLog(event, "logs", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleRewardManagerMetaData contains all meta data concerning the ExampleRewardManager contract.
var ExampleRewardManagerMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"allowFeeRecipients\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"areFeeRecipientsAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRewardAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setRewardAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x6080604052730200000000000000000000000000000000000004600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555034801561006557600080fd5b5061008261007761008760201b60201c565b61008f60201b60201c565b610153565b600033905090565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b6108f7806101626000396000f3fe608060405234801561001057600080fd5b50600436106100885760003560e01c8063bc1786281161005b578063bc178628146100db578063e915608b146100e5578063f2fde38b14610103578063f6542b2e1461011f57610088565b80630329099f1461008d5780635e00e67914610097578063715018a6146100b35780638da5cb5b146100bd575b600080fd5b61009561013d565b005b6100b160048036038101906100ac919061068a565b6101c9565b005b6100bb610261565b005b6100c5610275565b6040516100d291906106c6565b60405180910390f35b6100e361029e565b005b6100ed61032a565b6040516100fa91906106c6565b60405180910390f35b61011d6004803603810190610118919061068a565b6103c2565b005b610127610445565b60405161013491906106fc565b60405180910390f35b6101456104dd565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630329099f6040518163ffffffff1660e01b8152600401600060405180830381600087803b1580156101af57600080fd5b505af11580156101c3573d6000803e3d6000fd5b50505050565b6101d16104dd565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16635e00e679826040518263ffffffff1660e01b815260040161022c91906106c6565b600060405180830381600087803b15801561024657600080fd5b505af115801561025a573d6000803e3d6000fd5b5050505050565b6102696104dd565b610273600061055b565b565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b6102a66104dd565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663bc1786286040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561031057600080fd5b505af1158015610324573d6000803e3d6000fd5b50505050565b6000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e915608b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610399573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103bd919061072c565b905090565b6103ca6104dd565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603610439576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610430906107dc565b60405180910390fd5b6104428161055b565b50565b6000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f6542b2e6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156104b4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104d89190610828565b905090565b6104e561061f565b73ffffffffffffffffffffffffffffffffffffffff16610503610275565b73ffffffffffffffffffffffffffffffffffffffff1614610559576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610550906108a1565b60405180910390fd5b565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b600033905090565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006106578261062c565b9050919050565b6106678161064c565b811461067257600080fd5b50565b6000813590506106848161065e565b92915050565b6000602082840312156106a05761069f610627565b5b60006106ae84828501610675565b91505092915050565b6106c08161064c565b82525050565b60006020820190506106db60008301846106b7565b92915050565b60008115159050919050565b6106f6816106e1565b82525050565b600060208201905061071160008301846106ed565b92915050565b6000815190506107268161065e565b92915050565b60006020828403121561074257610741610627565b5b600061075084828501610717565b91505092915050565b600082825260208201905092915050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160008201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b60006107c6602683610759565b91506107d18261076a565b604082019050919050565b600060208201905081810360008301526107f5816107b9565b9050919050565b610805816106e1565b811461081057600080fd5b50565b600081519050610822816107fc565b92915050565b60006020828403121561083e5761083d610627565b5b600061084c84828501610813565b91505092915050565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572600082015250565b600061088b602083610759565b915061089682610855565b602082019050919050565b600060208201905081810360008301526108ba8161087e565b905091905056fea264697066735822122036dbb6e8a502bdd627becf3bb780ef117a11a3ed8412d9169fe4f674eb08e21d64736f6c634300081a0033",
}

// ExampleRewardManagerABI is the input ABI used to generate the binding from.
// Deprecated: Use ExampleRewardManagerMetaData.ABI instead.
var ExampleRewardManagerABI = ExampleRewardManagerMetaData.ABI

// ExampleRewardManagerBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use ExampleRewardManagerMetaData.Bin instead.
var ExampleRewardManagerBin = ExampleRewardManagerMetaData.Bin

// DeployExampleRewardManager deploys a new Ethereum contract, binding an instance of ExampleRewardManager to it.
func DeployExampleRewardManager(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ExampleRewardManager, error) {
	parsed, err := ExampleRewardManagerMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(ExampleRewardManagerBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ExampleRewardManager{ExampleRewardManagerCaller: ExampleRewardManagerCaller{contract: contract}, ExampleRewardManagerTransactor: ExampleRewardManagerTransactor{contract: contract}, ExampleRewardManagerFilterer: ExampleRewardManagerFilterer{contract: contract}}, nil
}

// ExampleRewardManager is an auto generated Go binding around an Ethereum contract.
type ExampleRewardManager struct {
	ExampleRewardManagerCaller     // Read-only binding to the contract
	ExampleRewardManagerTransactor // Write-only binding to the contract
	ExampleRewardManagerFilterer   // Log filterer for contract events
}

// ExampleRewardManagerCaller is an auto generated read-only Go binding around an Ethereum contract.
type ExampleRewardManagerCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExampleRewardManagerTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ExampleRewardManagerTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExampleRewardManagerFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ExampleRewardManagerFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExampleRewardManagerSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ExampleRewardManagerSession struct {
	Contract     *ExampleRewardManager // Generic contract binding to set the session for
	CallOpts     bind.CallOpts         // Call options to use throughout this session
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// ExampleRewardManagerCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ExampleRewardManagerCallerSession struct {
	Contract *ExampleRewardManagerCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts               // Call options to use throughout this session
}

// ExampleRewardManagerTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ExampleRewardManagerTransactorSession struct {
	Contract     *ExampleRewardManagerTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts               // Transaction auth options to use throughout this session
}

// ExampleRewardManagerRaw is an auto generated low-level Go binding around an Ethereum contract.
type ExampleRewardManagerRaw struct {
	Contract *ExampleRewardManager // Generic contract binding to access the raw methods on
}

// ExampleRewardManagerCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ExampleRewardManagerCallerRaw struct {
	Contract *ExampleRewardManagerCaller // Generic read-only contract binding to access the raw methods on
}

// ExampleRewardManagerTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ExampleRewardManagerTransactorRaw struct {
	Contract *ExampleRewardManagerTransactor // Generic write-only contract binding to access the raw methods on
}

// NewExampleRewardManager creates a new instance of ExampleRewardManager, bound to a specific deployed contract.
func NewExampleRewardManager(address common.Address, backend bind.ContractBackend) (*ExampleRewardManager, error) {
	contract, err := bindExampleRewardManager(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ExampleRewardManager{ExampleRewardManagerCaller: ExampleRewardManagerCaller{contract: contract}, ExampleRewardManagerTransactor: ExampleRewardManagerTransactor{contract: contract}, ExampleRewardManagerFilterer: ExampleRewardManagerFilterer{contract: contract}}, nil
}

// NewExampleRewardManagerCaller creates a new read-only instance of ExampleRewardManager, bound to a specific deployed contract.
func NewExampleRewardManagerCaller(address common.Address, caller bind.ContractCaller) (*ExampleRewardManagerCaller, error) {
	contract, err := bindExampleRewardManager(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ExampleRewardManagerCaller{contract: contract}, nil
}

// NewExampleRewardManagerTransactor creates a new write-only instance of ExampleRewardManager, bound to a specific deployed contract.
func NewExampleRewardManagerTransactor(address common.Address, transactor bind.ContractTransactor) (*ExampleRewardManagerTransactor, error) {
	contract, err := bindExampleRewardManager(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ExampleRewardManagerTransactor{contract: contract}, nil
}

// NewExampleRewardManagerFilterer creates a new log filterer instance of ExampleRewardManager, bound to a specific deployed contract.
func NewExampleRewardManagerFilterer(address common.Address, filterer bind.ContractFilterer) (*ExampleRewardManagerFilterer, error) {
	contract, err := bindExampleRewardManager(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ExampleRewardManagerFilterer{contract: contract}, nil
}

// bindExampleRewardManager binds a generic wrapper to an already deployed contract.
func bindExampleRewardManager(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ExampleRewardManagerMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ExampleRewardManager *ExampleRewardManagerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ExampleRewardManager.Contract.ExampleRewardManagerCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ExampleRewardManager *ExampleRewardManagerRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleRewardManager.Contract.ExampleRewardManagerTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ExampleRewardManager *ExampleRewardManagerRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ExampleRewardManager.Contract.ExampleRewardManagerTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ExampleRewardManager *ExampleRewardManagerCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ExampleRewardManager.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ExampleRewardManager *ExampleRewardManagerTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleRewardManager.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ExampleRewardManager *ExampleRewardManagerTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ExampleRewardManager.Contract.contract.Transact(opts, method, params...)
}

// AreFeeRecipientsAllowed is a free data retrieval call binding the contract method 0xf6542b2e.
//
// Solidity: function areFeeRecipientsAllowed() view returns(bool)
func (_ExampleRewardManager *ExampleRewardManagerCaller) AreFeeRecipientsAllowed(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _ExampleRewardManager.contract.Call(opts, &out, "areFeeRecipientsAllowed")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// AreFeeRecipientsAllowed is a free data retrieval call binding the contract method 0xf6542b2e.
//
// Solidity: function areFeeRecipientsAllowed() view returns(bool)
func (_ExampleRewardManager *ExampleRewardManagerSession) AreFeeRecipientsAllowed() (bool, error) {
	return _ExampleRewardManager.Contract.AreFeeRecipientsAllowed(&_ExampleRewardManager.CallOpts)
}

// AreFeeRecipientsAllowed is a free data retrieval call binding the contract method 0xf6542b2e.
//
// Solidity: function areFeeRecipientsAllowed() view returns(bool)
func (_ExampleRewardManager *ExampleRewardManagerCallerSession) AreFeeRecipientsAllowed() (bool, error) {
	return _ExampleRewardManager.Contract.AreFeeRecipientsAllowed(&_ExampleRewardManager.CallOpts)
}

// CurrentRewardAddress is a free data retrieval call binding the contract method 0xe915608b.
//
// Solidity: function currentRewardAddress() view returns(address)
func (_ExampleRewardManager *ExampleRewardManagerCaller) CurrentRewardAddress(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ExampleRewardManager.contract.Call(opts, &out, "currentRewardAddress")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// CurrentRewardAddress is a free data retrieval call binding the contract method 0xe915608b.
//
// Solidity: function currentRewardAddress() view returns(address)
func (_ExampleRewardManager *ExampleRewardManagerSession) CurrentRewardAddress() (common.Address, error) {
	return _ExampleRewardManager.Contract.CurrentRewardAddress(&_ExampleRewardManager.CallOpts)
}

// CurrentRewardAddress is a free data retrieval call binding the contract method 0xe915608b.
//
// Solidity: function currentRewardAddress() view returns(address)
func (_ExampleRewardManager *ExampleRewardManagerCallerSession) CurrentRewardAddress() (common.Address, error) {
	return _ExampleRewardManager.Contract.CurrentRewardAddress(&_ExampleRewardManager.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ExampleRewardManager *ExampleRewardManagerCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ExampleRewardManager.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ExampleRewardManager *ExampleRewardManagerSession) Owner() (common.Address, error) {
	return _ExampleRewardManager.Contract.Owner(&_ExampleRewardManager.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ExampleRewardManager *ExampleRewardManagerCallerSession) Owner() (common.Address, error) {
	return _ExampleRewardManager.Contract.Owner(&_ExampleRewardManager.CallOpts)
}

// AllowFeeRecipients is a paid mutator transaction binding the contract method 0x0329099f.
//
// Solidity: function allowFeeRecipients() returns()
func (_ExampleRewardManager *ExampleRewardManagerTransactor) AllowFeeRecipients(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleRewardManager.contract.Transact(opts, "allowFeeRecipients")
}

// AllowFeeRecipients is a paid mutator transaction binding the contract method 0x0329099f.
//
// Solidity: function allowFeeRecipients() returns()
func (_ExampleRewardManager *ExampleRewardManagerSession) AllowFeeRecipients() (*types.Transaction, error) {
	return _ExampleRewardManager.Contract.AllowFeeRecipients(&_ExampleRewardManager.TransactOpts)
}

// AllowFeeRecipients is a paid mutator transaction binding the contract method 0x0329099f.
//
// Solidity: function allowFeeRecipients() returns()
func (_ExampleRewardManager *ExampleRewardManagerTransactorSession) AllowFeeRecipients() (*types.Transaction, error) {
	return _ExampleRewardManager.Contract.AllowFeeRecipients(&_ExampleRewardManager.TransactOpts)
}

// DisableRewards is a paid mutator transaction binding the contract method 0xbc178628.
//
// Solidity: function disableRewards() returns()
func (_ExampleRewardManager *ExampleRewardManagerTransactor) DisableRewards(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleRewardManager.contract.Transact(opts, "disableRewards")
}

// DisableRewards is a paid mutator transaction binding the contract method 0xbc178628.
//
// Solidity: function disableRewards() returns()
func (_ExampleRewardManager *ExampleRewardManagerSession) DisableRewards() (*types.Transaction, error) {
	return _ExampleRewardManager.Contract.DisableRewards(&_ExampleRewardManager.TransactOpts)
}

// DisableRewards is a paid mutator transaction binding the contract method 0xbc178628.
//
// Solidity: function disableRewards() returns()
func (_ExampleRewardManager *ExampleRewardManagerTransactorSession) DisableRewards() (*types.Transaction, error) {
	return _ExampleRewardManager.Contract.DisableRewards(&_ExampleRewardManager.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_ExampleRewardManager *ExampleRewardManagerTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleRewardManager.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_ExampleRewardManager *ExampleRewardManagerSession) RenounceOwnership() (*types.Transaction, error) {
	return _ExampleRewardManager.Contract.RenounceOwnership(&_ExampleRewardManager.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_ExampleRewardManager *ExampleRewardManagerTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _ExampleRewardManager.Contract.RenounceOwnership(&_ExampleRewardManager.TransactOpts)
}

// SetRewardAddress is a paid mutator transaction binding the contract method 0x5e00e679.
//
// Solidity: function setRewardAddress(address addr) returns()
func (_ExampleRewardManager *ExampleRewardManagerTransactor) SetRewardAddress(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _ExampleRewardManager.contract.Transact(opts, "setRewardAddress", addr)
}

// SetRewardAddress is a paid mutator transaction binding the contract method 0x5e00e679.
//
// Solidity: function setRewardAddress(address addr) returns()
func (_ExampleRewardManager *ExampleRewardManagerSession) SetRewardAddress(addr common.Address) (*types.Transaction, error) {
	return _ExampleRewardManager.Contract.SetRewardAddress(&_ExampleRewardManager.TransactOpts, addr)
}

// SetRewardAddress is a paid mutator transaction binding the contract method 0x5e00e679.
//
// Solidity: function setRewardAddress(address addr) returns()
func (_ExampleRewardManager *ExampleRewardManagerTransactorSession) SetRewardAddress(addr common.Address) (*types.Transaction, error) {
	return _ExampleRewardManager.Contract.SetRewardAddress(&_ExampleRewardManager.TransactOpts, addr)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_ExampleRewardManager *ExampleRewardManagerTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _ExampleRewardManager.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_ExampleRewardManager *ExampleRewardManagerSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _ExampleRewardManager.Contract.TransferOwnership(&_ExampleRewardManager.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_ExampleRewardManager *ExampleRewardManagerTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _ExampleRewardManager.Contract.TransferOwnership(&_ExampleRewardManager.TransactOpts, newOwner)
}

// ExampleRewardManagerOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the ExampleRewardManager contract.
type ExampleRewardManagerOwnershipTransferredIterator struct {
	Event *ExampleRewardManagerOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleRewardManagerOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleRewardManagerOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleRewardManagerOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleRewardManagerOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleRewardManagerOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleRewardManagerOwnershipTransferred represents a OwnershipTransferred event raised by the ExampleRewardManager contract.
type ExampleRewardManagerOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_ExampleRewardManager *ExampleRewardManagerFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*ExampleRewardManagerOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _ExampleRewardManager.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &ExampleRewardManagerOwnershipTransferredIterator{contract: _ExampleRewardManager.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_ExampleRewardManager *ExampleRewardManagerFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *ExampleRewardManagerOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _ExampleRewardManager.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleRewardManagerOwnershipTransferred)
				if err := _ExampleRewardManager.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_ExampleRewardManager *ExampleRewardManagerFilterer) ParseOwnershipTransferred(log types.Log) (*ExampleRewardManagerOwnershipTransferred, error) {
	event := new(ExampleRewardManagerOwnershipTransferred)
	if err := _ExampleRewardManager.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleRewardManagerTestMetaData contains all meta data concerning the ExampleRewardManagerTest contract.
var ExampleRewardManagerTestMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"log_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"log_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"log_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"name\":\"log_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"val\",\"type\":\"address\"}],\"name\":\"log_named_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"val\",\"type\":\"bytes\"}],\"name\":\"log_named_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"val\",\"type\":\"bytes32\"}],\"name\":\"log_named_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"}],\"name\":\"log_named_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"val\",\"type\":\"string\"}],\"name\":\"log_named_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"log_named_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"log_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"logs\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"IS_TEST\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"failed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_allowFeeRecipients\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_areFeeRecipientsAllowed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_captureBlackholeBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_checkReceiveFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_checkSendFeesToBlackhole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_disableRewardAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_doesNotSetRewardAddressBeforeEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_receiveFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_setEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_setRewardAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_setupReceiveFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x608060405260016000806101000a81548160ff021916908315150217905550730200000000000000000000000000000000000004600060026101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550348015607e57600080fd5b506127bd8061008e6000396000f3fe608060405234801561001057600080fd5b50600436106100ea5760003560e01c8063b3e60beb1161008c578063c63cc6d911610066578063c63cc6d914610167578063cbc0752614610171578063eb4d27211461017b578063fa7626d414610185576100ea565b8063b3e60beb14610135578063ba414fa61461013f578063c54173e21461015d576100ea565b80630a9254e4116100c85780630a9254e41461010d57806328f9eb8714610117578063671579ec14610121578063b280c3a21461012b576100ea565b806305ac90c9146100ef57806307448f28146100f9578063090b969414610103575b600080fd5b6100f76101a3565b005b6101016103b2565b005b61010b61053f565b005b610115610578565b005b61011f6105ac565b005b610129610752565b005b610133610799565b005b61013d610933565b005b6101476109db565b604051610154919061149c565b60405180910390f35b610165610b78565b005b61016f610bac565b005b610179610d32565b005b610183610fc4565b005b61018d610fc6565b60405161019a919061149c565b60405180910390f35b60006040516101b190611474565b604051809103906000f0801580156101cd573d6000803e3d6000fd5b509050600081905061027b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1836040518263ffffffff1660e01b815260040161023391906114f8565b602060405180830381865afa158015610250573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610274919061154e565b6000610fd7565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043826040518263ffffffff1660e01b81526004016102d691906114f8565b600060405180830381600087803b1580156102f057600080fd5b505af1158015610304573d6000803e3d6000fd5b505050506103ae600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1836040518263ffffffff1660e01b815260040161036691906114f8565b602060405180830381865afa158015610383573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103a7919061154e565b6001610fd7565b5050565b60006040516103c090611474565b604051809103906000f0801580156103dc573d6000803e3d6000fd5b5090506000819050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043826040518263ffffffff1660e01b815260040161043f91906114f8565b600060405180830381600087803b15801561045957600080fd5b505af115801561046d573d6000803e3d6000fd5b505050508173ffffffffffffffffffffffffffffffffffffffff16635e00e679826040518263ffffffff1660e01b81526004016104aa91906114f8565b600060405180830381600087803b1580156104c457600080fd5b505af11580156104d8573d6000803e3d6000fd5b5050505081600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508073ffffffffffffffffffffffffffffffffffffffff16316002819055505050565b61057673010000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1631600354610ff7565b565b73010000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1631600381905550565b60006040516105ba90611474565b604051809103906000f0801580156105d6573d6000803e3d6000fd5b5090506000819050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043826040518263ffffffff1660e01b815260040161063991906114f8565b600060405180830381600087803b15801561065357600080fd5b505af1158015610667573d6000803e3d6000fd5b505050508173ffffffffffffffffffffffffffffffffffffffff16635e00e679826040518263ffffffff1660e01b81526004016106a491906114f8565b600060405180830381600087803b1580156106be57600080fd5b505af11580156106d2573d6000803e3d6000fd5b5050505061074e8273ffffffffffffffffffffffffffffffffffffffff1663e915608b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610724573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061074891906115a7565b826110ae565b5050565b610797600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1631600254610ff7565b565b60006040516107a790611474565b604051809103906000f0801580156107c3573d6000803e3d6000fd5b5090506000819050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043826040518263ffffffff1660e01b815260040161082691906114f8565b600060405180830381600087803b15801561084057600080fd5b505af1158015610854573d6000803e3d6000fd5b505050508173ffffffffffffffffffffffffffffffffffffffff16630329099f6040518163ffffffff1660e01b8152600401600060405180830381600087803b1580156108a057600080fd5b505af11580156108b4573d6000803e3d6000fd5b5050505061092f8273ffffffffffffffffffffffffffffffffffffffff1663f6542b2e6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610906573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061092a9190611600565b611191565b5050565b600060405161094190611474565b604051809103906000f08015801561095d573d6000803e3d6000fd5b5090506109d88173ffffffffffffffffffffffffffffffffffffffff1663f6542b2e6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156109ae573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109d29190611600565b15611191565b50565b60008060019054906101000a900460ff1615610a0857600060019054906101000a900460ff169050610b75565b6000610a126111d7565b15610b705760007f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d60001c60601b60601c73ffffffffffffffffffffffffffffffffffffffff167f667f9d70ca411d70ead50d8d5c22070dafc36ad75f3dcf5e7237b22ade9aecc47f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d60001c60601b60601c7f6661696c65640000000000000000000000000000000000000000000000000000604051602001610ad6929190611646565b604051602081830303815290604052604051602001610af692919061172d565b604051602081830303815290604052604051610b129190611755565b6000604051808303816000865af19150503d8060008114610b4f576040519150601f19603f3d011682016040523d82523d6000602084013e610b54565b606091505b5091505080806020019051810190610b6c9190611600565b9150505b809150505b90565b73010000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1631600381905550565b6000604051610bba90611474565b604051809103906000f080158015610bd6573d6000803e3d6000fd5b5090506000819050610c84600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1836040518263ffffffff1660e01b8152600401610c3c91906114f8565b602060405180830381865afa158015610c59573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c7d919061154e565b6000610fd7565b8173ffffffffffffffffffffffffffffffffffffffff16635e00e679826040518263ffffffff1660e01b8152600401610cbd91906114f8565b600060405180830381600087803b158015610cd757600080fd5b505af1925050508015610ce8575060015b15610d2e57610d2d60006040518060400160405280601c81526020017f736574526577617264416464726573732073686f756c64206661696c00000000815250611200565b5b5050565b6000604051610d4090611474565b604051809103906000f080158015610d5c573d6000803e3d6000fd5b5090506000819050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043826040518263ffffffff1660e01b8152600401610dbf91906114f8565b600060405180830381600087803b158015610dd957600080fd5b505af1158015610ded573d6000803e3d6000fd5b505050508173ffffffffffffffffffffffffffffffffffffffff16635e00e679826040518263ffffffff1660e01b8152600401610e2a91906114f8565b600060405180830381600087803b158015610e4457600080fd5b505af1158015610e58573d6000803e3d6000fd5b50505050610ed48273ffffffffffffffffffffffffffffffffffffffff1663e915608b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610eaa573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ece91906115a7565b826110ae565b8173ffffffffffffffffffffffffffffffffffffffff1663bc1786286040518163ffffffff1660e01b8152600401600060405180830381600087803b158015610f1c57600080fd5b505af1158015610f30573d6000803e3d6000fd5b50505050610fc08273ffffffffffffffffffffffffffffffffffffffff1663e915608b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610f82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fa691906115a7565b7301000000000000000000000000000000000000006110ae565b5050565b565b60008054906101000a900460ff1681565b610ff382826003811115610fee57610fed61176c565b5b61124a565b5050565b8082116110aa577f41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f5060405161102b9061181e565b60405180910390a17fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8826040516110629190611899565b60405180910390a17fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8816040516110999190611913565b60405180910390a16110a9611301565b5b5050565b8073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff161461118d577f41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f5060405161110e906119b3565b60405180910390a17f9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f826040516111459190611a1f565b60405180910390a17f9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f8160405161117c9190611a99565b60405180910390a161118c611301565b5b5050565b806111d4577f41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f506040516111c390611b13565b60405180910390a16111d3611301565b5b50565b60008060009050737109709ecfa91a80626ff3989d68f67f5b1dd12d3b90506000811191505090565b81611246577f280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583816040516112349190611bd4565b60405180910390a161124582611191565b5b5050565b8082146112fd577f41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f5060405161127e90611c7b565b60405180910390a17fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8826040516112b59190611c9b565b60405180910390a17fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8816040516112ec9190611cc9565b60405180910390a16112fc611301565b5b5050565b6113096111d7565b156114575760007f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d60001c60601b60601c73ffffffffffffffffffffffffffffffffffffffff167f70ca10bbd0dbfd9020a9f4b13402c16cb120705e0d1c0aeab10fa353ae586fc47f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d60001c60601b60601c7f6661696c65640000000000000000000000000000000000000000000000000000600160001b6040516020016113d393929190611cf7565b6040516020818303038152906040526040516020016113f392919061172d565b60405160208183030381529060405260405161140f9190611755565b6000604051808303816000865af19150503d806000811461144c576040519150601f19603f3d011682016040523d82523d6000602084013e611451565b606091505b50509050505b6001600060016101000a81548160ff021916908315150217905550565b610a5980611d2f83390190565b60008115159050919050565b61149681611481565b82525050565b60006020820190506114b1600083018461148d565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006114e2826114b7565b9050919050565b6114f2816114d7565b82525050565b600060208201905061150d60008301846114e9565b92915050565b600080fd5b6000819050919050565b61152b81611518565b811461153657600080fd5b50565b60008151905061154881611522565b92915050565b60006020828403121561156457611563611513565b5b600061157284828501611539565b91505092915050565b611584816114d7565b811461158f57600080fd5b50565b6000815190506115a18161157b565b92915050565b6000602082840312156115bd576115bc611513565b5b60006115cb84828501611592565b91505092915050565b6115dd81611481565b81146115e857600080fd5b50565b6000815190506115fa816115d4565b92915050565b60006020828403121561161657611615611513565b5b6000611624848285016115eb565b91505092915050565b6000819050919050565b6116408161162d565b82525050565b600060408201905061165b60008301856114e9565b6116686020830184611637565b9392505050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b6000819050919050565b6116b66116b18261166f565b61169b565b82525050565b600081519050919050565b600081905092915050565b60005b838110156116f05780820151818401526020810190506116d5565b60008484015250505050565b6000611707826116bc565b61171181856116c7565b93506117218185602086016116d2565b80840191505092915050565b600061173982856116a5565b60048201915061174982846116fc565b91508190509392505050565b600061176182846116fc565b915081905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b600082825260208201905092915050565b7f4572726f723a2061203e2062206e6f7420736174697366696564205b75696e7460008201527f5d00000000000000000000000000000000000000000000000000000000000000602082015250565b600061180860218361179b565b9150611813826117ac565b604082019050919050565b60006020820190508181036000830152611837816117fb565b9050919050565b7f202056616c756520610000000000000000000000000000000000000000000000600082015250565b600061187460098361179b565b915061187f8261183e565b602082019050919050565b61189381611518565b82525050565b600060408201905081810360008301526118b281611867565b90506118c1602083018461188a565b92915050565b7f202056616c756520620000000000000000000000000000000000000000000000600082015250565b60006118fd60098361179b565b9150611908826118c7565b602082019050919050565b6000604082019050818103600083015261192c816118f0565b905061193b602083018461188a565b92915050565b7f4572726f723a2061203d3d2062206e6f7420736174697366696564205b61646460008201527f726573735d000000000000000000000000000000000000000000000000000000602082015250565b600061199d60258361179b565b91506119a882611941565b604082019050919050565b600060208201905081810360008301526119cc81611990565b9050919050565b7f2020202020204c65667400000000000000000000000000000000000000000000600082015250565b6000611a09600a8361179b565b9150611a14826119d3565b602082019050919050565b60006040820190508181036000830152611a38816119fc565b9050611a4760208301846114e9565b92915050565b7f2020202020526967687400000000000000000000000000000000000000000000600082015250565b6000611a83600a8361179b565b9150611a8e82611a4d565b602082019050919050565b60006040820190508181036000830152611ab281611a76565b9050611ac160208301846114e9565b92915050565b7f4572726f723a20417373657274696f6e204661696c6564000000000000000000600082015250565b6000611afd60178361179b565b9150611b0882611ac7565b602082019050919050565b60006020820190508181036000830152611b2c81611af0565b9050919050565b7f4572726f72000000000000000000000000000000000000000000000000000000600082015250565b6000611b6960058361179b565b9150611b7482611b33565b602082019050919050565b600081519050919050565b6000601f19601f8301169050919050565b6000611ba682611b7f565b611bb0818561179b565b9350611bc08185602086016116d2565b611bc981611b8a565b840191505092915050565b60006040820190508181036000830152611bed81611b5c565b90508181036020830152611c018184611b9b565b905092915050565b7f4572726f723a2061203d3d2062206e6f7420736174697366696564205b75696e60008201527f745d000000000000000000000000000000000000000000000000000000000000602082015250565b6000611c6560228361179b565b9150611c7082611c09565b604082019050919050565b60006020820190508181036000830152611c9481611c58565b9050919050565b60006040820190508181036000830152611cb4816119fc565b9050611cc3602083018461188a565b92915050565b60006040820190508181036000830152611ce281611a76565b9050611cf1602083018461188a565b92915050565b6000606082019050611d0c60008301866114e9565b611d196020830185611637565b611d266040830184611637565b94935050505056fe6080604052730200000000000000000000000000000000000004600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555034801561006557600080fd5b5061008261007761008760201b60201c565b61008f60201b60201c565b610153565b600033905090565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b6108f7806101626000396000f3fe608060405234801561001057600080fd5b50600436106100885760003560e01c8063bc1786281161005b578063bc178628146100db578063e915608b146100e5578063f2fde38b14610103578063f6542b2e1461011f57610088565b80630329099f1461008d5780635e00e67914610097578063715018a6146100b35780638da5cb5b146100bd575b600080fd5b61009561013d565b005b6100b160048036038101906100ac919061068a565b6101c9565b005b6100bb610261565b005b6100c5610275565b6040516100d291906106c6565b60405180910390f35b6100e361029e565b005b6100ed61032a565b6040516100fa91906106c6565b60405180910390f35b61011d6004803603810190610118919061068a565b6103c2565b005b610127610445565b60405161013491906106fc565b60405180910390f35b6101456104dd565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630329099f6040518163ffffffff1660e01b8152600401600060405180830381600087803b1580156101af57600080fd5b505af11580156101c3573d6000803e3d6000fd5b50505050565b6101d16104dd565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16635e00e679826040518263ffffffff1660e01b815260040161022c91906106c6565b600060405180830381600087803b15801561024657600080fd5b505af115801561025a573d6000803e3d6000fd5b5050505050565b6102696104dd565b610273600061055b565b565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b6102a66104dd565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663bc1786286040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561031057600080fd5b505af1158015610324573d6000803e3d6000fd5b50505050565b6000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663e915608b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610399573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103bd919061072c565b905090565b6103ca6104dd565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603610439576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610430906107dc565b60405180910390fd5b6104428161055b565b50565b6000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663f6542b2e6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156104b4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104d89190610828565b905090565b6104e561061f565b73ffffffffffffffffffffffffffffffffffffffff16610503610275565b73ffffffffffffffffffffffffffffffffffffffff1614610559576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610550906108a1565b60405180910390fd5b565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b600033905090565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006106578261062c565b9050919050565b6106678161064c565b811461067257600080fd5b50565b6000813590506106848161065e565b92915050565b6000602082840312156106a05761069f610627565b5b60006106ae84828501610675565b91505092915050565b6106c08161064c565b82525050565b60006020820190506106db60008301846106b7565b92915050565b60008115159050919050565b6106f6816106e1565b82525050565b600060208201905061071160008301846106ed565b92915050565b6000815190506107268161065e565b92915050565b60006020828403121561074257610741610627565b5b600061075084828501610717565b91505092915050565b600082825260208201905092915050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160008201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b60006107c6602683610759565b91506107d18261076a565b604082019050919050565b600060208201905081810360008301526107f5816107b9565b9050919050565b610805816106e1565b811461081057600080fd5b50565b600081519050610822816107fc565b92915050565b60006020828403121561083e5761083d610627565b5b600061084c84828501610813565b91505092915050565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572600082015250565b600061088b602083610759565b915061089682610855565b602082019050919050565b600060208201905081810360008301526108ba8161087e565b905091905056fea264697066735822122036dbb6e8a502bdd627becf3bb780ef117a11a3ed8412d9169fe4f674eb08e21d64736f6c634300081a0033a2646970667358221220bd6be8518e4f5d490cbf465b187f12235d5439f370d44de81b1de7ca1b819e1664736f6c634300081a0033",
}

// ExampleRewardManagerTestABI is the input ABI used to generate the binding from.
// Deprecated: Use ExampleRewardManagerTestMetaData.ABI instead.
var ExampleRewardManagerTestABI = ExampleRewardManagerTestMetaData.ABI

// ExampleRewardManagerTestBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use ExampleRewardManagerTestMetaData.Bin instead.
var ExampleRewardManagerTestBin = ExampleRewardManagerTestMetaData.Bin

// DeployExampleRewardManagerTest deploys a new Ethereum contract, binding an instance of ExampleRewardManagerTest to it.
func DeployExampleRewardManagerTest(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ExampleRewardManagerTest, error) {
	parsed, err := ExampleRewardManagerTestMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(ExampleRewardManagerTestBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ExampleRewardManagerTest{ExampleRewardManagerTestCaller: ExampleRewardManagerTestCaller{contract: contract}, ExampleRewardManagerTestTransactor: ExampleRewardManagerTestTransactor{contract: contract}, ExampleRewardManagerTestFilterer: ExampleRewardManagerTestFilterer{contract: contract}}, nil
}

// ExampleRewardManagerTest is an auto generated Go binding around an Ethereum contract.
type ExampleRewardManagerTest struct {
	ExampleRewardManagerTestCaller     // Read-only binding to the contract
	ExampleRewardManagerTestTransactor // Write-only binding to the contract
	ExampleRewardManagerTestFilterer   // Log filterer for contract events
}

// ExampleRewardManagerTestCaller is an auto generated read-only Go binding around an Ethereum contract.
type ExampleRewardManagerTestCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExampleRewardManagerTestTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ExampleRewardManagerTestTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExampleRewardManagerTestFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ExampleRewardManagerTestFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExampleRewardManagerTestSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ExampleRewardManagerTestSession struct {
	Contract     *ExampleRewardManagerTest // Generic contract binding to set the session for
	CallOpts     bind.CallOpts             // Call options to use throughout this session
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// ExampleRewardManagerTestCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ExampleRewardManagerTestCallerSession struct {
	Contract *ExampleRewardManagerTestCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts                   // Call options to use throughout this session
}

// ExampleRewardManagerTestTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ExampleRewardManagerTestTransactorSession struct {
	Contract     *ExampleRewardManagerTestTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts                   // Transaction auth options to use throughout this session
}

// ExampleRewardManagerTestRaw is an auto generated low-level Go binding around an Ethereum contract.
type ExampleRewardManagerTestRaw struct {
	Contract *ExampleRewardManagerTest // Generic contract binding to access the raw methods on
}

// ExampleRewardManagerTestCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ExampleRewardManagerTestCallerRaw struct {
	Contract *ExampleRewardManagerTestCaller // Generic read-only contract binding to access the raw methods on
}

// ExampleRewardManagerTestTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ExampleRewardManagerTestTransactorRaw struct {
	Contract *ExampleRewardManagerTestTransactor // Generic write-only contract binding to access the raw methods on
}

// NewExampleRewardManagerTest creates a new instance of ExampleRewardManagerTest, bound to a specific deployed contract.
func NewExampleRewardManagerTest(address common.Address, backend bind.ContractBackend) (*ExampleRewardManagerTest, error) {
	contract, err := bindExampleRewardManagerTest(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ExampleRewardManagerTest{ExampleRewardManagerTestCaller: ExampleRewardManagerTestCaller{contract: contract}, ExampleRewardManagerTestTransactor: ExampleRewardManagerTestTransactor{contract: contract}, ExampleRewardManagerTestFilterer: ExampleRewardManagerTestFilterer{contract: contract}}, nil
}

// NewExampleRewardManagerTestCaller creates a new read-only instance of ExampleRewardManagerTest, bound to a specific deployed contract.
func NewExampleRewardManagerTestCaller(address common.Address, caller bind.ContractCaller) (*ExampleRewardManagerTestCaller, error) {
	contract, err := bindExampleRewardManagerTest(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ExampleRewardManagerTestCaller{contract: contract}, nil
}

// NewExampleRewardManagerTestTransactor creates a new write-only instance of ExampleRewardManagerTest, bound to a specific deployed contract.
func NewExampleRewardManagerTestTransactor(address common.Address, transactor bind.ContractTransactor) (*ExampleRewardManagerTestTransactor, error) {
	contract, err := bindExampleRewardManagerTest(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ExampleRewardManagerTestTransactor{contract: contract}, nil
}

// NewExampleRewardManagerTestFilterer creates a new log filterer instance of ExampleRewardManagerTest, bound to a specific deployed contract.
func NewExampleRewardManagerTestFilterer(address common.Address, filterer bind.ContractFilterer) (*ExampleRewardManagerTestFilterer, error) {
	contract, err := bindExampleRewardManagerTest(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ExampleRewardManagerTestFilterer{contract: contract}, nil
}

// bindExampleRewardManagerTest binds a generic wrapper to an already deployed contract.
func bindExampleRewardManagerTest(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ExampleRewardManagerTestMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ExampleRewardManagerTest *ExampleRewardManagerTestRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ExampleRewardManagerTest.Contract.ExampleRewardManagerTestCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ExampleRewardManagerTest *ExampleRewardManagerTestRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.ExampleRewardManagerTestTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ExampleRewardManagerTest *ExampleRewardManagerTestRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.ExampleRewardManagerTestTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ExampleRewardManagerTest *ExampleRewardManagerTestCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ExampleRewardManagerTest.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.contract.Transact(opts, method, params...)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestCaller) ISTEST(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _ExampleRewardManagerTest.contract.Call(opts, &out, "IS_TEST")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestSession) ISTEST() (bool, error) {
	return _ExampleRewardManagerTest.Contract.ISTEST(&_ExampleRewardManagerTest.CallOpts)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestCallerSession) ISTEST() (bool, error) {
	return _ExampleRewardManagerTest.Contract.ISTEST(&_ExampleRewardManagerTest.CallOpts)
}

// Failed is a paid mutator transaction binding the contract method 0xba414fa6.
//
// Solidity: function failed() returns(bool)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactor) Failed(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleRewardManagerTest.contract.Transact(opts, "failed")
}

// Failed is a paid mutator transaction binding the contract method 0xba414fa6.
//
// Solidity: function failed() returns(bool)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestSession) Failed() (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.Failed(&_ExampleRewardManagerTest.TransactOpts)
}

// Failed is a paid mutator transaction binding the contract method 0xba414fa6.
//
// Solidity: function failed() returns(bool)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactorSession) Failed() (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.Failed(&_ExampleRewardManagerTest.TransactOpts)
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactor) SetUp(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleRewardManagerTest.contract.Transact(opts, "setUp")
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestSession) SetUp() (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.SetUp(&_ExampleRewardManagerTest.TransactOpts)
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactorSession) SetUp() (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.SetUp(&_ExampleRewardManagerTest.TransactOpts)
}

// StepAllowFeeRecipients is a paid mutator transaction binding the contract method 0xb280c3a2.
//
// Solidity: function step_allowFeeRecipients() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactor) StepAllowFeeRecipients(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleRewardManagerTest.contract.Transact(opts, "step_allowFeeRecipients")
}

// StepAllowFeeRecipients is a paid mutator transaction binding the contract method 0xb280c3a2.
//
// Solidity: function step_allowFeeRecipients() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestSession) StepAllowFeeRecipients() (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.StepAllowFeeRecipients(&_ExampleRewardManagerTest.TransactOpts)
}

// StepAllowFeeRecipients is a paid mutator transaction binding the contract method 0xb280c3a2.
//
// Solidity: function step_allowFeeRecipients() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactorSession) StepAllowFeeRecipients() (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.StepAllowFeeRecipients(&_ExampleRewardManagerTest.TransactOpts)
}

// StepAreFeeRecipientsAllowed is a paid mutator transaction binding the contract method 0xb3e60beb.
//
// Solidity: function step_areFeeRecipientsAllowed() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactor) StepAreFeeRecipientsAllowed(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleRewardManagerTest.contract.Transact(opts, "step_areFeeRecipientsAllowed")
}

// StepAreFeeRecipientsAllowed is a paid mutator transaction binding the contract method 0xb3e60beb.
//
// Solidity: function step_areFeeRecipientsAllowed() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestSession) StepAreFeeRecipientsAllowed() (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.StepAreFeeRecipientsAllowed(&_ExampleRewardManagerTest.TransactOpts)
}

// StepAreFeeRecipientsAllowed is a paid mutator transaction binding the contract method 0xb3e60beb.
//
// Solidity: function step_areFeeRecipientsAllowed() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactorSession) StepAreFeeRecipientsAllowed() (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.StepAreFeeRecipientsAllowed(&_ExampleRewardManagerTest.TransactOpts)
}

// StepCaptureBlackholeBalance is a paid mutator transaction binding the contract method 0xc54173e2.
//
// Solidity: function step_captureBlackholeBalance() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactor) StepCaptureBlackholeBalance(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleRewardManagerTest.contract.Transact(opts, "step_captureBlackholeBalance")
}

// StepCaptureBlackholeBalance is a paid mutator transaction binding the contract method 0xc54173e2.
//
// Solidity: function step_captureBlackholeBalance() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestSession) StepCaptureBlackholeBalance() (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.StepCaptureBlackholeBalance(&_ExampleRewardManagerTest.TransactOpts)
}

// StepCaptureBlackholeBalance is a paid mutator transaction binding the contract method 0xc54173e2.
//
// Solidity: function step_captureBlackholeBalance() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactorSession) StepCaptureBlackholeBalance() (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.StepCaptureBlackholeBalance(&_ExampleRewardManagerTest.TransactOpts)
}

// StepCheckReceiveFees is a paid mutator transaction binding the contract method 0x671579ec.
//
// Solidity: function step_checkReceiveFees() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactor) StepCheckReceiveFees(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleRewardManagerTest.contract.Transact(opts, "step_checkReceiveFees")
}

// StepCheckReceiveFees is a paid mutator transaction binding the contract method 0x671579ec.
//
// Solidity: function step_checkReceiveFees() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestSession) StepCheckReceiveFees() (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.StepCheckReceiveFees(&_ExampleRewardManagerTest.TransactOpts)
}

// StepCheckReceiveFees is a paid mutator transaction binding the contract method 0x671579ec.
//
// Solidity: function step_checkReceiveFees() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactorSession) StepCheckReceiveFees() (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.StepCheckReceiveFees(&_ExampleRewardManagerTest.TransactOpts)
}

// StepCheckSendFeesToBlackhole is a paid mutator transaction binding the contract method 0x090b9694.
//
// Solidity: function step_checkSendFeesToBlackhole() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactor) StepCheckSendFeesToBlackhole(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleRewardManagerTest.contract.Transact(opts, "step_checkSendFeesToBlackhole")
}

// StepCheckSendFeesToBlackhole is a paid mutator transaction binding the contract method 0x090b9694.
//
// Solidity: function step_checkSendFeesToBlackhole() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestSession) StepCheckSendFeesToBlackhole() (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.StepCheckSendFeesToBlackhole(&_ExampleRewardManagerTest.TransactOpts)
}

// StepCheckSendFeesToBlackhole is a paid mutator transaction binding the contract method 0x090b9694.
//
// Solidity: function step_checkSendFeesToBlackhole() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactorSession) StepCheckSendFeesToBlackhole() (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.StepCheckSendFeesToBlackhole(&_ExampleRewardManagerTest.TransactOpts)
}

// StepDisableRewardAddress is a paid mutator transaction binding the contract method 0xcbc07526.
//
// Solidity: function step_disableRewardAddress() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactor) StepDisableRewardAddress(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleRewardManagerTest.contract.Transact(opts, "step_disableRewardAddress")
}

// StepDisableRewardAddress is a paid mutator transaction binding the contract method 0xcbc07526.
//
// Solidity: function step_disableRewardAddress() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestSession) StepDisableRewardAddress() (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.StepDisableRewardAddress(&_ExampleRewardManagerTest.TransactOpts)
}

// StepDisableRewardAddress is a paid mutator transaction binding the contract method 0xcbc07526.
//
// Solidity: function step_disableRewardAddress() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactorSession) StepDisableRewardAddress() (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.StepDisableRewardAddress(&_ExampleRewardManagerTest.TransactOpts)
}

// StepDoesNotSetRewardAddressBeforeEnabled is a paid mutator transaction binding the contract method 0xc63cc6d9.
//
// Solidity: function step_doesNotSetRewardAddressBeforeEnabled() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactor) StepDoesNotSetRewardAddressBeforeEnabled(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleRewardManagerTest.contract.Transact(opts, "step_doesNotSetRewardAddressBeforeEnabled")
}

// StepDoesNotSetRewardAddressBeforeEnabled is a paid mutator transaction binding the contract method 0xc63cc6d9.
//
// Solidity: function step_doesNotSetRewardAddressBeforeEnabled() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestSession) StepDoesNotSetRewardAddressBeforeEnabled() (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.StepDoesNotSetRewardAddressBeforeEnabled(&_ExampleRewardManagerTest.TransactOpts)
}

// StepDoesNotSetRewardAddressBeforeEnabled is a paid mutator transaction binding the contract method 0xc63cc6d9.
//
// Solidity: function step_doesNotSetRewardAddressBeforeEnabled() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactorSession) StepDoesNotSetRewardAddressBeforeEnabled() (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.StepDoesNotSetRewardAddressBeforeEnabled(&_ExampleRewardManagerTest.TransactOpts)
}

// StepReceiveFees is a paid mutator transaction binding the contract method 0xeb4d2721.
//
// Solidity: function step_receiveFees() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactor) StepReceiveFees(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleRewardManagerTest.contract.Transact(opts, "step_receiveFees")
}

// StepReceiveFees is a paid mutator transaction binding the contract method 0xeb4d2721.
//
// Solidity: function step_receiveFees() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestSession) StepReceiveFees() (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.StepReceiveFees(&_ExampleRewardManagerTest.TransactOpts)
}

// StepReceiveFees is a paid mutator transaction binding the contract method 0xeb4d2721.
//
// Solidity: function step_receiveFees() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactorSession) StepReceiveFees() (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.StepReceiveFees(&_ExampleRewardManagerTest.TransactOpts)
}

// StepSetEnabled is a paid mutator transaction binding the contract method 0x05ac90c9.
//
// Solidity: function step_setEnabled() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactor) StepSetEnabled(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleRewardManagerTest.contract.Transact(opts, "step_setEnabled")
}

// StepSetEnabled is a paid mutator transaction binding the contract method 0x05ac90c9.
//
// Solidity: function step_setEnabled() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestSession) StepSetEnabled() (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.StepSetEnabled(&_ExampleRewardManagerTest.TransactOpts)
}

// StepSetEnabled is a paid mutator transaction binding the contract method 0x05ac90c9.
//
// Solidity: function step_setEnabled() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactorSession) StepSetEnabled() (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.StepSetEnabled(&_ExampleRewardManagerTest.TransactOpts)
}

// StepSetRewardAddress is a paid mutator transaction binding the contract method 0x28f9eb87.
//
// Solidity: function step_setRewardAddress() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactor) StepSetRewardAddress(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleRewardManagerTest.contract.Transact(opts, "step_setRewardAddress")
}

// StepSetRewardAddress is a paid mutator transaction binding the contract method 0x28f9eb87.
//
// Solidity: function step_setRewardAddress() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestSession) StepSetRewardAddress() (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.StepSetRewardAddress(&_ExampleRewardManagerTest.TransactOpts)
}

// StepSetRewardAddress is a paid mutator transaction binding the contract method 0x28f9eb87.
//
// Solidity: function step_setRewardAddress() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactorSession) StepSetRewardAddress() (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.StepSetRewardAddress(&_ExampleRewardManagerTest.TransactOpts)
}

// StepSetupReceiveFees is a paid mutator transaction binding the contract method 0x07448f28.
//
// Solidity: function step_setupReceiveFees() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactor) StepSetupReceiveFees(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleRewardManagerTest.contract.Transact(opts, "step_setupReceiveFees")
}

// StepSetupReceiveFees is a paid mutator transaction binding the contract method 0x07448f28.
//
// Solidity: function step_setupReceiveFees() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestSession) StepSetupReceiveFees() (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.StepSetupReceiveFees(&_ExampleRewardManagerTest.TransactOpts)
}

// StepSetupReceiveFees is a paid mutator transaction binding the contract method 0x07448f28.
//
// Solidity: function step_setupReceiveFees() returns()
func (_ExampleRewardManagerTest *ExampleRewardManagerTestTransactorSession) StepSetupReceiveFees() (*types.Transaction, error) {
	return _ExampleRewardManagerTest.Contract.StepSetupReceiveFees(&_ExampleRewardManagerTest.TransactOpts)
}

// ExampleRewardManagerTestLogIterator is returned from FilterLog and is used to iterate over the raw logs and unpacked data for Log events raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogIterator struct {
	Event *ExampleRewardManagerTestLog // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleRewardManagerTestLogIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleRewardManagerTestLog)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleRewardManagerTestLog)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleRewardManagerTestLogIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleRewardManagerTestLogIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleRewardManagerTestLog represents a Log event raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLog struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLog is a free log retrieval operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) FilterLog(opts *bind.FilterOpts) (*ExampleRewardManagerTestLogIterator, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.FilterLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return &ExampleRewardManagerTestLogIterator{contract: _ExampleRewardManagerTest.contract, event: "log", logs: logs, sub: sub}, nil
}

// WatchLog is a free log subscription operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) WatchLog(opts *bind.WatchOpts, sink chan<- *ExampleRewardManagerTestLog) (event.Subscription, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.WatchLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleRewardManagerTestLog)
				if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLog is a log parse operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) ParseLog(log types.Log) (*ExampleRewardManagerTestLog, error) {
	event := new(ExampleRewardManagerTestLog)
	if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleRewardManagerTestLogAddressIterator is returned from FilterLogAddress and is used to iterate over the raw logs and unpacked data for LogAddress events raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogAddressIterator struct {
	Event *ExampleRewardManagerTestLogAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleRewardManagerTestLogAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleRewardManagerTestLogAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleRewardManagerTestLogAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleRewardManagerTestLogAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleRewardManagerTestLogAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleRewardManagerTestLogAddress represents a LogAddress event raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogAddress struct {
	Arg0 common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogAddress is a free log retrieval operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) FilterLogAddress(opts *bind.FilterOpts) (*ExampleRewardManagerTestLogAddressIterator, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.FilterLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return &ExampleRewardManagerTestLogAddressIterator{contract: _ExampleRewardManagerTest.contract, event: "log_address", logs: logs, sub: sub}, nil
}

// WatchLogAddress is a free log subscription operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) WatchLogAddress(opts *bind.WatchOpts, sink chan<- *ExampleRewardManagerTestLogAddress) (event.Subscription, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.WatchLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleRewardManagerTestLogAddress)
				if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogAddress is a log parse operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) ParseLogAddress(log types.Log) (*ExampleRewardManagerTestLogAddress, error) {
	event := new(ExampleRewardManagerTestLogAddress)
	if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_address", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleRewardManagerTestLogBytesIterator is returned from FilterLogBytes and is used to iterate over the raw logs and unpacked data for LogBytes events raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogBytesIterator struct {
	Event *ExampleRewardManagerTestLogBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleRewardManagerTestLogBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleRewardManagerTestLogBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleRewardManagerTestLogBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleRewardManagerTestLogBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleRewardManagerTestLogBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleRewardManagerTestLogBytes represents a LogBytes event raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogBytes struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes is a free log retrieval operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) FilterLogBytes(opts *bind.FilterOpts) (*ExampleRewardManagerTestLogBytesIterator, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.FilterLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return &ExampleRewardManagerTestLogBytesIterator{contract: _ExampleRewardManagerTest.contract, event: "log_bytes", logs: logs, sub: sub}, nil
}

// WatchLogBytes is a free log subscription operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) WatchLogBytes(opts *bind.WatchOpts, sink chan<- *ExampleRewardManagerTestLogBytes) (event.Subscription, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.WatchLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleRewardManagerTestLogBytes)
				if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes is a log parse operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) ParseLogBytes(log types.Log) (*ExampleRewardManagerTestLogBytes, error) {
	event := new(ExampleRewardManagerTestLogBytes)
	if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleRewardManagerTestLogBytes32Iterator is returned from FilterLogBytes32 and is used to iterate over the raw logs and unpacked data for LogBytes32 events raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogBytes32Iterator struct {
	Event *ExampleRewardManagerTestLogBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleRewardManagerTestLogBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleRewardManagerTestLogBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleRewardManagerTestLogBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleRewardManagerTestLogBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleRewardManagerTestLogBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleRewardManagerTestLogBytes32 represents a LogBytes32 event raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogBytes32 struct {
	Arg0 [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes32 is a free log retrieval operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) FilterLogBytes32(opts *bind.FilterOpts) (*ExampleRewardManagerTestLogBytes32Iterator, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.FilterLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return &ExampleRewardManagerTestLogBytes32Iterator{contract: _ExampleRewardManagerTest.contract, event: "log_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogBytes32 is a free log subscription operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) WatchLogBytes32(opts *bind.WatchOpts, sink chan<- *ExampleRewardManagerTestLogBytes32) (event.Subscription, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.WatchLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleRewardManagerTestLogBytes32)
				if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes32 is a log parse operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) ParseLogBytes32(log types.Log) (*ExampleRewardManagerTestLogBytes32, error) {
	event := new(ExampleRewardManagerTestLogBytes32)
	if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleRewardManagerTestLogIntIterator is returned from FilterLogInt and is used to iterate over the raw logs and unpacked data for LogInt events raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogIntIterator struct {
	Event *ExampleRewardManagerTestLogInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleRewardManagerTestLogIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleRewardManagerTestLogInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleRewardManagerTestLogInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleRewardManagerTestLogIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleRewardManagerTestLogIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleRewardManagerTestLogInt represents a LogInt event raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogInt struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogInt is a free log retrieval operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) FilterLogInt(opts *bind.FilterOpts) (*ExampleRewardManagerTestLogIntIterator, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.FilterLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return &ExampleRewardManagerTestLogIntIterator{contract: _ExampleRewardManagerTest.contract, event: "log_int", logs: logs, sub: sub}, nil
}

// WatchLogInt is a free log subscription operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) WatchLogInt(opts *bind.WatchOpts, sink chan<- *ExampleRewardManagerTestLogInt) (event.Subscription, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.WatchLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleRewardManagerTestLogInt)
				if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogInt is a log parse operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) ParseLogInt(log types.Log) (*ExampleRewardManagerTestLogInt, error) {
	event := new(ExampleRewardManagerTestLogInt)
	if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_int", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleRewardManagerTestLogNamedAddressIterator is returned from FilterLogNamedAddress and is used to iterate over the raw logs and unpacked data for LogNamedAddress events raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogNamedAddressIterator struct {
	Event *ExampleRewardManagerTestLogNamedAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleRewardManagerTestLogNamedAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleRewardManagerTestLogNamedAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleRewardManagerTestLogNamedAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleRewardManagerTestLogNamedAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleRewardManagerTestLogNamedAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleRewardManagerTestLogNamedAddress represents a LogNamedAddress event raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogNamedAddress struct {
	Key string
	Val common.Address
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedAddress is a free log retrieval operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) FilterLogNamedAddress(opts *bind.FilterOpts) (*ExampleRewardManagerTestLogNamedAddressIterator, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.FilterLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return &ExampleRewardManagerTestLogNamedAddressIterator{contract: _ExampleRewardManagerTest.contract, event: "log_named_address", logs: logs, sub: sub}, nil
}

// WatchLogNamedAddress is a free log subscription operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) WatchLogNamedAddress(opts *bind.WatchOpts, sink chan<- *ExampleRewardManagerTestLogNamedAddress) (event.Subscription, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.WatchLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleRewardManagerTestLogNamedAddress)
				if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedAddress is a log parse operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) ParseLogNamedAddress(log types.Log) (*ExampleRewardManagerTestLogNamedAddress, error) {
	event := new(ExampleRewardManagerTestLogNamedAddress)
	if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleRewardManagerTestLogNamedBytesIterator is returned from FilterLogNamedBytes and is used to iterate over the raw logs and unpacked data for LogNamedBytes events raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogNamedBytesIterator struct {
	Event *ExampleRewardManagerTestLogNamedBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleRewardManagerTestLogNamedBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleRewardManagerTestLogNamedBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleRewardManagerTestLogNamedBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleRewardManagerTestLogNamedBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleRewardManagerTestLogNamedBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleRewardManagerTestLogNamedBytes represents a LogNamedBytes event raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogNamedBytes struct {
	Key string
	Val []byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes is a free log retrieval operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) FilterLogNamedBytes(opts *bind.FilterOpts) (*ExampleRewardManagerTestLogNamedBytesIterator, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.FilterLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return &ExampleRewardManagerTestLogNamedBytesIterator{contract: _ExampleRewardManagerTest.contract, event: "log_named_bytes", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes is a free log subscription operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) WatchLogNamedBytes(opts *bind.WatchOpts, sink chan<- *ExampleRewardManagerTestLogNamedBytes) (event.Subscription, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.WatchLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleRewardManagerTestLogNamedBytes)
				if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes is a log parse operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) ParseLogNamedBytes(log types.Log) (*ExampleRewardManagerTestLogNamedBytes, error) {
	event := new(ExampleRewardManagerTestLogNamedBytes)
	if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleRewardManagerTestLogNamedBytes32Iterator is returned from FilterLogNamedBytes32 and is used to iterate over the raw logs and unpacked data for LogNamedBytes32 events raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogNamedBytes32Iterator struct {
	Event *ExampleRewardManagerTestLogNamedBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleRewardManagerTestLogNamedBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleRewardManagerTestLogNamedBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleRewardManagerTestLogNamedBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleRewardManagerTestLogNamedBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleRewardManagerTestLogNamedBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleRewardManagerTestLogNamedBytes32 represents a LogNamedBytes32 event raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogNamedBytes32 struct {
	Key string
	Val [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes32 is a free log retrieval operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) FilterLogNamedBytes32(opts *bind.FilterOpts) (*ExampleRewardManagerTestLogNamedBytes32Iterator, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.FilterLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return &ExampleRewardManagerTestLogNamedBytes32Iterator{contract: _ExampleRewardManagerTest.contract, event: "log_named_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes32 is a free log subscription operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) WatchLogNamedBytes32(opts *bind.WatchOpts, sink chan<- *ExampleRewardManagerTestLogNamedBytes32) (event.Subscription, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.WatchLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleRewardManagerTestLogNamedBytes32)
				if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes32 is a log parse operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) ParseLogNamedBytes32(log types.Log) (*ExampleRewardManagerTestLogNamedBytes32, error) {
	event := new(ExampleRewardManagerTestLogNamedBytes32)
	if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleRewardManagerTestLogNamedDecimalIntIterator is returned from FilterLogNamedDecimalInt and is used to iterate over the raw logs and unpacked data for LogNamedDecimalInt events raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogNamedDecimalIntIterator struct {
	Event *ExampleRewardManagerTestLogNamedDecimalInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleRewardManagerTestLogNamedDecimalIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleRewardManagerTestLogNamedDecimalInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleRewardManagerTestLogNamedDecimalInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleRewardManagerTestLogNamedDecimalIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleRewardManagerTestLogNamedDecimalIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleRewardManagerTestLogNamedDecimalInt represents a LogNamedDecimalInt event raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogNamedDecimalInt struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalInt is a free log retrieval operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) FilterLogNamedDecimalInt(opts *bind.FilterOpts) (*ExampleRewardManagerTestLogNamedDecimalIntIterator, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.FilterLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return &ExampleRewardManagerTestLogNamedDecimalIntIterator{contract: _ExampleRewardManagerTest.contract, event: "log_named_decimal_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalInt is a free log subscription operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) WatchLogNamedDecimalInt(opts *bind.WatchOpts, sink chan<- *ExampleRewardManagerTestLogNamedDecimalInt) (event.Subscription, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.WatchLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleRewardManagerTestLogNamedDecimalInt)
				if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalInt is a log parse operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) ParseLogNamedDecimalInt(log types.Log) (*ExampleRewardManagerTestLogNamedDecimalInt, error) {
	event := new(ExampleRewardManagerTestLogNamedDecimalInt)
	if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleRewardManagerTestLogNamedDecimalUintIterator is returned from FilterLogNamedDecimalUint and is used to iterate over the raw logs and unpacked data for LogNamedDecimalUint events raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogNamedDecimalUintIterator struct {
	Event *ExampleRewardManagerTestLogNamedDecimalUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleRewardManagerTestLogNamedDecimalUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleRewardManagerTestLogNamedDecimalUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleRewardManagerTestLogNamedDecimalUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleRewardManagerTestLogNamedDecimalUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleRewardManagerTestLogNamedDecimalUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleRewardManagerTestLogNamedDecimalUint represents a LogNamedDecimalUint event raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogNamedDecimalUint struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalUint is a free log retrieval operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) FilterLogNamedDecimalUint(opts *bind.FilterOpts) (*ExampleRewardManagerTestLogNamedDecimalUintIterator, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.FilterLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return &ExampleRewardManagerTestLogNamedDecimalUintIterator{contract: _ExampleRewardManagerTest.contract, event: "log_named_decimal_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalUint is a free log subscription operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) WatchLogNamedDecimalUint(opts *bind.WatchOpts, sink chan<- *ExampleRewardManagerTestLogNamedDecimalUint) (event.Subscription, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.WatchLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleRewardManagerTestLogNamedDecimalUint)
				if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalUint is a log parse operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) ParseLogNamedDecimalUint(log types.Log) (*ExampleRewardManagerTestLogNamedDecimalUint, error) {
	event := new(ExampleRewardManagerTestLogNamedDecimalUint)
	if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleRewardManagerTestLogNamedIntIterator is returned from FilterLogNamedInt and is used to iterate over the raw logs and unpacked data for LogNamedInt events raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogNamedIntIterator struct {
	Event *ExampleRewardManagerTestLogNamedInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleRewardManagerTestLogNamedIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleRewardManagerTestLogNamedInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleRewardManagerTestLogNamedInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleRewardManagerTestLogNamedIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleRewardManagerTestLogNamedIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleRewardManagerTestLogNamedInt represents a LogNamedInt event raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogNamedInt struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedInt is a free log retrieval operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) FilterLogNamedInt(opts *bind.FilterOpts) (*ExampleRewardManagerTestLogNamedIntIterator, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.FilterLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return &ExampleRewardManagerTestLogNamedIntIterator{contract: _ExampleRewardManagerTest.contract, event: "log_named_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedInt is a free log subscription operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) WatchLogNamedInt(opts *bind.WatchOpts, sink chan<- *ExampleRewardManagerTestLogNamedInt) (event.Subscription, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.WatchLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleRewardManagerTestLogNamedInt)
				if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedInt is a log parse operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) ParseLogNamedInt(log types.Log) (*ExampleRewardManagerTestLogNamedInt, error) {
	event := new(ExampleRewardManagerTestLogNamedInt)
	if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleRewardManagerTestLogNamedStringIterator is returned from FilterLogNamedString and is used to iterate over the raw logs and unpacked data for LogNamedString events raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogNamedStringIterator struct {
	Event *ExampleRewardManagerTestLogNamedString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleRewardManagerTestLogNamedStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleRewardManagerTestLogNamedString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleRewardManagerTestLogNamedString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleRewardManagerTestLogNamedStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleRewardManagerTestLogNamedStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleRewardManagerTestLogNamedString represents a LogNamedString event raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogNamedString struct {
	Key string
	Val string
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedString is a free log retrieval operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) FilterLogNamedString(opts *bind.FilterOpts) (*ExampleRewardManagerTestLogNamedStringIterator, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.FilterLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return &ExampleRewardManagerTestLogNamedStringIterator{contract: _ExampleRewardManagerTest.contract, event: "log_named_string", logs: logs, sub: sub}, nil
}

// WatchLogNamedString is a free log subscription operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) WatchLogNamedString(opts *bind.WatchOpts, sink chan<- *ExampleRewardManagerTestLogNamedString) (event.Subscription, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.WatchLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleRewardManagerTestLogNamedString)
				if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedString is a log parse operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) ParseLogNamedString(log types.Log) (*ExampleRewardManagerTestLogNamedString, error) {
	event := new(ExampleRewardManagerTestLogNamedString)
	if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleRewardManagerTestLogNamedUintIterator is returned from FilterLogNamedUint and is used to iterate over the raw logs and unpacked data for LogNamedUint events raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogNamedUintIterator struct {
	Event *ExampleRewardManagerTestLogNamedUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleRewardManagerTestLogNamedUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleRewardManagerTestLogNamedUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleRewardManagerTestLogNamedUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleRewardManagerTestLogNamedUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleRewardManagerTestLogNamedUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleRewardManagerTestLogNamedUint represents a LogNamedUint event raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogNamedUint struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedUint is a free log retrieval operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) FilterLogNamedUint(opts *bind.FilterOpts) (*ExampleRewardManagerTestLogNamedUintIterator, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.FilterLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return &ExampleRewardManagerTestLogNamedUintIterator{contract: _ExampleRewardManagerTest.contract, event: "log_named_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedUint is a free log subscription operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) WatchLogNamedUint(opts *bind.WatchOpts, sink chan<- *ExampleRewardManagerTestLogNamedUint) (event.Subscription, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.WatchLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleRewardManagerTestLogNamedUint)
				if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedUint is a log parse operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) ParseLogNamedUint(log types.Log) (*ExampleRewardManagerTestLogNamedUint, error) {
	event := new(ExampleRewardManagerTestLogNamedUint)
	if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleRewardManagerTestLogStringIterator is returned from FilterLogString and is used to iterate over the raw logs and unpacked data for LogString events raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogStringIterator struct {
	Event *ExampleRewardManagerTestLogString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleRewardManagerTestLogStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleRewardManagerTestLogString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleRewardManagerTestLogString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleRewardManagerTestLogStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleRewardManagerTestLogStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleRewardManagerTestLogString represents a LogString event raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogString struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogString is a free log retrieval operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) FilterLogString(opts *bind.FilterOpts) (*ExampleRewardManagerTestLogStringIterator, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.FilterLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return &ExampleRewardManagerTestLogStringIterator{contract: _ExampleRewardManagerTest.contract, event: "log_string", logs: logs, sub: sub}, nil
}

// WatchLogString is a free log subscription operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) WatchLogString(opts *bind.WatchOpts, sink chan<- *ExampleRewardManagerTestLogString) (event.Subscription, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.WatchLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleRewardManagerTestLogString)
				if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogString is a log parse operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) ParseLogString(log types.Log) (*ExampleRewardManagerTestLogString, error) {
	event := new(ExampleRewardManagerTestLogString)
	if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_string", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleRewardManagerTestLogUintIterator is returned from FilterLogUint and is used to iterate over the raw logs and unpacked data for LogUint events raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogUintIterator struct {
	Event *ExampleRewardManagerTestLogUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleRewardManagerTestLogUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleRewardManagerTestLogUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleRewardManagerTestLogUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleRewardManagerTestLogUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleRewardManagerTestLogUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleRewardManagerTestLogUint represents a LogUint event raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogUint struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogUint is a free log retrieval operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) FilterLogUint(opts *bind.FilterOpts) (*ExampleRewardManagerTestLogUintIterator, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.FilterLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return &ExampleRewardManagerTestLogUintIterator{contract: _ExampleRewardManagerTest.contract, event: "log_uint", logs: logs, sub: sub}, nil
}

// WatchLogUint is a free log subscription operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) WatchLogUint(opts *bind.WatchOpts, sink chan<- *ExampleRewardManagerTestLogUint) (event.Subscription, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.WatchLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleRewardManagerTestLogUint)
				if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogUint is a log parse operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) ParseLogUint(log types.Log) (*ExampleRewardManagerTestLogUint, error) {
	event := new(ExampleRewardManagerTestLogUint)
	if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "log_uint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleRewardManagerTestLogsIterator is returned from FilterLogs and is used to iterate over the raw logs and unpacked data for Logs events raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogsIterator struct {
	Event *ExampleRewardManagerTestLogs // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleRewardManagerTestLogsIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleRewardManagerTestLogs)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleRewardManagerTestLogs)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleRewardManagerTestLogsIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleRewardManagerTestLogsIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleRewardManagerTestLogs represents a Logs event raised by the ExampleRewardManagerTest contract.
type ExampleRewardManagerTestLogs struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogs is a free log retrieval operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) FilterLogs(opts *bind.FilterOpts) (*ExampleRewardManagerTestLogsIterator, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.FilterLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return &ExampleRewardManagerTestLogsIterator{contract: _ExampleRewardManagerTest.contract, event: "logs", logs: logs, sub: sub}, nil
}

// WatchLogs is a free log subscription operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) WatchLogs(opts *bind.WatchOpts, sink chan<- *ExampleRewardManagerTestLogs) (event.Subscription, error) {

	logs, sub, err := _ExampleRewardManagerTest.contract.WatchLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleRewardManagerTestLogs)
				if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "logs", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogs is a log parse operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_ExampleRewardManagerTest *ExampleRewardManagerTestFilterer) ParseLogs(log types.Log) (*ExampleRewardManagerTestLogs, error) {
	event := new(ExampleRewardManagerTestLogs)
	if err := _ExampleRewardManagerTest.contract.UnpackLog(event, "logs", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleTxAllowListMetaData contains all meta data concerning the ExampleTxAllowList contract.
var ExampleTxAllowListMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"deployContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"revoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x608060405234801561001057600080fd5b5073020000000000000000000000000000000000000261004261003761008960201b60201c565b61009160201b60201c565b80600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050610155565b600033905090565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b610ca4806101646000396000f3fe608060405234801561001057600080fd5b50600436106100a95760003560e01c806374a8f1031161007157806374a8f1031461012a5780638da5cb5b146101465780639015d37114610164578063d0ebdbe714610194578063f2fde38b146101b0578063f3ae2415146101cc576100a9565b80630aaf7043146100ae57806324d7806c146100ca5780636cd5c39b146100fa578063704b6c0214610104578063715018a614610120575b600080fd5b6100c860048036038101906100c391906109a7565b6101fc565b005b6100e460048036038101906100df91906109a7565b610210565b6040516100f191906109ef565b60405180910390f35b6101026102bd565b005b61011e600480360381019061011991906109a7565b6102e9565b005b6101286102fd565b005b610144600480360381019061013f91906109a7565b610311565b005b61014e610325565b60405161015b9190610a19565b60405180910390f35b61017e600480360381019061017991906109a7565b61034e565b60405161018b91906109ef565b60405180910390f35b6101ae60048036038101906101a991906109a7565b6103fc565b005b6101ca60048036038101906101c591906109a7565b610410565b005b6101e660048036038101906101e191906109a7565b610493565b6040516101f391906109ef565b60405180910390f35b610204610540565b61020d816105be565b50565b600080600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b815260040161026e9190610a19565b602060405180830381865afa15801561028b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102af9190610a6a565b905060028114915050919050565b6040516102c990610938565b604051809103906000f0801580156102e5573d6000803e3d6000fd5b5050565b6102f1610540565b6102fa8161064e565b50565b610305610540565b61030f60006106de565b565b610319610540565b610322816107a2565b50565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b600080600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b81526004016103ac9190610a19565b602060405180830381865afa1580156103c9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103ed9190610a6a565b90506000811415915050919050565b610404610540565b61040d816108a0565b50565b610418610540565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603610487576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161047e90610b1a565b60405180910390fd5b610490816106de565b50565b600080600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b81526004016104f19190610a19565b602060405180830381865afa15801561050e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105329190610a6a565b905060038114915050919050565b610548610930565b73ffffffffffffffffffffffffffffffffffffffff16610566610325565b73ffffffffffffffffffffffffffffffffffffffff16146105bc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105b390610b86565b60405180910390fd5b565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043826040518263ffffffff1660e01b81526004016106199190610a19565b600060405180830381600087803b15801561063357600080fd5b505af1158015610647573d6000803e3d6000fd5b5050505050565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663704b6c02826040518263ffffffff1660e01b81526004016106a99190610a19565b600060405180830381600087803b1580156106c357600080fd5b505af11580156106d7573d6000803e3d6000fd5b5050505050565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b8073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1603610810576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161080790610bf2565b60405180910390fd5b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638c6bfb3b826040518263ffffffff1660e01b815260040161086b9190610a19565b600060405180830381600087803b15801561088557600080fd5b505af1158015610899573d6000803e3d6000fd5b5050505050565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d0ebdbe7826040518263ffffffff1660e01b81526004016108fb9190610a19565b600060405180830381600087803b15801561091557600080fd5b505af1158015610929573d6000803e3d6000fd5b5050505050565b600033905090565b605c80610c1383390190565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061097482610949565b9050919050565b61098481610969565b811461098f57600080fd5b50565b6000813590506109a18161097b565b92915050565b6000602082840312156109bd576109bc610944565b5b60006109cb84828501610992565b91505092915050565b60008115159050919050565b6109e9816109d4565b82525050565b6000602082019050610a0460008301846109e0565b92915050565b610a1381610969565b82525050565b6000602082019050610a2e6000830184610a0a565b92915050565b6000819050919050565b610a4781610a34565b8114610a5257600080fd5b50565b600081519050610a6481610a3e565b92915050565b600060208284031215610a8057610a7f610944565b5b6000610a8e84828501610a55565b91505092915050565b600082825260208201905092915050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160008201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b6000610b04602683610a97565b9150610b0f82610aa8565b604082019050919050565b60006020820190508181036000830152610b3381610af7565b9050919050565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572600082015250565b6000610b70602083610a97565b9150610b7b82610b3a565b602082019050919050565b60006020820190508181036000830152610b9f81610b63565b9050919050565b7f63616e6e6f74207265766f6b65206f776e20726f6c6500000000000000000000600082015250565b6000610bdc601683610a97565b9150610be782610ba6565b602082019050919050565b60006020820190508181036000830152610c0b81610bcf565b905091905056fe6080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea264697066735822122095e71fe7b8a7d8101f30ba68f5e4e09352023917522f32686f9c7d10ae36668964736f6c634300081a0033a264697066735822122000455b596227b71c5362847cc2589f7ae8ffbe514360a14e4f7b4cc58ba7718364736f6c634300081a0033",
}

// ExampleTxAllowListABI is the input ABI used to generate the binding from.
// Deprecated: Use ExampleTxAllowListMetaData.ABI instead.
var ExampleTxAllowListABI = ExampleTxAllowListMetaData.ABI

// ExampleTxAllowListBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use ExampleTxAllowListMetaData.Bin instead.
var ExampleTxAllowListBin = ExampleTxAllowListMetaData.Bin

// DeployExampleTxAllowList deploys a new Ethereum contract, binding an instance of ExampleTxAllowList to it.
func DeployExampleTxAllowList(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ExampleTxAllowList, error) {
	parsed, err := ExampleTxAllowListMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(ExampleTxAllowListBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ExampleTxAllowList{ExampleTxAllowListCaller: ExampleTxAllowListCaller{contract: contract}, ExampleTxAllowListTransactor: ExampleTxAllowListTransactor{contract: contract}, ExampleTxAllowListFilterer: ExampleTxAllowListFilterer{contract: contract}}, nil
}

// ExampleTxAllowList is an auto generated Go binding around an Ethereum contract.
type ExampleTxAllowList struct {
	ExampleTxAllowListCaller     // Read-only binding to the contract
	ExampleTxAllowListTransactor // Write-only binding to the contract
	ExampleTxAllowListFilterer   // Log filterer for contract events
}

// ExampleTxAllowListCaller is an auto generated read-only Go binding around an Ethereum contract.
type ExampleTxAllowListCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExampleTxAllowListTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ExampleTxAllowListTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExampleTxAllowListFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ExampleTxAllowListFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExampleTxAllowListSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ExampleTxAllowListSession struct {
	Contract     *ExampleTxAllowList // Generic contract binding to set the session for
	CallOpts     bind.CallOpts       // Call options to use throughout this session
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// ExampleTxAllowListCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ExampleTxAllowListCallerSession struct {
	Contract *ExampleTxAllowListCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts             // Call options to use throughout this session
}

// ExampleTxAllowListTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ExampleTxAllowListTransactorSession struct {
	Contract     *ExampleTxAllowListTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts             // Transaction auth options to use throughout this session
}

// ExampleTxAllowListRaw is an auto generated low-level Go binding around an Ethereum contract.
type ExampleTxAllowListRaw struct {
	Contract *ExampleTxAllowList // Generic contract binding to access the raw methods on
}

// ExampleTxAllowListCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ExampleTxAllowListCallerRaw struct {
	Contract *ExampleTxAllowListCaller // Generic read-only contract binding to access the raw methods on
}

// ExampleTxAllowListTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ExampleTxAllowListTransactorRaw struct {
	Contract *ExampleTxAllowListTransactor // Generic write-only contract binding to access the raw methods on
}

// NewExampleTxAllowList creates a new instance of ExampleTxAllowList, bound to a specific deployed contract.
func NewExampleTxAllowList(address common.Address, backend bind.ContractBackend) (*ExampleTxAllowList, error) {
	contract, err := bindExampleTxAllowList(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ExampleTxAllowList{ExampleTxAllowListCaller: ExampleTxAllowListCaller{contract: contract}, ExampleTxAllowListTransactor: ExampleTxAllowListTransactor{contract: contract}, ExampleTxAllowListFilterer: ExampleTxAllowListFilterer{contract: contract}}, nil
}

// NewExampleTxAllowListCaller creates a new read-only instance of ExampleTxAllowList, bound to a specific deployed contract.
func NewExampleTxAllowListCaller(address common.Address, caller bind.ContractCaller) (*ExampleTxAllowListCaller, error) {
	contract, err := bindExampleTxAllowList(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ExampleTxAllowListCaller{contract: contract}, nil
}

// NewExampleTxAllowListTransactor creates a new write-only instance of ExampleTxAllowList, bound to a specific deployed contract.
func NewExampleTxAllowListTransactor(address common.Address, transactor bind.ContractTransactor) (*ExampleTxAllowListTransactor, error) {
	contract, err := bindExampleTxAllowList(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ExampleTxAllowListTransactor{contract: contract}, nil
}

// NewExampleTxAllowListFilterer creates a new log filterer instance of ExampleTxAllowList, bound to a specific deployed contract.
func NewExampleTxAllowListFilterer(address common.Address, filterer bind.ContractFilterer) (*ExampleTxAllowListFilterer, error) {
	contract, err := bindExampleTxAllowList(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ExampleTxAllowListFilterer{contract: contract}, nil
}

// bindExampleTxAllowList binds a generic wrapper to an already deployed contract.
func bindExampleTxAllowList(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ExampleTxAllowListMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ExampleTxAllowList *ExampleTxAllowListRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ExampleTxAllowList.Contract.ExampleTxAllowListCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ExampleTxAllowList *ExampleTxAllowListRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowList.Contract.ExampleTxAllowListTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ExampleTxAllowList *ExampleTxAllowListRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ExampleTxAllowList.Contract.ExampleTxAllowListTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ExampleTxAllowList *ExampleTxAllowListCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ExampleTxAllowList.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ExampleTxAllowList *ExampleTxAllowListTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowList.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ExampleTxAllowList *ExampleTxAllowListTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ExampleTxAllowList.Contract.contract.Transact(opts, method, params...)
}

// IsAdmin is a free data retrieval call binding the contract method 0x24d7806c.
//
// Solidity: function isAdmin(address addr) view returns(bool)
func (_ExampleTxAllowList *ExampleTxAllowListCaller) IsAdmin(opts *bind.CallOpts, addr common.Address) (bool, error) {
	var out []interface{}
	err := _ExampleTxAllowList.contract.Call(opts, &out, "isAdmin", addr)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsAdmin is a free data retrieval call binding the contract method 0x24d7806c.
//
// Solidity: function isAdmin(address addr) view returns(bool)
func (_ExampleTxAllowList *ExampleTxAllowListSession) IsAdmin(addr common.Address) (bool, error) {
	return _ExampleTxAllowList.Contract.IsAdmin(&_ExampleTxAllowList.CallOpts, addr)
}

// IsAdmin is a free data retrieval call binding the contract method 0x24d7806c.
//
// Solidity: function isAdmin(address addr) view returns(bool)
func (_ExampleTxAllowList *ExampleTxAllowListCallerSession) IsAdmin(addr common.Address) (bool, error) {
	return _ExampleTxAllowList.Contract.IsAdmin(&_ExampleTxAllowList.CallOpts, addr)
}

// IsEnabled is a free data retrieval call binding the contract method 0x9015d371.
//
// Solidity: function isEnabled(address addr) view returns(bool)
func (_ExampleTxAllowList *ExampleTxAllowListCaller) IsEnabled(opts *bind.CallOpts, addr common.Address) (bool, error) {
	var out []interface{}
	err := _ExampleTxAllowList.contract.Call(opts, &out, "isEnabled", addr)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsEnabled is a free data retrieval call binding the contract method 0x9015d371.
//
// Solidity: function isEnabled(address addr) view returns(bool)
func (_ExampleTxAllowList *ExampleTxAllowListSession) IsEnabled(addr common.Address) (bool, error) {
	return _ExampleTxAllowList.Contract.IsEnabled(&_ExampleTxAllowList.CallOpts, addr)
}

// IsEnabled is a free data retrieval call binding the contract method 0x9015d371.
//
// Solidity: function isEnabled(address addr) view returns(bool)
func (_ExampleTxAllowList *ExampleTxAllowListCallerSession) IsEnabled(addr common.Address) (bool, error) {
	return _ExampleTxAllowList.Contract.IsEnabled(&_ExampleTxAllowList.CallOpts, addr)
}

// IsManager is a free data retrieval call binding the contract method 0xf3ae2415.
//
// Solidity: function isManager(address addr) view returns(bool)
func (_ExampleTxAllowList *ExampleTxAllowListCaller) IsManager(opts *bind.CallOpts, addr common.Address) (bool, error) {
	var out []interface{}
	err := _ExampleTxAllowList.contract.Call(opts, &out, "isManager", addr)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsManager is a free data retrieval call binding the contract method 0xf3ae2415.
//
// Solidity: function isManager(address addr) view returns(bool)
func (_ExampleTxAllowList *ExampleTxAllowListSession) IsManager(addr common.Address) (bool, error) {
	return _ExampleTxAllowList.Contract.IsManager(&_ExampleTxAllowList.CallOpts, addr)
}

// IsManager is a free data retrieval call binding the contract method 0xf3ae2415.
//
// Solidity: function isManager(address addr) view returns(bool)
func (_ExampleTxAllowList *ExampleTxAllowListCallerSession) IsManager(addr common.Address) (bool, error) {
	return _ExampleTxAllowList.Contract.IsManager(&_ExampleTxAllowList.CallOpts, addr)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ExampleTxAllowList *ExampleTxAllowListCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ExampleTxAllowList.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ExampleTxAllowList *ExampleTxAllowListSession) Owner() (common.Address, error) {
	return _ExampleTxAllowList.Contract.Owner(&_ExampleTxAllowList.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ExampleTxAllowList *ExampleTxAllowListCallerSession) Owner() (common.Address, error) {
	return _ExampleTxAllowList.Contract.Owner(&_ExampleTxAllowList.CallOpts)
}

// DeployContract is a paid mutator transaction binding the contract method 0x6cd5c39b.
//
// Solidity: function deployContract() returns()
func (_ExampleTxAllowList *ExampleTxAllowListTransactor) DeployContract(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowList.contract.Transact(opts, "deployContract")
}

// DeployContract is a paid mutator transaction binding the contract method 0x6cd5c39b.
//
// Solidity: function deployContract() returns()
func (_ExampleTxAllowList *ExampleTxAllowListSession) DeployContract() (*types.Transaction, error) {
	return _ExampleTxAllowList.Contract.DeployContract(&_ExampleTxAllowList.TransactOpts)
}

// DeployContract is a paid mutator transaction binding the contract method 0x6cd5c39b.
//
// Solidity: function deployContract() returns()
func (_ExampleTxAllowList *ExampleTxAllowListTransactorSession) DeployContract() (*types.Transaction, error) {
	return _ExampleTxAllowList.Contract.DeployContract(&_ExampleTxAllowList.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_ExampleTxAllowList *ExampleTxAllowListTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowList.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_ExampleTxAllowList *ExampleTxAllowListSession) RenounceOwnership() (*types.Transaction, error) {
	return _ExampleTxAllowList.Contract.RenounceOwnership(&_ExampleTxAllowList.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_ExampleTxAllowList *ExampleTxAllowListTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _ExampleTxAllowList.Contract.RenounceOwnership(&_ExampleTxAllowList.TransactOpts)
}

// Revoke is a paid mutator transaction binding the contract method 0x74a8f103.
//
// Solidity: function revoke(address addr) returns()
func (_ExampleTxAllowList *ExampleTxAllowListTransactor) Revoke(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _ExampleTxAllowList.contract.Transact(opts, "revoke", addr)
}

// Revoke is a paid mutator transaction binding the contract method 0x74a8f103.
//
// Solidity: function revoke(address addr) returns()
func (_ExampleTxAllowList *ExampleTxAllowListSession) Revoke(addr common.Address) (*types.Transaction, error) {
	return _ExampleTxAllowList.Contract.Revoke(&_ExampleTxAllowList.TransactOpts, addr)
}

// Revoke is a paid mutator transaction binding the contract method 0x74a8f103.
//
// Solidity: function revoke(address addr) returns()
func (_ExampleTxAllowList *ExampleTxAllowListTransactorSession) Revoke(addr common.Address) (*types.Transaction, error) {
	return _ExampleTxAllowList.Contract.Revoke(&_ExampleTxAllowList.TransactOpts, addr)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_ExampleTxAllowList *ExampleTxAllowListTransactor) SetAdmin(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _ExampleTxAllowList.contract.Transact(opts, "setAdmin", addr)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_ExampleTxAllowList *ExampleTxAllowListSession) SetAdmin(addr common.Address) (*types.Transaction, error) {
	return _ExampleTxAllowList.Contract.SetAdmin(&_ExampleTxAllowList.TransactOpts, addr)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_ExampleTxAllowList *ExampleTxAllowListTransactorSession) SetAdmin(addr common.Address) (*types.Transaction, error) {
	return _ExampleTxAllowList.Contract.SetAdmin(&_ExampleTxAllowList.TransactOpts, addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_ExampleTxAllowList *ExampleTxAllowListTransactor) SetEnabled(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _ExampleTxAllowList.contract.Transact(opts, "setEnabled", addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_ExampleTxAllowList *ExampleTxAllowListSession) SetEnabled(addr common.Address) (*types.Transaction, error) {
	return _ExampleTxAllowList.Contract.SetEnabled(&_ExampleTxAllowList.TransactOpts, addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_ExampleTxAllowList *ExampleTxAllowListTransactorSession) SetEnabled(addr common.Address) (*types.Transaction, error) {
	return _ExampleTxAllowList.Contract.SetEnabled(&_ExampleTxAllowList.TransactOpts, addr)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_ExampleTxAllowList *ExampleTxAllowListTransactor) SetManager(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _ExampleTxAllowList.contract.Transact(opts, "setManager", addr)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_ExampleTxAllowList *ExampleTxAllowListSession) SetManager(addr common.Address) (*types.Transaction, error) {
	return _ExampleTxAllowList.Contract.SetManager(&_ExampleTxAllowList.TransactOpts, addr)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_ExampleTxAllowList *ExampleTxAllowListTransactorSession) SetManager(addr common.Address) (*types.Transaction, error) {
	return _ExampleTxAllowList.Contract.SetManager(&_ExampleTxAllowList.TransactOpts, addr)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_ExampleTxAllowList *ExampleTxAllowListTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _ExampleTxAllowList.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_ExampleTxAllowList *ExampleTxAllowListSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _ExampleTxAllowList.Contract.TransferOwnership(&_ExampleTxAllowList.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_ExampleTxAllowList *ExampleTxAllowListTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _ExampleTxAllowList.Contract.TransferOwnership(&_ExampleTxAllowList.TransactOpts, newOwner)
}

// ExampleTxAllowListOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the ExampleTxAllowList contract.
type ExampleTxAllowListOwnershipTransferredIterator struct {
	Event *ExampleTxAllowListOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleTxAllowListOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleTxAllowListOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleTxAllowListOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleTxAllowListOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleTxAllowListOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleTxAllowListOwnershipTransferred represents a OwnershipTransferred event raised by the ExampleTxAllowList contract.
type ExampleTxAllowListOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_ExampleTxAllowList *ExampleTxAllowListFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*ExampleTxAllowListOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _ExampleTxAllowList.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &ExampleTxAllowListOwnershipTransferredIterator{contract: _ExampleTxAllowList.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_ExampleTxAllowList *ExampleTxAllowListFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *ExampleTxAllowListOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _ExampleTxAllowList.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleTxAllowListOwnershipTransferred)
				if err := _ExampleTxAllowList.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_ExampleTxAllowList *ExampleTxAllowListFilterer) ParseOwnershipTransferred(log types.Log) (*ExampleTxAllowListOwnershipTransferred, error) {
	event := new(ExampleTxAllowListOwnershipTransferred)
	if err := _ExampleTxAllowList.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleTxAllowListTestMetaData contains all meta data concerning the ExampleTxAllowListTest contract.
var ExampleTxAllowListTestMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"log_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"log_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"log_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"name\":\"log_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"val\",\"type\":\"address\"}],\"name\":\"log_named_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"val\",\"type\":\"bytes\"}],\"name\":\"log_named_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"val\",\"type\":\"bytes32\"}],\"name\":\"log_named_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"}],\"name\":\"log_named_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"val\",\"type\":\"string\"}],\"name\":\"log_named_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"log_named_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"log_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"logs\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"IS_TEST\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"failed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_addContractAsAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_adminCanRevoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_canDeploy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_contractOwnerIsAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_enableOther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_enableThroughContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_exampleAllowListReturnsTestIsAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_fromOther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_managerCanAllow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_managerCanDeploy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_managerCanRevoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_managerCannotGrantAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_managerCannotGrantManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_managerCannotRevokeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_managerCannotRevokeManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_newAddressHasNoRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_noRoleCannotEnableItself\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_noRoleIsNotAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_onlyAdminCanEnable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_onlyAdminCanRevoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step_precompileHasDeployerAsAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x608060405260016000806101000a81548160ff021916908315150217905550730200000000000000000000000000000000000002600060026101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550348015607e57600080fd5b506153a38061008e6000396000f3fe608060405234801561001057600080fd5b50600436106101585760003560e01c806382204bc4116100c3578063c24f26ce1161007c578063c24f26ce14610225578063e6617ee31461022f578063ea442d7014610239578063f26c562c14610243578063f7e4e82d1461024d578063fa7626d41461025757610158565b806382204bc4146101d557806384725ce4146101df5780638d20a19f146101e95780639d127233146101f3578063aee9e308146101fd578063ba414fa61461020757610158565b806333cb47db1161011557806333cb47db146101995780634f2fd73b146101a357806351605581146101ad5780635838f8f1146101b75780636499010a146101c15780636604c69f146101cb57610158565b80630a9254e41461015d578063110feff614610167578063199b9a56146101715780631ab506691461017b5780632bf9fc8c1461018557806333a49bb01461018f575b600080fd5b610165610275565b005b61016f610318565b005b61017961043b565b005b6101836104ed565b005b61018d61091b565b005b610197610bac565b005b6101a161101d565b005b6101ab6110f3565b005b6101b561156f565b005b6101bf61191a565b005b6101c9611d96565b005b6101d3611f16565b005b6101dd612345565b005b6101e76123f7565b005b6101f161282d565b005b6101fb612950565b005b610205612e8d565b005b61020f613473565b60405161021c9190613fa0565b60405180910390f35b61022d613610565b005b6102376136b8565b005b610241613815565b005b61024b613817565b005b6102556138f8565b005b61025f613c64565b60405161026c9190613fa0565b60405180910390f35b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638c6bfb3b730fa8ea536be85f32724d57a37758761b864161236040518263ffffffff1660e01b81526004016102e49190613ffc565b600060405180830381600087803b1580156102fe57600080fd5b505af1158015610312573d6000803e3d6000fd5b50505050565b600060405161032690613f78565b604051809103906000f080158015610342573d6000803e3d6000fd5b5090506000819050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d0ebdbe7826040518263ffffffff1660e01b81526004016103a59190613ffc565b600060405180830381600087803b1580156103bf57600080fd5b505af11580156103d3573d6000803e3d6000fd5b505050508173ffffffffffffffffffffffffffffffffffffffff16636cd5c39b6040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561041f57600080fd5b505af1158015610433573d6000803e3d6000fd5b505050505050565b600060405161044990613f78565b604051809103906000f080158015610465573d6000803e3d6000fd5b5090506104ea8173ffffffffffffffffffffffffffffffffffffffff166324d7806c306040518263ffffffff1660e01b81526004016104a49190613ffc565b602060405180830381865afa1580156104c1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104e59190614048565b613c75565b50565b60006040516104fb90613f78565b604051809103906000f080158015610517573d6000803e3d6000fd5b509050600060405161052890613f78565b604051809103906000f080158015610544573d6000803e3d6000fd5b509050600082905060008290506105d48473ffffffffffffffffffffffffffffffffffffffff166324d7806c846040518263ffffffff1660e01b815260040161058d9190613ffc565b602060405180830381865afa1580156105aa573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ce9190614048565b15613c75565b6106578473ffffffffffffffffffffffffffffffffffffffff1663f3ae2415836040518263ffffffff1660e01b81526004016106109190613ffc565b602060405180830381865afa15801561062d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106519190614048565b15613c75565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d0ebdbe7826040518263ffffffff1660e01b81526004016106b29190613ffc565b600060405180830381600087803b1580156106cc57600080fd5b505af11580156106e0573d6000803e3d6000fd5b505050506107668373ffffffffffffffffffffffffffffffffffffffff1663f3ae2415836040518263ffffffff1660e01b81526004016107209190613ffc565b602060405180830381865afa15801561073d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107619190614048565b613c75565b8273ffffffffffffffffffffffffffffffffffffffff1663704b6c02836040518263ffffffff1660e01b815260040161079f9190613ffc565b600060405180830381600087803b1580156107b957600080fd5b505af19250505080156107ca575060015b156108105761080f60006040518060400160405280601481526020017f73657441646d696e2073686f756c64206661696c000000000000000000000000815250613cbb565b5b6108938473ffffffffffffffffffffffffffffffffffffffff166324d7806c846040518263ffffffff1660e01b815260040161084c9190613ffc565b602060405180830381865afa158015610869573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061088d9190614048565b15613c75565b6109158373ffffffffffffffffffffffffffffffffffffffff1663f3ae2415836040518263ffffffff1660e01b81526004016108cf9190613ffc565b602060405180830381865afa1580156108ec573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109109190614048565b613c75565b50505050565b600060405161092990613f78565b604051809103906000f080158015610945573d6000803e3d6000fd5b50905060008190506109f3600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1836040518263ffffffff1660e01b81526004016109ab9190613ffc565b602060405180830381865afa1580156109c8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109ec91906140ab565b6000613d05565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663704b6c02826040518263ffffffff1660e01b8152600401610a4e9190613ffc565b600060405180830381600087803b158015610a6857600080fd5b505af1158015610a7c573d6000803e3d6000fd5b50505050610b26600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1836040518263ffffffff1660e01b8152600401610ade9190613ffc565b602060405180830381865afa158015610afb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b1f91906140ab565b6002613d05565b610ba88273ffffffffffffffffffffffffffffffffffffffff166324d7806c836040518263ffffffff1660e01b8152600401610b629190613ffc565b602060405180830381865afa158015610b7f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ba39190614048565b613c75565b5050565b6000604051610bba90613f78565b604051809103906000f080158015610bd6573d6000803e3d6000fd5b5090506000604051610be790613f78565b604051809103906000f080158015610c03573d6000803e3d6000fd5b50905060008290506000829050610c938473ffffffffffffffffffffffffffffffffffffffff16639015d371846040518263ffffffff1660e01b8152600401610c4c9190613ffc565b602060405180830381865afa158015610c69573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c8d9190614048565b15613c75565b610d168473ffffffffffffffffffffffffffffffffffffffff16639015d371836040518263ffffffff1660e01b8152600401610ccf9190613ffc565b602060405180830381865afa158015610cec573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d109190614048565b15613c75565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663704b6c02836040518263ffffffff1660e01b8152600401610d719190613ffc565b600060405180830381600087803b158015610d8b57600080fd5b505af1158015610d9f573d6000803e3d6000fd5b50505050610e258473ffffffffffffffffffffffffffffffffffffffff16639015d371846040518263ffffffff1660e01b8152600401610ddf9190613ffc565b602060405180830381865afa158015610dfc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e209190614048565b613c75565b610ea88473ffffffffffffffffffffffffffffffffffffffff16639015d371836040518263ffffffff1660e01b8152600401610e619190613ffc565b602060405180830381865afa158015610e7e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ea29190614048565b15613c75565b8373ffffffffffffffffffffffffffffffffffffffff16630aaf7043826040518263ffffffff1660e01b8152600401610ee19190613ffc565b600060405180830381600087803b158015610efb57600080fd5b505af1158015610f0f573d6000803e3d6000fd5b50505050610f958473ffffffffffffffffffffffffffffffffffffffff16639015d371846040518263ffffffff1660e01b8152600401610f4f9190613ffc565b602060405180830381865afa158015610f6c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f909190614048565b613c75565b6110178473ffffffffffffffffffffffffffffffffffffffff16639015d371836040518263ffffffff1660e01b8152600401610fd19190613ffc565b602060405180830381865afa158015610fee573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110129190614048565b613c75565b50505050565b600060405161102b90613f78565b604051809103906000f080158015611047573d6000803e3d6000fd5b5090506110f0600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1836040518263ffffffff1660e01b81526004016110a89190613ffc565b602060405180830381865afa1580156110c5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110e991906140ab565b6000613d05565b50565b600060405161110190613f78565b604051809103906000f08015801561111d573d6000803e3d6000fd5b509050600060405161112e90613f78565b604051809103906000f08015801561114a573d6000803e3d6000fd5b509050600082905060008290506111da8473ffffffffffffffffffffffffffffffffffffffff16639015d371846040518263ffffffff1660e01b81526004016111939190613ffc565b602060405180830381865afa1580156111b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111d49190614048565b15613c75565b61125d8473ffffffffffffffffffffffffffffffffffffffff16639015d371836040518263ffffffff1660e01b81526004016112169190613ffc565b602060405180830381865afa158015611233573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112579190614048565b15613c75565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663704b6c02836040518263ffffffff1660e01b81526004016112b89190613ffc565b600060405180830381600087803b1580156112d257600080fd5b505af11580156112e6573d6000803e3d6000fd5b50505050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663704b6c02826040518263ffffffff1660e01b81526004016113459190613ffc565b600060405180830381600087803b15801561135f57600080fd5b505af1158015611373573d6000803e3d6000fd5b505050506113f98473ffffffffffffffffffffffffffffffffffffffff166324d7806c846040518263ffffffff1660e01b81526004016113b39190613ffc565b602060405180830381865afa1580156113d0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113f49190614048565b613c75565b61147b8373ffffffffffffffffffffffffffffffffffffffff166324d7806c836040518263ffffffff1660e01b81526004016114359190613ffc565b602060405180830381865afa158015611452573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114769190614048565b613c75565b8373ffffffffffffffffffffffffffffffffffffffff166374a8f103826040518263ffffffff1660e01b81526004016114b49190613ffc565b600060405180830381600087803b1580156114ce57600080fd5b505af11580156114e2573d6000803e3d6000fd5b505050506115698373ffffffffffffffffffffffffffffffffffffffff16639015d371836040518263ffffffff1660e01b81526004016115229190613ffc565b602060405180830381865afa15801561153f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115639190614048565b15613c75565b50505050565b600060405161157d90613f78565b604051809103906000f080158015611599573d6000803e3d6000fd5b50905060006040516115aa90613f78565b604051809103906000f0801580156115c6573d6000803e3d6000fd5b50905060008290506000829050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d0ebdbe7826040518263ffffffff1660e01b815260040161162e9190613ffc565b600060405180830381600087803b15801561164857600080fd5b505af115801561165c573d6000803e3d6000fd5b505050506116e38473ffffffffffffffffffffffffffffffffffffffff1663f3ae2415846040518263ffffffff1660e01b815260040161169c9190613ffc565b602060405180830381865afa1580156116b9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116dd9190614048565b15613c75565b6117658373ffffffffffffffffffffffffffffffffffffffff1663f3ae2415836040518263ffffffff1660e01b815260040161171f9190613ffc565b602060405180830381865afa15801561173c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117609190614048565b613c75565b8273ffffffffffffffffffffffffffffffffffffffff1663d0ebdbe7836040518263ffffffff1660e01b815260040161179e9190613ffc565b600060405180830381600087803b1580156117b857600080fd5b505af19250505080156117c9575060015b1561180f5761180e60006040518060400160405280601681526020017f7365744d616e616765722073686f756c64206661696c00000000000000000000815250613cbb565b5b6118928473ffffffffffffffffffffffffffffffffffffffff1663f3ae2415846040518263ffffffff1660e01b815260040161184b9190613ffc565b602060405180830381865afa158015611868573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061188c9190614048565b15613c75565b6119148373ffffffffffffffffffffffffffffffffffffffff1663f3ae2415836040518263ffffffff1660e01b81526004016118ce9190613ffc565b602060405180830381865afa1580156118eb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061190f9190614048565b613c75565b50505050565b600060405161192890613f78565b604051809103906000f080158015611944573d6000803e3d6000fd5b509050600060405161195590613f78565b604051809103906000f080158015611971573d6000803e3d6000fd5b50905060008290506000829050611a018473ffffffffffffffffffffffffffffffffffffffff166324d7806c846040518263ffffffff1660e01b81526004016119ba9190613ffc565b602060405180830381865afa1580156119d7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119fb9190614048565b15613c75565b611a848473ffffffffffffffffffffffffffffffffffffffff1663f3ae2415836040518263ffffffff1660e01b8152600401611a3d9190613ffc565b602060405180830381865afa158015611a5a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a7e9190614048565b15613c75565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043836040518263ffffffff1660e01b8152600401611adf9190613ffc565b600060405180830381600087803b158015611af957600080fd5b505af1158015611b0d573d6000803e3d6000fd5b50505050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d0ebdbe7826040518263ffffffff1660e01b8152600401611b6c9190613ffc565b600060405180830381600087803b158015611b8657600080fd5b505af1158015611b9a573d6000803e3d6000fd5b50505050611c208473ffffffffffffffffffffffffffffffffffffffff16639015d371846040518263ffffffff1660e01b8152600401611bda9190613ffc565b602060405180830381865afa158015611bf7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c1b9190614048565b613c75565b611ca28373ffffffffffffffffffffffffffffffffffffffff1663f3ae2415836040518263ffffffff1660e01b8152600401611c5c9190613ffc565b602060405180830381865afa158015611c79573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c9d9190614048565b613c75565b8273ffffffffffffffffffffffffffffffffffffffff166374a8f103836040518263ffffffff1660e01b8152600401611cdb9190613ffc565b600060405180830381600087803b158015611cf557600080fd5b505af1158015611d09573d6000803e3d6000fd5b50505050611d908473ffffffffffffffffffffffffffffffffffffffff16639015d371846040518263ffffffff1660e01b8152600401611d499190613ffc565b602060405180830381865afa158015611d66573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d8a9190614048565b15613c75565b50505050565b6000604051611da490613f78565b604051809103906000f080158015611dc0573d6000803e3d6000fd5b509050611e69600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1836040518263ffffffff1660e01b8152600401611e219190613ffc565b602060405180830381865afa158015611e3e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e6291906140ab565b6000613d05565b8073ffffffffffffffffffffffffffffffffffffffff16630aaf7043826040518263ffffffff1660e01b8152600401611ea29190613ffc565b600060405180830381600087803b158015611ebc57600080fd5b505af1925050508015611ecd575060015b15611f1357611f1260006040518060400160405280601681526020017f736574456e61626c65642073686f756c64206661696c00000000000000000000815250613cbb565b5b50565b6000604051611f2490613f78565b604051809103906000f080158015611f40573d6000803e3d6000fd5b5090506000604051611f5190613f78565b604051809103906000f080158015611f6d573d6000803e3d6000fd5b50905060008290506000829050611ffd8473ffffffffffffffffffffffffffffffffffffffff16639015d371846040518263ffffffff1660e01b8152600401611fb69190613ffc565b602060405180830381865afa158015611fd3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ff79190614048565b15613c75565b6120808473ffffffffffffffffffffffffffffffffffffffff16639015d371836040518263ffffffff1660e01b81526004016120399190613ffc565b602060405180830381865afa158015612056573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061207a9190614048565b15613c75565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043836040518263ffffffff1660e01b81526004016120db9190613ffc565b600060405180830381600087803b1580156120f557600080fd5b505af1158015612109573d6000803e3d6000fd5b5050505061218f8473ffffffffffffffffffffffffffffffffffffffff16639015d371846040518263ffffffff1660e01b81526004016121499190613ffc565b602060405180830381865afa158015612166573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061218a9190614048565b613c75565b6122128473ffffffffffffffffffffffffffffffffffffffff16639015d371836040518263ffffffff1660e01b81526004016121cb9190613ffc565b602060405180830381865afa1580156121e8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061220c9190614048565b15613c75565b8373ffffffffffffffffffffffffffffffffffffffff16630aaf7043826040518263ffffffff1660e01b815260040161224b9190613ffc565b600060405180830381600087803b15801561226557600080fd5b505af1925050508015612276575060015b156122bc576122bb60006040518060400160405280601681526020017f736574456e61626c65642073686f756c64206661696c00000000000000000000815250613cbb565b5b61233f8473ffffffffffffffffffffffffffffffffffffffff16639015d371836040518263ffffffff1660e01b81526004016122f89190613ffc565b602060405180830381865afa158015612315573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123399190614048565b15613c75565b50505050565b600060405161235390613f78565b604051809103906000f08015801561236f573d6000803e3d6000fd5b5090506123f48173ffffffffffffffffffffffffffffffffffffffff166324d7806c306040518263ffffffff1660e01b81526004016123ae9190613ffc565b602060405180830381865afa1580156123cb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123ef9190614048565b613c75565b50565b600060405161240590613f78565b604051809103906000f080158015612421573d6000803e3d6000fd5b509050600060405161243290613f78565b604051809103906000f08015801561244e573d6000803e3d6000fd5b50905060008290506000829050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d0ebdbe7836040518263ffffffff1660e01b81526004016124b69190613ffc565b600060405180830381600087803b1580156124d057600080fd5b505af11580156124e4573d6000803e3d6000fd5b50505050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d0ebdbe7826040518263ffffffff1660e01b81526004016125439190613ffc565b600060405180830381600087803b15801561255d57600080fd5b505af1158015612571573d6000803e3d6000fd5b505050506125f78473ffffffffffffffffffffffffffffffffffffffff1663f3ae2415846040518263ffffffff1660e01b81526004016125b19190613ffc565b602060405180830381865afa1580156125ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125f29190614048565b613c75565b6126798373ffffffffffffffffffffffffffffffffffffffff1663f3ae2415836040518263ffffffff1660e01b81526004016126339190613ffc565b602060405180830381865afa158015612650573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126749190614048565b613c75565b8273ffffffffffffffffffffffffffffffffffffffff166374a8f103836040518263ffffffff1660e01b81526004016126b29190613ffc565b600060405180830381600087803b1580156126cc57600080fd5b505af19250505080156126dd575060015b156127235761272260006040518060400160405280601281526020017f7265766f6b652073686f756c64206661696c0000000000000000000000000000815250613cbb565b5b6127a58473ffffffffffffffffffffffffffffffffffffffff1663f3ae2415846040518263ffffffff1660e01b815260040161275f9190613ffc565b602060405180830381865afa15801561277c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906127a09190614048565b613c75565b6128278373ffffffffffffffffffffffffffffffffffffffff1663f3ae2415836040518263ffffffff1660e01b81526004016127e19190613ffc565b602060405180830381865afa1580156127fe573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906128229190614048565b613c75565b50505050565b600060405161283b90613f78565b604051809103906000f080158015612857573d6000803e3d6000fd5b5090506000819050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043826040518263ffffffff1660e01b81526004016128ba9190613ffc565b600060405180830381600087803b1580156128d457600080fd5b505af11580156128e8573d6000803e3d6000fd5b505050508173ffffffffffffffffffffffffffffffffffffffff16636cd5c39b6040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561293457600080fd5b505af1158015612948573d6000803e3d6000fd5b505050505050565b600060405161295e90613f78565b604051809103906000f08015801561297a573d6000803e3d6000fd5b509050600060405161298b90613f78565b604051809103906000f0801580156129a7573d6000803e3d6000fd5b50905060008290506000829050612a378473ffffffffffffffffffffffffffffffffffffffff16639015d371846040518263ffffffff1660e01b81526004016129f09190613ffc565b602060405180830381865afa158015612a0d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612a319190614048565b15613c75565b612aba8473ffffffffffffffffffffffffffffffffffffffff16639015d371836040518263ffffffff1660e01b8152600401612a739190613ffc565b602060405180830381865afa158015612a90573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612ab49190614048565b15613c75565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043836040518263ffffffff1660e01b8152600401612b159190613ffc565b600060405180830381600087803b158015612b2f57600080fd5b505af1158015612b43573d6000803e3d6000fd5b50505050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663704b6c02826040518263ffffffff1660e01b8152600401612ba29190613ffc565b600060405180830381600087803b158015612bbc57600080fd5b505af1158015612bd0573d6000803e3d6000fd5b50505050612cd98473ffffffffffffffffffffffffffffffffffffffff16639015d371846040518263ffffffff1660e01b8152600401612c109190613ffc565b602060405180830381865afa158015612c2d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612c519190614048565b8015612cd457508473ffffffffffffffffffffffffffffffffffffffff166324d7806c846040518263ffffffff1660e01b8152600401612c919190613ffc565b602060405180830381865afa158015612cae573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612cd29190614048565b155b613c75565b612d5b8473ffffffffffffffffffffffffffffffffffffffff166324d7806c836040518263ffffffff1660e01b8152600401612d159190613ffc565b602060405180830381865afa158015612d32573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612d569190614048565b613c75565b8373ffffffffffffffffffffffffffffffffffffffff166374a8f103826040518263ffffffff1660e01b8152600401612d949190613ffc565b600060405180830381600087803b158015612dae57600080fd5b505af1925050508015612dbf575060015b15612e0557612e0460006040518060400160405280601281526020017f7265766f6b652073686f756c64206661696c0000000000000000000000000000815250613cbb565b5b612e878473ffffffffffffffffffffffffffffffffffffffff166324d7806c836040518263ffffffff1660e01b8152600401612e419190613ffc565b602060405180830381865afa158015612e5e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612e829190614048565b613c75565b50505050565b6000604051612e9b90613f78565b604051809103906000f080158015612eb7573d6000803e3d6000fd5b5090506000604051612ec890613f78565b604051809103906000f080158015612ee4573d6000803e3d6000fd5b50905060008290506000829050612f748473ffffffffffffffffffffffffffffffffffffffff166324d7806c846040518263ffffffff1660e01b8152600401612f2d9190613ffc565b602060405180830381865afa158015612f4a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612f6e9190614048565b15613c75565b612ff78473ffffffffffffffffffffffffffffffffffffffff1663f3ae2415836040518263ffffffff1660e01b8152600401612fb09190613ffc565b602060405180830381865afa158015612fcd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612ff19190614048565b15613c75565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663704b6c02836040518263ffffffff1660e01b81526004016130529190613ffc565b600060405180830381600087803b15801561306c57600080fd5b505af1158015613080573d6000803e3d6000fd5b50505050600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d0ebdbe7826040518263ffffffff1660e01b81526004016130df9190613ffc565b600060405180830381600087803b1580156130f957600080fd5b505af115801561310d573d6000803e3d6000fd5b505050506131938473ffffffffffffffffffffffffffffffffffffffff166324d7806c846040518263ffffffff1660e01b815260040161314d9190613ffc565b602060405180830381865afa15801561316a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061318e9190614048565b613c75565b6132158373ffffffffffffffffffffffffffffffffffffffff1663f3ae2415836040518263ffffffff1660e01b81526004016131cf9190613ffc565b602060405180830381865afa1580156131ec573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906132109190614048565b613c75565b8273ffffffffffffffffffffffffffffffffffffffff166374a8f103826040518263ffffffff1660e01b815260040161324e9190613ffc565b600060405180830381600087803b15801561326857600080fd5b505af1925050508015613279575060015b156132bf576132be60006040518060400160405280601281526020017f7265766f6b652073686f756c64206661696c0000000000000000000000000000815250613cbb565b5b8273ffffffffffffffffffffffffffffffffffffffff166374a8f103836040518263ffffffff1660e01b81526004016132f89190613ffc565b600060405180830381600087803b15801561331257600080fd5b505af1925050508015613323575060015b156133695761336860006040518060400160405280601281526020017f7265766f6b652073686f756c64206661696c0000000000000000000000000000815250613cbb565b5b6133eb8473ffffffffffffffffffffffffffffffffffffffff166324d7806c846040518263ffffffff1660e01b81526004016133a59190613ffc565b602060405180830381865afa1580156133c2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906133e69190614048565b613c75565b61346d8373ffffffffffffffffffffffffffffffffffffffff1663f3ae2415836040518263ffffffff1660e01b81526004016134279190613ffc565b602060405180830381865afa158015613444573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906134689190614048565b613c75565b50505050565b60008060019054906101000a900460ff16156134a057600060019054906101000a900460ff16905061360d565b60006134aa613d25565b156136085760007f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d60001c60601b60601c73ffffffffffffffffffffffffffffffffffffffff167f667f9d70ca411d70ead50d8d5c22070dafc36ad75f3dcf5e7237b22ade9aecc47f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d60001c60601b60601c7f6661696c6564000000000000000000000000000000000000000000000000000060405160200161356e9291906140f1565b60405160208183030381529060405260405160200161358e9291906141d8565b6040516020818303038152906040526040516135aa9190614200565b6000604051808303816000865af19150503d80600081146135e7576040519150601f19603f3d011682016040523d82523d6000602084013e6135ec565b606091505b50915050808060200190518101906136049190614048565b9150505b809150505b90565b6136b6600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1336040518263ffffffff1660e01b815260040161366e9190613ffc565b602060405180830381865afa15801561368b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906136af91906140ab565b6002613d05565b565b613772600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1730fa8ea536be85f32724d57a37758761b864161236040518263ffffffff1660e01b815260040161372a9190613ffc565b602060405180830381865afa158015613747573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061376b91906140ab565b6000613d05565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043730fa8ea536be85f32724d57a37758761b864161236040518263ffffffff1660e01b81526004016137e19190613ffc565b600060405180830381600087803b1580156137fb57600080fd5b505af115801561380f573d6000803e3d6000fd5b50505050565b565b600060405161382590613f78565b604051809103906000f080158015613841573d6000803e3d6000fd5b509050600060405161385290613f78565b604051809103906000f08015801561386e573d6000803e3d6000fd5b5090506138f48273ffffffffffffffffffffffffffffffffffffffff166324d7806c836040518263ffffffff1660e01b81526004016138ad9190613ffc565b602060405180830381865afa1580156138ca573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906138ee9190614048565b15613c75565b5050565b600060405161390690613f78565b604051809103906000f080158015613922573d6000803e3d6000fd5b509050600060405161393390613f78565b604051809103906000f08015801561394f573d6000803e3d6000fd5b509050600082905060008290506139df8473ffffffffffffffffffffffffffffffffffffffff16639015d371846040518263ffffffff1660e01b81526004016139989190613ffc565b602060405180830381865afa1580156139b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906139d99190614048565b15613c75565b613a628473ffffffffffffffffffffffffffffffffffffffff1663f3ae2415836040518263ffffffff1660e01b8152600401613a1b9190613ffc565b602060405180830381865afa158015613a38573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613a5c9190614048565b15613c75565b600060029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d0ebdbe7826040518263ffffffff1660e01b8152600401613abd9190613ffc565b600060405180830381600087803b158015613ad757600080fd5b505af1158015613aeb573d6000803e3d6000fd5b50505050613b718373ffffffffffffffffffffffffffffffffffffffff1663f3ae2415836040518263ffffffff1660e01b8152600401613b2b9190613ffc565b602060405180830381865afa158015613b48573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613b6c9190614048565b613c75565b8273ffffffffffffffffffffffffffffffffffffffff16630aaf7043836040518263ffffffff1660e01b8152600401613baa9190613ffc565b600060405180830381600087803b158015613bc457600080fd5b505af1158015613bd8573d6000803e3d6000fd5b50505050613c5e8473ffffffffffffffffffffffffffffffffffffffff16639015d371846040518263ffffffff1660e01b8152600401613c189190613ffc565b602060405180830381865afa158015613c35573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613c599190614048565b613c75565b50505050565b60008054906101000a900460ff1681565b80613cb8577f41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50604051613ca790614274565b60405180910390a1613cb7613d4e565b5b50565b81613d01577f280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf358381604051613cef9190614335565b60405180910390a1613d0082613c75565b5b5050565b613d2182826003811115613d1c57613d1b61436a565b5b613ec1565b5050565b60008060009050737109709ecfa91a80626ff3989d68f67f5b1dd12d3b90506000811191505090565b613d56613d25565b15613ea45760007f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d60001c60601b60601c73ffffffffffffffffffffffffffffffffffffffff167f70ca10bbd0dbfd9020a9f4b13402c16cb120705e0d1c0aeab10fa353ae586fc47f885cb69240a935d632d79c317109709ecfa91a80626ff3989d68f67f5b1dd12d60001c60601b60601c7f6661696c65640000000000000000000000000000000000000000000000000000600160001b604051602001613e2093929190614399565b604051602081830303815290604052604051602001613e409291906141d8565b604051602081830303815290604052604051613e5c9190614200565b6000604051808303816000865af19150503d8060008114613e99576040519150601f19603f3d011682016040523d82523d6000602084013e613e9e565b606091505b50509050505b6001600060016101000a81548160ff021916908315150217905550565b808214613f74577f41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50604051613ef590614442565b60405180910390a17fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a882604051613f2c91906144bd565b60405180910390a17fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a881604051613f639190614537565b60405180910390a1613f73613d4e565b5b5050565b610e088061456683390190565b60008115159050919050565b613f9a81613f85565b82525050565b6000602082019050613fb56000830184613f91565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000613fe682613fbb565b9050919050565b613ff681613fdb565b82525050565b60006020820190506140116000830184613fed565b92915050565b600080fd5b61402581613f85565b811461403057600080fd5b50565b6000815190506140428161401c565b92915050565b60006020828403121561405e5761405d614017565b5b600061406c84828501614033565b91505092915050565b6000819050919050565b61408881614075565b811461409357600080fd5b50565b6000815190506140a58161407f565b92915050565b6000602082840312156140c1576140c0614017565b5b60006140cf84828501614096565b91505092915050565b6000819050919050565b6140eb816140d8565b82525050565b60006040820190506141066000830185613fed565b61411360208301846140e2565b9392505050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b6000819050919050565b61416161415c8261411a565b614146565b82525050565b600081519050919050565b600081905092915050565b60005b8381101561419b578082015181840152602081019050614180565b60008484015250505050565b60006141b282614167565b6141bc8185614172565b93506141cc81856020860161417d565b80840191505092915050565b60006141e48285614150565b6004820191506141f482846141a7565b91508190509392505050565b600061420c82846141a7565b915081905092915050565b600082825260208201905092915050565b7f4572726f723a20417373657274696f6e204661696c6564000000000000000000600082015250565b600061425e601783614217565b915061426982614228565b602082019050919050565b6000602082019050818103600083015261428d81614251565b9050919050565b7f4572726f72000000000000000000000000000000000000000000000000000000600082015250565b60006142ca600583614217565b91506142d582614294565b602082019050919050565b600081519050919050565b6000601f19601f8301169050919050565b6000614307826142e0565b6143118185614217565b935061432181856020860161417d565b61432a816142eb565b840191505092915050565b6000604082019050818103600083015261434e816142bd565b9050818103602083015261436281846142fc565b905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60006060820190506143ae6000830186613fed565b6143bb60208301856140e2565b6143c860408301846140e2565b949350505050565b7f4572726f723a2061203d3d2062206e6f7420736174697366696564205b75696e60008201527f745d000000000000000000000000000000000000000000000000000000000000602082015250565b600061442c602283614217565b9150614437826143d0565b604082019050919050565b6000602082019050818103600083015261445b8161441f565b9050919050565b7f2020202020204c65667400000000000000000000000000000000000000000000600082015250565b6000614498600a83614217565b91506144a382614462565b602082019050919050565b6144b781614075565b82525050565b600060408201905081810360008301526144d68161448b565b90506144e560208301846144ae565b92915050565b7f2020202020526967687400000000000000000000000000000000000000000000600082015250565b6000614521600a83614217565b915061452c826144eb565b602082019050919050565b6000604082019050818103600083015261455081614514565b905061455f60208301846144ae565b9291505056fe608060405234801561001057600080fd5b5073020000000000000000000000000000000000000261004261003761008960201b60201c565b61009160201b60201c565b80600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050610155565b600033905090565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b610ca4806101646000396000f3fe608060405234801561001057600080fd5b50600436106100a95760003560e01c806374a8f1031161007157806374a8f1031461012a5780638da5cb5b146101465780639015d37114610164578063d0ebdbe714610194578063f2fde38b146101b0578063f3ae2415146101cc576100a9565b80630aaf7043146100ae57806324d7806c146100ca5780636cd5c39b146100fa578063704b6c0214610104578063715018a614610120575b600080fd5b6100c860048036038101906100c391906109a7565b6101fc565b005b6100e460048036038101906100df91906109a7565b610210565b6040516100f191906109ef565b60405180910390f35b6101026102bd565b005b61011e600480360381019061011991906109a7565b6102e9565b005b6101286102fd565b005b610144600480360381019061013f91906109a7565b610311565b005b61014e610325565b60405161015b9190610a19565b60405180910390f35b61017e600480360381019061017991906109a7565b61034e565b60405161018b91906109ef565b60405180910390f35b6101ae60048036038101906101a991906109a7565b6103fc565b005b6101ca60048036038101906101c591906109a7565b610410565b005b6101e660048036038101906101e191906109a7565b610493565b6040516101f391906109ef565b60405180910390f35b610204610540565b61020d816105be565b50565b600080600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b815260040161026e9190610a19565b602060405180830381865afa15801561028b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102af9190610a6a565b905060028114915050919050565b6040516102c990610938565b604051809103906000f0801580156102e5573d6000803e3d6000fd5b5050565b6102f1610540565b6102fa8161064e565b50565b610305610540565b61030f60006106de565b565b610319610540565b610322816107a2565b50565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b600080600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b81526004016103ac9190610a19565b602060405180830381865afa1580156103c9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103ed9190610a6a565b90506000811415915050919050565b610404610540565b61040d816108a0565b50565b610418610540565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603610487576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161047e90610b1a565b60405180910390fd5b610490816106de565b50565b600080600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eb54dae1846040518263ffffffff1660e01b81526004016104f19190610a19565b602060405180830381865afa15801561050e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105329190610a6a565b905060038114915050919050565b610548610930565b73ffffffffffffffffffffffffffffffffffffffff16610566610325565b73ffffffffffffffffffffffffffffffffffffffff16146105bc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105b390610b86565b60405180910390fd5b565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630aaf7043826040518263ffffffff1660e01b81526004016106199190610a19565b600060405180830381600087803b15801561063357600080fd5b505af1158015610647573d6000803e3d6000fd5b5050505050565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663704b6c02826040518263ffffffff1660e01b81526004016106a99190610a19565b600060405180830381600087803b1580156106c357600080fd5b505af11580156106d7573d6000803e3d6000fd5b5050505050565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b8073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1603610810576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161080790610bf2565b60405180910390fd5b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638c6bfb3b826040518263ffffffff1660e01b815260040161086b9190610a19565b600060405180830381600087803b15801561088557600080fd5b505af1158015610899573d6000803e3d6000fd5b5050505050565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d0ebdbe7826040518263ffffffff1660e01b81526004016108fb9190610a19565b600060405180830381600087803b15801561091557600080fd5b505af1158015610929573d6000803e3d6000fd5b5050505050565b600033905090565b605c80610c1383390190565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061097482610949565b9050919050565b61098481610969565b811461098f57600080fd5b50565b6000813590506109a18161097b565b92915050565b6000602082840312156109bd576109bc610944565b5b60006109cb84828501610992565b91505092915050565b60008115159050919050565b6109e9816109d4565b82525050565b6000602082019050610a0460008301846109e0565b92915050565b610a1381610969565b82525050565b6000602082019050610a2e6000830184610a0a565b92915050565b6000819050919050565b610a4781610a34565b8114610a5257600080fd5b50565b600081519050610a6481610a3e565b92915050565b600060208284031215610a8057610a7f610944565b5b6000610a8e84828501610a55565b91505092915050565b600082825260208201905092915050565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160008201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b6000610b04602683610a97565b9150610b0f82610aa8565b604082019050919050565b60006020820190508181036000830152610b3381610af7565b9050919050565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572600082015250565b6000610b70602083610a97565b9150610b7b82610b3a565b602082019050919050565b60006020820190508181036000830152610b9f81610b63565b9050919050565b7f63616e6e6f74207265766f6b65206f776e20726f6c6500000000000000000000600082015250565b6000610bdc601683610a97565b9150610be782610ba6565b602082019050919050565b60006020820190508181036000830152610c0b81610bcf565b905091905056fe6080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea264697066735822122095e71fe7b8a7d8101f30ba68f5e4e09352023917522f32686f9c7d10ae36668964736f6c634300081a0033a264697066735822122000455b596227b71c5362847cc2589f7ae8ffbe514360a14e4f7b4cc58ba7718364736f6c634300081a0033a264697066735822122017c6d8bd0de6496c337be8b1f9247f517d97740624705efda67c79ef666b563a64736f6c634300081a0033",
}

// ExampleTxAllowListTestABI is the input ABI used to generate the binding from.
// Deprecated: Use ExampleTxAllowListTestMetaData.ABI instead.
var ExampleTxAllowListTestABI = ExampleTxAllowListTestMetaData.ABI

// ExampleTxAllowListTestBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use ExampleTxAllowListTestMetaData.Bin instead.
var ExampleTxAllowListTestBin = ExampleTxAllowListTestMetaData.Bin

// DeployExampleTxAllowListTest deploys a new Ethereum contract, binding an instance of ExampleTxAllowListTest to it.
func DeployExampleTxAllowListTest(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ExampleTxAllowListTest, error) {
	parsed, err := ExampleTxAllowListTestMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(ExampleTxAllowListTestBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ExampleTxAllowListTest{ExampleTxAllowListTestCaller: ExampleTxAllowListTestCaller{contract: contract}, ExampleTxAllowListTestTransactor: ExampleTxAllowListTestTransactor{contract: contract}, ExampleTxAllowListTestFilterer: ExampleTxAllowListTestFilterer{contract: contract}}, nil
}

// ExampleTxAllowListTest is an auto generated Go binding around an Ethereum contract.
type ExampleTxAllowListTest struct {
	ExampleTxAllowListTestCaller     // Read-only binding to the contract
	ExampleTxAllowListTestTransactor // Write-only binding to the contract
	ExampleTxAllowListTestFilterer   // Log filterer for contract events
}

// ExampleTxAllowListTestCaller is an auto generated read-only Go binding around an Ethereum contract.
type ExampleTxAllowListTestCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExampleTxAllowListTestTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ExampleTxAllowListTestTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExampleTxAllowListTestFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ExampleTxAllowListTestFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ExampleTxAllowListTestSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ExampleTxAllowListTestSession struct {
	Contract     *ExampleTxAllowListTest // Generic contract binding to set the session for
	CallOpts     bind.CallOpts           // Call options to use throughout this session
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// ExampleTxAllowListTestCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ExampleTxAllowListTestCallerSession struct {
	Contract *ExampleTxAllowListTestCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts                 // Call options to use throughout this session
}

// ExampleTxAllowListTestTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ExampleTxAllowListTestTransactorSession struct {
	Contract     *ExampleTxAllowListTestTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts                 // Transaction auth options to use throughout this session
}

// ExampleTxAllowListTestRaw is an auto generated low-level Go binding around an Ethereum contract.
type ExampleTxAllowListTestRaw struct {
	Contract *ExampleTxAllowListTest // Generic contract binding to access the raw methods on
}

// ExampleTxAllowListTestCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ExampleTxAllowListTestCallerRaw struct {
	Contract *ExampleTxAllowListTestCaller // Generic read-only contract binding to access the raw methods on
}

// ExampleTxAllowListTestTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ExampleTxAllowListTestTransactorRaw struct {
	Contract *ExampleTxAllowListTestTransactor // Generic write-only contract binding to access the raw methods on
}

// NewExampleTxAllowListTest creates a new instance of ExampleTxAllowListTest, bound to a specific deployed contract.
func NewExampleTxAllowListTest(address common.Address, backend bind.ContractBackend) (*ExampleTxAllowListTest, error) {
	contract, err := bindExampleTxAllowListTest(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ExampleTxAllowListTest{ExampleTxAllowListTestCaller: ExampleTxAllowListTestCaller{contract: contract}, ExampleTxAllowListTestTransactor: ExampleTxAllowListTestTransactor{contract: contract}, ExampleTxAllowListTestFilterer: ExampleTxAllowListTestFilterer{contract: contract}}, nil
}

// NewExampleTxAllowListTestCaller creates a new read-only instance of ExampleTxAllowListTest, bound to a specific deployed contract.
func NewExampleTxAllowListTestCaller(address common.Address, caller bind.ContractCaller) (*ExampleTxAllowListTestCaller, error) {
	contract, err := bindExampleTxAllowListTest(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ExampleTxAllowListTestCaller{contract: contract}, nil
}

// NewExampleTxAllowListTestTransactor creates a new write-only instance of ExampleTxAllowListTest, bound to a specific deployed contract.
func NewExampleTxAllowListTestTransactor(address common.Address, transactor bind.ContractTransactor) (*ExampleTxAllowListTestTransactor, error) {
	contract, err := bindExampleTxAllowListTest(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ExampleTxAllowListTestTransactor{contract: contract}, nil
}

// NewExampleTxAllowListTestFilterer creates a new log filterer instance of ExampleTxAllowListTest, bound to a specific deployed contract.
func NewExampleTxAllowListTestFilterer(address common.Address, filterer bind.ContractFilterer) (*ExampleTxAllowListTestFilterer, error) {
	contract, err := bindExampleTxAllowListTest(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ExampleTxAllowListTestFilterer{contract: contract}, nil
}

// bindExampleTxAllowListTest binds a generic wrapper to an already deployed contract.
func bindExampleTxAllowListTest(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ExampleTxAllowListTestMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ExampleTxAllowListTest *ExampleTxAllowListTestRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ExampleTxAllowListTest.Contract.ExampleTxAllowListTestCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ExampleTxAllowListTest *ExampleTxAllowListTestRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.ExampleTxAllowListTestTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ExampleTxAllowListTest *ExampleTxAllowListTestRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.ExampleTxAllowListTestTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ExampleTxAllowListTest *ExampleTxAllowListTestCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ExampleTxAllowListTest.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.contract.Transact(opts, method, params...)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestCaller) ISTEST(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _ExampleTxAllowListTest.contract.Call(opts, &out, "IS_TEST")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestSession) ISTEST() (bool, error) {
	return _ExampleTxAllowListTest.Contract.ISTEST(&_ExampleTxAllowListTest.CallOpts)
}

// ISTEST is a free data retrieval call binding the contract method 0xfa7626d4.
//
// Solidity: function IS_TEST() view returns(bool)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestCallerSession) ISTEST() (bool, error) {
	return _ExampleTxAllowListTest.Contract.ISTEST(&_ExampleTxAllowListTest.CallOpts)
}

// Failed is a paid mutator transaction binding the contract method 0xba414fa6.
//
// Solidity: function failed() returns(bool)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactor) Failed(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.contract.Transact(opts, "failed")
}

// Failed is a paid mutator transaction binding the contract method 0xba414fa6.
//
// Solidity: function failed() returns(bool)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestSession) Failed() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.Failed(&_ExampleTxAllowListTest.TransactOpts)
}

// Failed is a paid mutator transaction binding the contract method 0xba414fa6.
//
// Solidity: function failed() returns(bool)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactorSession) Failed() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.Failed(&_ExampleTxAllowListTest.TransactOpts)
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactor) SetUp(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.contract.Transact(opts, "setUp")
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestSession) SetUp() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.SetUp(&_ExampleTxAllowListTest.TransactOpts)
}

// SetUp is a paid mutator transaction binding the contract method 0x0a9254e4.
//
// Solidity: function setUp() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactorSession) SetUp() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.SetUp(&_ExampleTxAllowListTest.TransactOpts)
}

// StepAddContractAsAdmin is a paid mutator transaction binding the contract method 0x2bf9fc8c.
//
// Solidity: function step_addContractAsAdmin() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactor) StepAddContractAsAdmin(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.contract.Transact(opts, "step_addContractAsAdmin")
}

// StepAddContractAsAdmin is a paid mutator transaction binding the contract method 0x2bf9fc8c.
//
// Solidity: function step_addContractAsAdmin() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestSession) StepAddContractAsAdmin() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepAddContractAsAdmin(&_ExampleTxAllowListTest.TransactOpts)
}

// StepAddContractAsAdmin is a paid mutator transaction binding the contract method 0x2bf9fc8c.
//
// Solidity: function step_addContractAsAdmin() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactorSession) StepAddContractAsAdmin() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepAddContractAsAdmin(&_ExampleTxAllowListTest.TransactOpts)
}

// StepAdminCanRevoke is a paid mutator transaction binding the contract method 0x4f2fd73b.
//
// Solidity: function step_adminCanRevoke() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactor) StepAdminCanRevoke(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.contract.Transact(opts, "step_adminCanRevoke")
}

// StepAdminCanRevoke is a paid mutator transaction binding the contract method 0x4f2fd73b.
//
// Solidity: function step_adminCanRevoke() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestSession) StepAdminCanRevoke() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepAdminCanRevoke(&_ExampleTxAllowListTest.TransactOpts)
}

// StepAdminCanRevoke is a paid mutator transaction binding the contract method 0x4f2fd73b.
//
// Solidity: function step_adminCanRevoke() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactorSession) StepAdminCanRevoke() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepAdminCanRevoke(&_ExampleTxAllowListTest.TransactOpts)
}

// StepCanDeploy is a paid mutator transaction binding the contract method 0x8d20a19f.
//
// Solidity: function step_canDeploy() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactor) StepCanDeploy(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.contract.Transact(opts, "step_canDeploy")
}

// StepCanDeploy is a paid mutator transaction binding the contract method 0x8d20a19f.
//
// Solidity: function step_canDeploy() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestSession) StepCanDeploy() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepCanDeploy(&_ExampleTxAllowListTest.TransactOpts)
}

// StepCanDeploy is a paid mutator transaction binding the contract method 0x8d20a19f.
//
// Solidity: function step_canDeploy() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactorSession) StepCanDeploy() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepCanDeploy(&_ExampleTxAllowListTest.TransactOpts)
}

// StepContractOwnerIsAdmin is a paid mutator transaction binding the contract method 0x199b9a56.
//
// Solidity: function step_contractOwnerIsAdmin() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactor) StepContractOwnerIsAdmin(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.contract.Transact(opts, "step_contractOwnerIsAdmin")
}

// StepContractOwnerIsAdmin is a paid mutator transaction binding the contract method 0x199b9a56.
//
// Solidity: function step_contractOwnerIsAdmin() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestSession) StepContractOwnerIsAdmin() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepContractOwnerIsAdmin(&_ExampleTxAllowListTest.TransactOpts)
}

// StepContractOwnerIsAdmin is a paid mutator transaction binding the contract method 0x199b9a56.
//
// Solidity: function step_contractOwnerIsAdmin() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactorSession) StepContractOwnerIsAdmin() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepContractOwnerIsAdmin(&_ExampleTxAllowListTest.TransactOpts)
}

// StepEnableOther is a paid mutator transaction binding the contract method 0xe6617ee3.
//
// Solidity: function step_enableOther() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactor) StepEnableOther(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.contract.Transact(opts, "step_enableOther")
}

// StepEnableOther is a paid mutator transaction binding the contract method 0xe6617ee3.
//
// Solidity: function step_enableOther() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestSession) StepEnableOther() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepEnableOther(&_ExampleTxAllowListTest.TransactOpts)
}

// StepEnableOther is a paid mutator transaction binding the contract method 0xe6617ee3.
//
// Solidity: function step_enableOther() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactorSession) StepEnableOther() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepEnableOther(&_ExampleTxAllowListTest.TransactOpts)
}

// StepEnableThroughContract is a paid mutator transaction binding the contract method 0x33a49bb0.
//
// Solidity: function step_enableThroughContract() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactor) StepEnableThroughContract(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.contract.Transact(opts, "step_enableThroughContract")
}

// StepEnableThroughContract is a paid mutator transaction binding the contract method 0x33a49bb0.
//
// Solidity: function step_enableThroughContract() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestSession) StepEnableThroughContract() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepEnableThroughContract(&_ExampleTxAllowListTest.TransactOpts)
}

// StepEnableThroughContract is a paid mutator transaction binding the contract method 0x33a49bb0.
//
// Solidity: function step_enableThroughContract() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactorSession) StepEnableThroughContract() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepEnableThroughContract(&_ExampleTxAllowListTest.TransactOpts)
}

// StepExampleAllowListReturnsTestIsAdmin is a paid mutator transaction binding the contract method 0x82204bc4.
//
// Solidity: function step_exampleAllowListReturnsTestIsAdmin() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactor) StepExampleAllowListReturnsTestIsAdmin(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.contract.Transact(opts, "step_exampleAllowListReturnsTestIsAdmin")
}

// StepExampleAllowListReturnsTestIsAdmin is a paid mutator transaction binding the contract method 0x82204bc4.
//
// Solidity: function step_exampleAllowListReturnsTestIsAdmin() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestSession) StepExampleAllowListReturnsTestIsAdmin() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepExampleAllowListReturnsTestIsAdmin(&_ExampleTxAllowListTest.TransactOpts)
}

// StepExampleAllowListReturnsTestIsAdmin is a paid mutator transaction binding the contract method 0x82204bc4.
//
// Solidity: function step_exampleAllowListReturnsTestIsAdmin() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactorSession) StepExampleAllowListReturnsTestIsAdmin() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepExampleAllowListReturnsTestIsAdmin(&_ExampleTxAllowListTest.TransactOpts)
}

// StepFromOther is a paid mutator transaction binding the contract method 0xea442d70.
//
// Solidity: function step_fromOther() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactor) StepFromOther(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.contract.Transact(opts, "step_fromOther")
}

// StepFromOther is a paid mutator transaction binding the contract method 0xea442d70.
//
// Solidity: function step_fromOther() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestSession) StepFromOther() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepFromOther(&_ExampleTxAllowListTest.TransactOpts)
}

// StepFromOther is a paid mutator transaction binding the contract method 0xea442d70.
//
// Solidity: function step_fromOther() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactorSession) StepFromOther() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepFromOther(&_ExampleTxAllowListTest.TransactOpts)
}

// StepManagerCanAllow is a paid mutator transaction binding the contract method 0xf7e4e82d.
//
// Solidity: function step_managerCanAllow() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactor) StepManagerCanAllow(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.contract.Transact(opts, "step_managerCanAllow")
}

// StepManagerCanAllow is a paid mutator transaction binding the contract method 0xf7e4e82d.
//
// Solidity: function step_managerCanAllow() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestSession) StepManagerCanAllow() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepManagerCanAllow(&_ExampleTxAllowListTest.TransactOpts)
}

// StepManagerCanAllow is a paid mutator transaction binding the contract method 0xf7e4e82d.
//
// Solidity: function step_managerCanAllow() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactorSession) StepManagerCanAllow() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepManagerCanAllow(&_ExampleTxAllowListTest.TransactOpts)
}

// StepManagerCanDeploy is a paid mutator transaction binding the contract method 0x110feff6.
//
// Solidity: function step_managerCanDeploy() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactor) StepManagerCanDeploy(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.contract.Transact(opts, "step_managerCanDeploy")
}

// StepManagerCanDeploy is a paid mutator transaction binding the contract method 0x110feff6.
//
// Solidity: function step_managerCanDeploy() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestSession) StepManagerCanDeploy() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepManagerCanDeploy(&_ExampleTxAllowListTest.TransactOpts)
}

// StepManagerCanDeploy is a paid mutator transaction binding the contract method 0x110feff6.
//
// Solidity: function step_managerCanDeploy() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactorSession) StepManagerCanDeploy() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepManagerCanDeploy(&_ExampleTxAllowListTest.TransactOpts)
}

// StepManagerCanRevoke is a paid mutator transaction binding the contract method 0x5838f8f1.
//
// Solidity: function step_managerCanRevoke() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactor) StepManagerCanRevoke(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.contract.Transact(opts, "step_managerCanRevoke")
}

// StepManagerCanRevoke is a paid mutator transaction binding the contract method 0x5838f8f1.
//
// Solidity: function step_managerCanRevoke() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestSession) StepManagerCanRevoke() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepManagerCanRevoke(&_ExampleTxAllowListTest.TransactOpts)
}

// StepManagerCanRevoke is a paid mutator transaction binding the contract method 0x5838f8f1.
//
// Solidity: function step_managerCanRevoke() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactorSession) StepManagerCanRevoke() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepManagerCanRevoke(&_ExampleTxAllowListTest.TransactOpts)
}

// StepManagerCannotGrantAdmin is a paid mutator transaction binding the contract method 0x1ab50669.
//
// Solidity: function step_managerCannotGrantAdmin() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactor) StepManagerCannotGrantAdmin(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.contract.Transact(opts, "step_managerCannotGrantAdmin")
}

// StepManagerCannotGrantAdmin is a paid mutator transaction binding the contract method 0x1ab50669.
//
// Solidity: function step_managerCannotGrantAdmin() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestSession) StepManagerCannotGrantAdmin() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepManagerCannotGrantAdmin(&_ExampleTxAllowListTest.TransactOpts)
}

// StepManagerCannotGrantAdmin is a paid mutator transaction binding the contract method 0x1ab50669.
//
// Solidity: function step_managerCannotGrantAdmin() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactorSession) StepManagerCannotGrantAdmin() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepManagerCannotGrantAdmin(&_ExampleTxAllowListTest.TransactOpts)
}

// StepManagerCannotGrantManager is a paid mutator transaction binding the contract method 0x51605581.
//
// Solidity: function step_managerCannotGrantManager() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactor) StepManagerCannotGrantManager(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.contract.Transact(opts, "step_managerCannotGrantManager")
}

// StepManagerCannotGrantManager is a paid mutator transaction binding the contract method 0x51605581.
//
// Solidity: function step_managerCannotGrantManager() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestSession) StepManagerCannotGrantManager() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepManagerCannotGrantManager(&_ExampleTxAllowListTest.TransactOpts)
}

// StepManagerCannotGrantManager is a paid mutator transaction binding the contract method 0x51605581.
//
// Solidity: function step_managerCannotGrantManager() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactorSession) StepManagerCannotGrantManager() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepManagerCannotGrantManager(&_ExampleTxAllowListTest.TransactOpts)
}

// StepManagerCannotRevokeAdmin is a paid mutator transaction binding the contract method 0xaee9e308.
//
// Solidity: function step_managerCannotRevokeAdmin() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactor) StepManagerCannotRevokeAdmin(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.contract.Transact(opts, "step_managerCannotRevokeAdmin")
}

// StepManagerCannotRevokeAdmin is a paid mutator transaction binding the contract method 0xaee9e308.
//
// Solidity: function step_managerCannotRevokeAdmin() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestSession) StepManagerCannotRevokeAdmin() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepManagerCannotRevokeAdmin(&_ExampleTxAllowListTest.TransactOpts)
}

// StepManagerCannotRevokeAdmin is a paid mutator transaction binding the contract method 0xaee9e308.
//
// Solidity: function step_managerCannotRevokeAdmin() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactorSession) StepManagerCannotRevokeAdmin() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepManagerCannotRevokeAdmin(&_ExampleTxAllowListTest.TransactOpts)
}

// StepManagerCannotRevokeManager is a paid mutator transaction binding the contract method 0x84725ce4.
//
// Solidity: function step_managerCannotRevokeManager() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactor) StepManagerCannotRevokeManager(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.contract.Transact(opts, "step_managerCannotRevokeManager")
}

// StepManagerCannotRevokeManager is a paid mutator transaction binding the contract method 0x84725ce4.
//
// Solidity: function step_managerCannotRevokeManager() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestSession) StepManagerCannotRevokeManager() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepManagerCannotRevokeManager(&_ExampleTxAllowListTest.TransactOpts)
}

// StepManagerCannotRevokeManager is a paid mutator transaction binding the contract method 0x84725ce4.
//
// Solidity: function step_managerCannotRevokeManager() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactorSession) StepManagerCannotRevokeManager() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepManagerCannotRevokeManager(&_ExampleTxAllowListTest.TransactOpts)
}

// StepNewAddressHasNoRole is a paid mutator transaction binding the contract method 0x33cb47db.
//
// Solidity: function step_newAddressHasNoRole() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactor) StepNewAddressHasNoRole(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.contract.Transact(opts, "step_newAddressHasNoRole")
}

// StepNewAddressHasNoRole is a paid mutator transaction binding the contract method 0x33cb47db.
//
// Solidity: function step_newAddressHasNoRole() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestSession) StepNewAddressHasNoRole() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepNewAddressHasNoRole(&_ExampleTxAllowListTest.TransactOpts)
}

// StepNewAddressHasNoRole is a paid mutator transaction binding the contract method 0x33cb47db.
//
// Solidity: function step_newAddressHasNoRole() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactorSession) StepNewAddressHasNoRole() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepNewAddressHasNoRole(&_ExampleTxAllowListTest.TransactOpts)
}

// StepNoRoleCannotEnableItself is a paid mutator transaction binding the contract method 0x6499010a.
//
// Solidity: function step_noRoleCannotEnableItself() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactor) StepNoRoleCannotEnableItself(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.contract.Transact(opts, "step_noRoleCannotEnableItself")
}

// StepNoRoleCannotEnableItself is a paid mutator transaction binding the contract method 0x6499010a.
//
// Solidity: function step_noRoleCannotEnableItself() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestSession) StepNoRoleCannotEnableItself() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepNoRoleCannotEnableItself(&_ExampleTxAllowListTest.TransactOpts)
}

// StepNoRoleCannotEnableItself is a paid mutator transaction binding the contract method 0x6499010a.
//
// Solidity: function step_noRoleCannotEnableItself() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactorSession) StepNoRoleCannotEnableItself() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepNoRoleCannotEnableItself(&_ExampleTxAllowListTest.TransactOpts)
}

// StepNoRoleIsNotAdmin is a paid mutator transaction binding the contract method 0xf26c562c.
//
// Solidity: function step_noRoleIsNotAdmin() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactor) StepNoRoleIsNotAdmin(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.contract.Transact(opts, "step_noRoleIsNotAdmin")
}

// StepNoRoleIsNotAdmin is a paid mutator transaction binding the contract method 0xf26c562c.
//
// Solidity: function step_noRoleIsNotAdmin() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestSession) StepNoRoleIsNotAdmin() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepNoRoleIsNotAdmin(&_ExampleTxAllowListTest.TransactOpts)
}

// StepNoRoleIsNotAdmin is a paid mutator transaction binding the contract method 0xf26c562c.
//
// Solidity: function step_noRoleIsNotAdmin() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactorSession) StepNoRoleIsNotAdmin() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepNoRoleIsNotAdmin(&_ExampleTxAllowListTest.TransactOpts)
}

// StepOnlyAdminCanEnable is a paid mutator transaction binding the contract method 0x6604c69f.
//
// Solidity: function step_onlyAdminCanEnable() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactor) StepOnlyAdminCanEnable(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.contract.Transact(opts, "step_onlyAdminCanEnable")
}

// StepOnlyAdminCanEnable is a paid mutator transaction binding the contract method 0x6604c69f.
//
// Solidity: function step_onlyAdminCanEnable() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestSession) StepOnlyAdminCanEnable() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepOnlyAdminCanEnable(&_ExampleTxAllowListTest.TransactOpts)
}

// StepOnlyAdminCanEnable is a paid mutator transaction binding the contract method 0x6604c69f.
//
// Solidity: function step_onlyAdminCanEnable() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactorSession) StepOnlyAdminCanEnable() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepOnlyAdminCanEnable(&_ExampleTxAllowListTest.TransactOpts)
}

// StepOnlyAdminCanRevoke is a paid mutator transaction binding the contract method 0x9d127233.
//
// Solidity: function step_onlyAdminCanRevoke() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactor) StepOnlyAdminCanRevoke(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.contract.Transact(opts, "step_onlyAdminCanRevoke")
}

// StepOnlyAdminCanRevoke is a paid mutator transaction binding the contract method 0x9d127233.
//
// Solidity: function step_onlyAdminCanRevoke() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestSession) StepOnlyAdminCanRevoke() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepOnlyAdminCanRevoke(&_ExampleTxAllowListTest.TransactOpts)
}

// StepOnlyAdminCanRevoke is a paid mutator transaction binding the contract method 0x9d127233.
//
// Solidity: function step_onlyAdminCanRevoke() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactorSession) StepOnlyAdminCanRevoke() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepOnlyAdminCanRevoke(&_ExampleTxAllowListTest.TransactOpts)
}

// StepPrecompileHasDeployerAsAdmin is a paid mutator transaction binding the contract method 0xc24f26ce.
//
// Solidity: function step_precompileHasDeployerAsAdmin() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactor) StepPrecompileHasDeployerAsAdmin(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ExampleTxAllowListTest.contract.Transact(opts, "step_precompileHasDeployerAsAdmin")
}

// StepPrecompileHasDeployerAsAdmin is a paid mutator transaction binding the contract method 0xc24f26ce.
//
// Solidity: function step_precompileHasDeployerAsAdmin() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestSession) StepPrecompileHasDeployerAsAdmin() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepPrecompileHasDeployerAsAdmin(&_ExampleTxAllowListTest.TransactOpts)
}

// StepPrecompileHasDeployerAsAdmin is a paid mutator transaction binding the contract method 0xc24f26ce.
//
// Solidity: function step_precompileHasDeployerAsAdmin() returns()
func (_ExampleTxAllowListTest *ExampleTxAllowListTestTransactorSession) StepPrecompileHasDeployerAsAdmin() (*types.Transaction, error) {
	return _ExampleTxAllowListTest.Contract.StepPrecompileHasDeployerAsAdmin(&_ExampleTxAllowListTest.TransactOpts)
}

// ExampleTxAllowListTestLogIterator is returned from FilterLog and is used to iterate over the raw logs and unpacked data for Log events raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogIterator struct {
	Event *ExampleTxAllowListTestLog // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleTxAllowListTestLogIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleTxAllowListTestLog)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleTxAllowListTestLog)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleTxAllowListTestLogIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleTxAllowListTestLogIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleTxAllowListTestLog represents a Log event raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLog struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLog is a free log retrieval operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) FilterLog(opts *bind.FilterOpts) (*ExampleTxAllowListTestLogIterator, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.FilterLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return &ExampleTxAllowListTestLogIterator{contract: _ExampleTxAllowListTest.contract, event: "log", logs: logs, sub: sub}, nil
}

// WatchLog is a free log subscription operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) WatchLog(opts *bind.WatchOpts, sink chan<- *ExampleTxAllowListTestLog) (event.Subscription, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.WatchLogs(opts, "log")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleTxAllowListTestLog)
				if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLog is a log parse operation binding the contract event 0x41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f50.
//
// Solidity: event log(string arg0)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) ParseLog(log types.Log) (*ExampleTxAllowListTestLog, error) {
	event := new(ExampleTxAllowListTestLog)
	if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleTxAllowListTestLogAddressIterator is returned from FilterLogAddress and is used to iterate over the raw logs and unpacked data for LogAddress events raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogAddressIterator struct {
	Event *ExampleTxAllowListTestLogAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleTxAllowListTestLogAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleTxAllowListTestLogAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleTxAllowListTestLogAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleTxAllowListTestLogAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleTxAllowListTestLogAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleTxAllowListTestLogAddress represents a LogAddress event raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogAddress struct {
	Arg0 common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogAddress is a free log retrieval operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) FilterLogAddress(opts *bind.FilterOpts) (*ExampleTxAllowListTestLogAddressIterator, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.FilterLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return &ExampleTxAllowListTestLogAddressIterator{contract: _ExampleTxAllowListTest.contract, event: "log_address", logs: logs, sub: sub}, nil
}

// WatchLogAddress is a free log subscription operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) WatchLogAddress(opts *bind.WatchOpts, sink chan<- *ExampleTxAllowListTestLogAddress) (event.Subscription, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.WatchLogs(opts, "log_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleTxAllowListTestLogAddress)
				if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogAddress is a log parse operation binding the contract event 0x7ae74c527414ae135fd97047b12921a5ec3911b804197855d67e25c7b75ee6f3.
//
// Solidity: event log_address(address arg0)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) ParseLogAddress(log types.Log) (*ExampleTxAllowListTestLogAddress, error) {
	event := new(ExampleTxAllowListTestLogAddress)
	if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_address", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleTxAllowListTestLogBytesIterator is returned from FilterLogBytes and is used to iterate over the raw logs and unpacked data for LogBytes events raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogBytesIterator struct {
	Event *ExampleTxAllowListTestLogBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleTxAllowListTestLogBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleTxAllowListTestLogBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleTxAllowListTestLogBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleTxAllowListTestLogBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleTxAllowListTestLogBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleTxAllowListTestLogBytes represents a LogBytes event raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogBytes struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes is a free log retrieval operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) FilterLogBytes(opts *bind.FilterOpts) (*ExampleTxAllowListTestLogBytesIterator, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.FilterLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return &ExampleTxAllowListTestLogBytesIterator{contract: _ExampleTxAllowListTest.contract, event: "log_bytes", logs: logs, sub: sub}, nil
}

// WatchLogBytes is a free log subscription operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) WatchLogBytes(opts *bind.WatchOpts, sink chan<- *ExampleTxAllowListTestLogBytes) (event.Subscription, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.WatchLogs(opts, "log_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleTxAllowListTestLogBytes)
				if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes is a log parse operation binding the contract event 0x23b62ad0584d24a75f0bf3560391ef5659ec6db1269c56e11aa241d637f19b20.
//
// Solidity: event log_bytes(bytes arg0)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) ParseLogBytes(log types.Log) (*ExampleTxAllowListTestLogBytes, error) {
	event := new(ExampleTxAllowListTestLogBytes)
	if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_bytes", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleTxAllowListTestLogBytes32Iterator is returned from FilterLogBytes32 and is used to iterate over the raw logs and unpacked data for LogBytes32 events raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogBytes32Iterator struct {
	Event *ExampleTxAllowListTestLogBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleTxAllowListTestLogBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleTxAllowListTestLogBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleTxAllowListTestLogBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleTxAllowListTestLogBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleTxAllowListTestLogBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleTxAllowListTestLogBytes32 represents a LogBytes32 event raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogBytes32 struct {
	Arg0 [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogBytes32 is a free log retrieval operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) FilterLogBytes32(opts *bind.FilterOpts) (*ExampleTxAllowListTestLogBytes32Iterator, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.FilterLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return &ExampleTxAllowListTestLogBytes32Iterator{contract: _ExampleTxAllowListTest.contract, event: "log_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogBytes32 is a free log subscription operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) WatchLogBytes32(opts *bind.WatchOpts, sink chan<- *ExampleTxAllowListTestLogBytes32) (event.Subscription, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.WatchLogs(opts, "log_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleTxAllowListTestLogBytes32)
				if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogBytes32 is a log parse operation binding the contract event 0xe81699b85113eea1c73e10588b2b035e55893369632173afd43feb192fac64e3.
//
// Solidity: event log_bytes32(bytes32 arg0)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) ParseLogBytes32(log types.Log) (*ExampleTxAllowListTestLogBytes32, error) {
	event := new(ExampleTxAllowListTestLogBytes32)
	if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_bytes32", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleTxAllowListTestLogIntIterator is returned from FilterLogInt and is used to iterate over the raw logs and unpacked data for LogInt events raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogIntIterator struct {
	Event *ExampleTxAllowListTestLogInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleTxAllowListTestLogIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleTxAllowListTestLogInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleTxAllowListTestLogInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleTxAllowListTestLogIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleTxAllowListTestLogIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleTxAllowListTestLogInt represents a LogInt event raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogInt struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogInt is a free log retrieval operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) FilterLogInt(opts *bind.FilterOpts) (*ExampleTxAllowListTestLogIntIterator, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.FilterLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return &ExampleTxAllowListTestLogIntIterator{contract: _ExampleTxAllowListTest.contract, event: "log_int", logs: logs, sub: sub}, nil
}

// WatchLogInt is a free log subscription operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) WatchLogInt(opts *bind.WatchOpts, sink chan<- *ExampleTxAllowListTestLogInt) (event.Subscription, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.WatchLogs(opts, "log_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleTxAllowListTestLogInt)
				if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogInt is a log parse operation binding the contract event 0x0eb5d52624c8d28ada9fc55a8c502ed5aa3fbe2fb6e91b71b5f376882b1d2fb8.
//
// Solidity: event log_int(int256 arg0)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) ParseLogInt(log types.Log) (*ExampleTxAllowListTestLogInt, error) {
	event := new(ExampleTxAllowListTestLogInt)
	if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_int", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleTxAllowListTestLogNamedAddressIterator is returned from FilterLogNamedAddress and is used to iterate over the raw logs and unpacked data for LogNamedAddress events raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogNamedAddressIterator struct {
	Event *ExampleTxAllowListTestLogNamedAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleTxAllowListTestLogNamedAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleTxAllowListTestLogNamedAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleTxAllowListTestLogNamedAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleTxAllowListTestLogNamedAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleTxAllowListTestLogNamedAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleTxAllowListTestLogNamedAddress represents a LogNamedAddress event raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogNamedAddress struct {
	Key string
	Val common.Address
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedAddress is a free log retrieval operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) FilterLogNamedAddress(opts *bind.FilterOpts) (*ExampleTxAllowListTestLogNamedAddressIterator, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.FilterLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return &ExampleTxAllowListTestLogNamedAddressIterator{contract: _ExampleTxAllowListTest.contract, event: "log_named_address", logs: logs, sub: sub}, nil
}

// WatchLogNamedAddress is a free log subscription operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) WatchLogNamedAddress(opts *bind.WatchOpts, sink chan<- *ExampleTxAllowListTestLogNamedAddress) (event.Subscription, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.WatchLogs(opts, "log_named_address")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleTxAllowListTestLogNamedAddress)
				if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedAddress is a log parse operation binding the contract event 0x9c4e8541ca8f0dc1c413f9108f66d82d3cecb1bddbce437a61caa3175c4cc96f.
//
// Solidity: event log_named_address(string key, address val)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) ParseLogNamedAddress(log types.Log) (*ExampleTxAllowListTestLogNamedAddress, error) {
	event := new(ExampleTxAllowListTestLogNamedAddress)
	if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_named_address", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleTxAllowListTestLogNamedBytesIterator is returned from FilterLogNamedBytes and is used to iterate over the raw logs and unpacked data for LogNamedBytes events raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogNamedBytesIterator struct {
	Event *ExampleTxAllowListTestLogNamedBytes // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleTxAllowListTestLogNamedBytesIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleTxAllowListTestLogNamedBytes)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleTxAllowListTestLogNamedBytes)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleTxAllowListTestLogNamedBytesIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleTxAllowListTestLogNamedBytesIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleTxAllowListTestLogNamedBytes represents a LogNamedBytes event raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogNamedBytes struct {
	Key string
	Val []byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes is a free log retrieval operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) FilterLogNamedBytes(opts *bind.FilterOpts) (*ExampleTxAllowListTestLogNamedBytesIterator, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.FilterLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return &ExampleTxAllowListTestLogNamedBytesIterator{contract: _ExampleTxAllowListTest.contract, event: "log_named_bytes", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes is a free log subscription operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) WatchLogNamedBytes(opts *bind.WatchOpts, sink chan<- *ExampleTxAllowListTestLogNamedBytes) (event.Subscription, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.WatchLogs(opts, "log_named_bytes")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleTxAllowListTestLogNamedBytes)
				if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes is a log parse operation binding the contract event 0xd26e16cad4548705e4c9e2d94f98ee91c289085ee425594fd5635fa2964ccf18.
//
// Solidity: event log_named_bytes(string key, bytes val)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) ParseLogNamedBytes(log types.Log) (*ExampleTxAllowListTestLogNamedBytes, error) {
	event := new(ExampleTxAllowListTestLogNamedBytes)
	if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_named_bytes", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleTxAllowListTestLogNamedBytes32Iterator is returned from FilterLogNamedBytes32 and is used to iterate over the raw logs and unpacked data for LogNamedBytes32 events raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogNamedBytes32Iterator struct {
	Event *ExampleTxAllowListTestLogNamedBytes32 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleTxAllowListTestLogNamedBytes32Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleTxAllowListTestLogNamedBytes32)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleTxAllowListTestLogNamedBytes32)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleTxAllowListTestLogNamedBytes32Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleTxAllowListTestLogNamedBytes32Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleTxAllowListTestLogNamedBytes32 represents a LogNamedBytes32 event raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogNamedBytes32 struct {
	Key string
	Val [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedBytes32 is a free log retrieval operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) FilterLogNamedBytes32(opts *bind.FilterOpts) (*ExampleTxAllowListTestLogNamedBytes32Iterator, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.FilterLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return &ExampleTxAllowListTestLogNamedBytes32Iterator{contract: _ExampleTxAllowListTest.contract, event: "log_named_bytes32", logs: logs, sub: sub}, nil
}

// WatchLogNamedBytes32 is a free log subscription operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) WatchLogNamedBytes32(opts *bind.WatchOpts, sink chan<- *ExampleTxAllowListTestLogNamedBytes32) (event.Subscription, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.WatchLogs(opts, "log_named_bytes32")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleTxAllowListTestLogNamedBytes32)
				if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedBytes32 is a log parse operation binding the contract event 0xafb795c9c61e4fe7468c386f925d7a5429ecad9c0495ddb8d38d690614d32f99.
//
// Solidity: event log_named_bytes32(string key, bytes32 val)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) ParseLogNamedBytes32(log types.Log) (*ExampleTxAllowListTestLogNamedBytes32, error) {
	event := new(ExampleTxAllowListTestLogNamedBytes32)
	if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_named_bytes32", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleTxAllowListTestLogNamedDecimalIntIterator is returned from FilterLogNamedDecimalInt and is used to iterate over the raw logs and unpacked data for LogNamedDecimalInt events raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogNamedDecimalIntIterator struct {
	Event *ExampleTxAllowListTestLogNamedDecimalInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleTxAllowListTestLogNamedDecimalIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleTxAllowListTestLogNamedDecimalInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleTxAllowListTestLogNamedDecimalInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleTxAllowListTestLogNamedDecimalIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleTxAllowListTestLogNamedDecimalIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleTxAllowListTestLogNamedDecimalInt represents a LogNamedDecimalInt event raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogNamedDecimalInt struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalInt is a free log retrieval operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) FilterLogNamedDecimalInt(opts *bind.FilterOpts) (*ExampleTxAllowListTestLogNamedDecimalIntIterator, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.FilterLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return &ExampleTxAllowListTestLogNamedDecimalIntIterator{contract: _ExampleTxAllowListTest.contract, event: "log_named_decimal_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalInt is a free log subscription operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) WatchLogNamedDecimalInt(opts *bind.WatchOpts, sink chan<- *ExampleTxAllowListTestLogNamedDecimalInt) (event.Subscription, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.WatchLogs(opts, "log_named_decimal_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleTxAllowListTestLogNamedDecimalInt)
				if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalInt is a log parse operation binding the contract event 0x5da6ce9d51151ba10c09a559ef24d520b9dac5c5b8810ae8434e4d0d86411a95.
//
// Solidity: event log_named_decimal_int(string key, int256 val, uint256 decimals)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) ParseLogNamedDecimalInt(log types.Log) (*ExampleTxAllowListTestLogNamedDecimalInt, error) {
	event := new(ExampleTxAllowListTestLogNamedDecimalInt)
	if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_named_decimal_int", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleTxAllowListTestLogNamedDecimalUintIterator is returned from FilterLogNamedDecimalUint and is used to iterate over the raw logs and unpacked data for LogNamedDecimalUint events raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogNamedDecimalUintIterator struct {
	Event *ExampleTxAllowListTestLogNamedDecimalUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleTxAllowListTestLogNamedDecimalUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleTxAllowListTestLogNamedDecimalUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleTxAllowListTestLogNamedDecimalUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleTxAllowListTestLogNamedDecimalUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleTxAllowListTestLogNamedDecimalUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleTxAllowListTestLogNamedDecimalUint represents a LogNamedDecimalUint event raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogNamedDecimalUint struct {
	Key      string
	Val      *big.Int
	Decimals *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterLogNamedDecimalUint is a free log retrieval operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) FilterLogNamedDecimalUint(opts *bind.FilterOpts) (*ExampleTxAllowListTestLogNamedDecimalUintIterator, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.FilterLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return &ExampleTxAllowListTestLogNamedDecimalUintIterator{contract: _ExampleTxAllowListTest.contract, event: "log_named_decimal_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedDecimalUint is a free log subscription operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) WatchLogNamedDecimalUint(opts *bind.WatchOpts, sink chan<- *ExampleTxAllowListTestLogNamedDecimalUint) (event.Subscription, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.WatchLogs(opts, "log_named_decimal_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleTxAllowListTestLogNamedDecimalUint)
				if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedDecimalUint is a log parse operation binding the contract event 0xeb8ba43ced7537421946bd43e828b8b2b8428927aa8f801c13d934bf11aca57b.
//
// Solidity: event log_named_decimal_uint(string key, uint256 val, uint256 decimals)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) ParseLogNamedDecimalUint(log types.Log) (*ExampleTxAllowListTestLogNamedDecimalUint, error) {
	event := new(ExampleTxAllowListTestLogNamedDecimalUint)
	if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_named_decimal_uint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleTxAllowListTestLogNamedIntIterator is returned from FilterLogNamedInt and is used to iterate over the raw logs and unpacked data for LogNamedInt events raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogNamedIntIterator struct {
	Event *ExampleTxAllowListTestLogNamedInt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleTxAllowListTestLogNamedIntIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleTxAllowListTestLogNamedInt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleTxAllowListTestLogNamedInt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleTxAllowListTestLogNamedIntIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleTxAllowListTestLogNamedIntIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleTxAllowListTestLogNamedInt represents a LogNamedInt event raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogNamedInt struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedInt is a free log retrieval operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) FilterLogNamedInt(opts *bind.FilterOpts) (*ExampleTxAllowListTestLogNamedIntIterator, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.FilterLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return &ExampleTxAllowListTestLogNamedIntIterator{contract: _ExampleTxAllowListTest.contract, event: "log_named_int", logs: logs, sub: sub}, nil
}

// WatchLogNamedInt is a free log subscription operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) WatchLogNamedInt(opts *bind.WatchOpts, sink chan<- *ExampleTxAllowListTestLogNamedInt) (event.Subscription, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.WatchLogs(opts, "log_named_int")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleTxAllowListTestLogNamedInt)
				if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedInt is a log parse operation binding the contract event 0x2fe632779174374378442a8e978bccfbdcc1d6b2b0d81f7e8eb776ab2286f168.
//
// Solidity: event log_named_int(string key, int256 val)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) ParseLogNamedInt(log types.Log) (*ExampleTxAllowListTestLogNamedInt, error) {
	event := new(ExampleTxAllowListTestLogNamedInt)
	if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_named_int", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleTxAllowListTestLogNamedStringIterator is returned from FilterLogNamedString and is used to iterate over the raw logs and unpacked data for LogNamedString events raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogNamedStringIterator struct {
	Event *ExampleTxAllowListTestLogNamedString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleTxAllowListTestLogNamedStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleTxAllowListTestLogNamedString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleTxAllowListTestLogNamedString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleTxAllowListTestLogNamedStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleTxAllowListTestLogNamedStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleTxAllowListTestLogNamedString represents a LogNamedString event raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogNamedString struct {
	Key string
	Val string
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedString is a free log retrieval operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) FilterLogNamedString(opts *bind.FilterOpts) (*ExampleTxAllowListTestLogNamedStringIterator, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.FilterLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return &ExampleTxAllowListTestLogNamedStringIterator{contract: _ExampleTxAllowListTest.contract, event: "log_named_string", logs: logs, sub: sub}, nil
}

// WatchLogNamedString is a free log subscription operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) WatchLogNamedString(opts *bind.WatchOpts, sink chan<- *ExampleTxAllowListTestLogNamedString) (event.Subscription, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.WatchLogs(opts, "log_named_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleTxAllowListTestLogNamedString)
				if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedString is a log parse operation binding the contract event 0x280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583.
//
// Solidity: event log_named_string(string key, string val)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) ParseLogNamedString(log types.Log) (*ExampleTxAllowListTestLogNamedString, error) {
	event := new(ExampleTxAllowListTestLogNamedString)
	if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_named_string", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleTxAllowListTestLogNamedUintIterator is returned from FilterLogNamedUint and is used to iterate over the raw logs and unpacked data for LogNamedUint events raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogNamedUintIterator struct {
	Event *ExampleTxAllowListTestLogNamedUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleTxAllowListTestLogNamedUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleTxAllowListTestLogNamedUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleTxAllowListTestLogNamedUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleTxAllowListTestLogNamedUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleTxAllowListTestLogNamedUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleTxAllowListTestLogNamedUint represents a LogNamedUint event raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogNamedUint struct {
	Key string
	Val *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterLogNamedUint is a free log retrieval operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) FilterLogNamedUint(opts *bind.FilterOpts) (*ExampleTxAllowListTestLogNamedUintIterator, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.FilterLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return &ExampleTxAllowListTestLogNamedUintIterator{contract: _ExampleTxAllowListTest.contract, event: "log_named_uint", logs: logs, sub: sub}, nil
}

// WatchLogNamedUint is a free log subscription operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) WatchLogNamedUint(opts *bind.WatchOpts, sink chan<- *ExampleTxAllowListTestLogNamedUint) (event.Subscription, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.WatchLogs(opts, "log_named_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleTxAllowListTestLogNamedUint)
				if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogNamedUint is a log parse operation binding the contract event 0xb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a8.
//
// Solidity: event log_named_uint(string key, uint256 val)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) ParseLogNamedUint(log types.Log) (*ExampleTxAllowListTestLogNamedUint, error) {
	event := new(ExampleTxAllowListTestLogNamedUint)
	if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_named_uint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleTxAllowListTestLogStringIterator is returned from FilterLogString and is used to iterate over the raw logs and unpacked data for LogString events raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogStringIterator struct {
	Event *ExampleTxAllowListTestLogString // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleTxAllowListTestLogStringIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleTxAllowListTestLogString)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleTxAllowListTestLogString)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleTxAllowListTestLogStringIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleTxAllowListTestLogStringIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleTxAllowListTestLogString represents a LogString event raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogString struct {
	Arg0 string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogString is a free log retrieval operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) FilterLogString(opts *bind.FilterOpts) (*ExampleTxAllowListTestLogStringIterator, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.FilterLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return &ExampleTxAllowListTestLogStringIterator{contract: _ExampleTxAllowListTest.contract, event: "log_string", logs: logs, sub: sub}, nil
}

// WatchLogString is a free log subscription operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) WatchLogString(opts *bind.WatchOpts, sink chan<- *ExampleTxAllowListTestLogString) (event.Subscription, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.WatchLogs(opts, "log_string")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleTxAllowListTestLogString)
				if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_string", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogString is a log parse operation binding the contract event 0x0b2e13ff20ac7b474198655583edf70dedd2c1dc980e329c4fbb2fc0748b796b.
//
// Solidity: event log_string(string arg0)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) ParseLogString(log types.Log) (*ExampleTxAllowListTestLogString, error) {
	event := new(ExampleTxAllowListTestLogString)
	if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_string", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleTxAllowListTestLogUintIterator is returned from FilterLogUint and is used to iterate over the raw logs and unpacked data for LogUint events raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogUintIterator struct {
	Event *ExampleTxAllowListTestLogUint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleTxAllowListTestLogUintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleTxAllowListTestLogUint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleTxAllowListTestLogUint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleTxAllowListTestLogUintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleTxAllowListTestLogUintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleTxAllowListTestLogUint represents a LogUint event raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogUint struct {
	Arg0 *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogUint is a free log retrieval operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) FilterLogUint(opts *bind.FilterOpts) (*ExampleTxAllowListTestLogUintIterator, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.FilterLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return &ExampleTxAllowListTestLogUintIterator{contract: _ExampleTxAllowListTest.contract, event: "log_uint", logs: logs, sub: sub}, nil
}

// WatchLogUint is a free log subscription operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) WatchLogUint(opts *bind.WatchOpts, sink chan<- *ExampleTxAllowListTestLogUint) (event.Subscription, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.WatchLogs(opts, "log_uint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleTxAllowListTestLogUint)
				if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_uint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogUint is a log parse operation binding the contract event 0x2cab9790510fd8bdfbd2115288db33fec66691d476efc5427cfd4c0969301755.
//
// Solidity: event log_uint(uint256 arg0)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) ParseLogUint(log types.Log) (*ExampleTxAllowListTestLogUint, error) {
	event := new(ExampleTxAllowListTestLogUint)
	if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "log_uint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ExampleTxAllowListTestLogsIterator is returned from FilterLogs and is used to iterate over the raw logs and unpacked data for Logs events raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogsIterator struct {
	Event *ExampleTxAllowListTestLogs // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ExampleTxAllowListTestLogsIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ExampleTxAllowListTestLogs)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ExampleTxAllowListTestLogs)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ExampleTxAllowListTestLogsIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ExampleTxAllowListTestLogsIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ExampleTxAllowListTestLogs represents a Logs event raised by the ExampleTxAllowListTest contract.
type ExampleTxAllowListTestLogs struct {
	Arg0 []byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterLogs is a free log retrieval operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) FilterLogs(opts *bind.FilterOpts) (*ExampleTxAllowListTestLogsIterator, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.FilterLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return &ExampleTxAllowListTestLogsIterator{contract: _ExampleTxAllowListTest.contract, event: "logs", logs: logs, sub: sub}, nil
}

// WatchLogs is a free log subscription operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) WatchLogs(opts *bind.WatchOpts, sink chan<- *ExampleTxAllowListTestLogs) (event.Subscription, error) {

	logs, sub, err := _ExampleTxAllowListTest.contract.WatchLogs(opts, "logs")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ExampleTxAllowListTestLogs)
				if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "logs", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseLogs is a log parse operation binding the contract event 0xe7950ede0394b9f2ce4a5a1bf5a7e1852411f7e6661b4308c913c4bfd11027e4.
//
// Solidity: event logs(bytes arg0)
func (_ExampleTxAllowListTest *ExampleTxAllowListTestFilterer) ParseLogs(log types.Log) (*ExampleTxAllowListTestLogs, error) {
	event := new(ExampleTxAllowListTestLogs)
	if err := _ExampleTxAllowListTest.contract.UnpackLog(event, "logs", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAllowListMetaData contains all meta data concerning the IAllowList contract.
var IAllowListMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"role\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldRole\",\"type\":\"uint256\"}],\"name\":\"RoleSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"readAllowList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"role\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setNone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IAllowListABI is the input ABI used to generate the binding from.
// Deprecated: Use IAllowListMetaData.ABI instead.
var IAllowListABI = IAllowListMetaData.ABI

// IAllowList is an auto generated Go binding around an Ethereum contract.
type IAllowList struct {
	IAllowListCaller     // Read-only binding to the contract
	IAllowListTransactor // Write-only binding to the contract
	IAllowListFilterer   // Log filterer for contract events
}

// IAllowListCaller is an auto generated read-only Go binding around an Ethereum contract.
type IAllowListCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAllowListTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IAllowListTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAllowListFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IAllowListFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAllowListSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IAllowListSession struct {
	Contract     *IAllowList       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IAllowListCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IAllowListCallerSession struct {
	Contract *IAllowListCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// IAllowListTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IAllowListTransactorSession struct {
	Contract     *IAllowListTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// IAllowListRaw is an auto generated low-level Go binding around an Ethereum contract.
type IAllowListRaw struct {
	Contract *IAllowList // Generic contract binding to access the raw methods on
}

// IAllowListCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IAllowListCallerRaw struct {
	Contract *IAllowListCaller // Generic read-only contract binding to access the raw methods on
}

// IAllowListTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IAllowListTransactorRaw struct {
	Contract *IAllowListTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIAllowList creates a new instance of IAllowList, bound to a specific deployed contract.
func NewIAllowList(address common.Address, backend bind.ContractBackend) (*IAllowList, error) {
	contract, err := bindIAllowList(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IAllowList{IAllowListCaller: IAllowListCaller{contract: contract}, IAllowListTransactor: IAllowListTransactor{contract: contract}, IAllowListFilterer: IAllowListFilterer{contract: contract}}, nil
}

// NewIAllowListCaller creates a new read-only instance of IAllowList, bound to a specific deployed contract.
func NewIAllowListCaller(address common.Address, caller bind.ContractCaller) (*IAllowListCaller, error) {
	contract, err := bindIAllowList(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IAllowListCaller{contract: contract}, nil
}

// NewIAllowListTransactor creates a new write-only instance of IAllowList, bound to a specific deployed contract.
func NewIAllowListTransactor(address common.Address, transactor bind.ContractTransactor) (*IAllowListTransactor, error) {
	contract, err := bindIAllowList(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IAllowListTransactor{contract: contract}, nil
}

// NewIAllowListFilterer creates a new log filterer instance of IAllowList, bound to a specific deployed contract.
func NewIAllowListFilterer(address common.Address, filterer bind.ContractFilterer) (*IAllowListFilterer, error) {
	contract, err := bindIAllowList(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IAllowListFilterer{contract: contract}, nil
}

// bindIAllowList binds a generic wrapper to an already deployed contract.
func bindIAllowList(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IAllowListMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IAllowList *IAllowListRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IAllowList.Contract.IAllowListCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IAllowList *IAllowListRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAllowList.Contract.IAllowListTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IAllowList *IAllowListRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IAllowList.Contract.IAllowListTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IAllowList *IAllowListCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IAllowList.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IAllowList *IAllowListTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAllowList.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IAllowList *IAllowListTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IAllowList.Contract.contract.Transact(opts, method, params...)
}

// ReadAllowList is a free data retrieval call binding the contract method 0xeb54dae1.
//
// Solidity: function readAllowList(address addr) view returns(uint256 role)
func (_IAllowList *IAllowListCaller) ReadAllowList(opts *bind.CallOpts, addr common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IAllowList.contract.Call(opts, &out, "readAllowList", addr)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ReadAllowList is a free data retrieval call binding the contract method 0xeb54dae1.
//
// Solidity: function readAllowList(address addr) view returns(uint256 role)
func (_IAllowList *IAllowListSession) ReadAllowList(addr common.Address) (*big.Int, error) {
	return _IAllowList.Contract.ReadAllowList(&_IAllowList.CallOpts, addr)
}

// ReadAllowList is a free data retrieval call binding the contract method 0xeb54dae1.
//
// Solidity: function readAllowList(address addr) view returns(uint256 role)
func (_IAllowList *IAllowListCallerSession) ReadAllowList(addr common.Address) (*big.Int, error) {
	return _IAllowList.Contract.ReadAllowList(&_IAllowList.CallOpts, addr)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_IAllowList *IAllowListTransactor) SetAdmin(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _IAllowList.contract.Transact(opts, "setAdmin", addr)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_IAllowList *IAllowListSession) SetAdmin(addr common.Address) (*types.Transaction, error) {
	return _IAllowList.Contract.SetAdmin(&_IAllowList.TransactOpts, addr)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_IAllowList *IAllowListTransactorSession) SetAdmin(addr common.Address) (*types.Transaction, error) {
	return _IAllowList.Contract.SetAdmin(&_IAllowList.TransactOpts, addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_IAllowList *IAllowListTransactor) SetEnabled(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _IAllowList.contract.Transact(opts, "setEnabled", addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_IAllowList *IAllowListSession) SetEnabled(addr common.Address) (*types.Transaction, error) {
	return _IAllowList.Contract.SetEnabled(&_IAllowList.TransactOpts, addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_IAllowList *IAllowListTransactorSession) SetEnabled(addr common.Address) (*types.Transaction, error) {
	return _IAllowList.Contract.SetEnabled(&_IAllowList.TransactOpts, addr)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_IAllowList *IAllowListTransactor) SetManager(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _IAllowList.contract.Transact(opts, "setManager", addr)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_IAllowList *IAllowListSession) SetManager(addr common.Address) (*types.Transaction, error) {
	return _IAllowList.Contract.SetManager(&_IAllowList.TransactOpts, addr)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_IAllowList *IAllowListTransactorSession) SetManager(addr common.Address) (*types.Transaction, error) {
	return _IAllowList.Contract.SetManager(&_IAllowList.TransactOpts, addr)
}

// SetNone is a paid mutator transaction binding the contract method 0x8c6bfb3b.
//
// Solidity: function setNone(address addr) returns()
func (_IAllowList *IAllowListTransactor) SetNone(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _IAllowList.contract.Transact(opts, "setNone", addr)
}

// SetNone is a paid mutator transaction binding the contract method 0x8c6bfb3b.
//
// Solidity: function setNone(address addr) returns()
func (_IAllowList *IAllowListSession) SetNone(addr common.Address) (*types.Transaction, error) {
	return _IAllowList.Contract.SetNone(&_IAllowList.TransactOpts, addr)
}

// SetNone is a paid mutator transaction binding the contract method 0x8c6bfb3b.
//
// Solidity: function setNone(address addr) returns()
func (_IAllowList *IAllowListTransactorSession) SetNone(addr common.Address) (*types.Transaction, error) {
	return _IAllowList.Contract.SetNone(&_IAllowList.TransactOpts, addr)
}

// IAllowListRoleSetIterator is returned from FilterRoleSet and is used to iterate over the raw logs and unpacked data for RoleSet events raised by the IAllowList contract.
type IAllowListRoleSetIterator struct {
	Event *IAllowListRoleSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAllowListRoleSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAllowListRoleSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAllowListRoleSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAllowListRoleSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAllowListRoleSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAllowListRoleSet represents a RoleSet event raised by the IAllowList contract.
type IAllowListRoleSet struct {
	Role    *big.Int
	Account common.Address
	Sender  common.Address
	OldRole *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleSet is a free log retrieval operation binding the contract event 0xcdb7ea01f00a414d78757bdb0f6391664ba3fedf987eed280927c1e7d695be3e.
//
// Solidity: event RoleSet(uint256 indexed role, address indexed account, address indexed sender, uint256 oldRole)
func (_IAllowList *IAllowListFilterer) FilterRoleSet(opts *bind.FilterOpts, role []*big.Int, account []common.Address, sender []common.Address) (*IAllowListRoleSetIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IAllowList.contract.FilterLogs(opts, "RoleSet", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &IAllowListRoleSetIterator{contract: _IAllowList.contract, event: "RoleSet", logs: logs, sub: sub}, nil
}

// WatchRoleSet is a free log subscription operation binding the contract event 0xcdb7ea01f00a414d78757bdb0f6391664ba3fedf987eed280927c1e7d695be3e.
//
// Solidity: event RoleSet(uint256 indexed role, address indexed account, address indexed sender, uint256 oldRole)
func (_IAllowList *IAllowListFilterer) WatchRoleSet(opts *bind.WatchOpts, sink chan<- *IAllowListRoleSet, role []*big.Int, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IAllowList.contract.WatchLogs(opts, "RoleSet", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAllowListRoleSet)
				if err := _IAllowList.contract.UnpackLog(event, "RoleSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleSet is a log parse operation binding the contract event 0xcdb7ea01f00a414d78757bdb0f6391664ba3fedf987eed280927c1e7d695be3e.
//
// Solidity: event RoleSet(uint256 indexed role, address indexed account, address indexed sender, uint256 oldRole)
func (_IAllowList *IAllowListFilterer) ParseRoleSet(log types.Log) (*IAllowListRoleSet, error) {
	event := new(IAllowListRoleSet)
	if err := _IAllowList.contract.UnpackLog(event, "RoleSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20MetaData contains all meta data concerning the IERC20 contract.
var IERC20MetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IERC20ABI is the input ABI used to generate the binding from.
// Deprecated: Use IERC20MetaData.ABI instead.
var IERC20ABI = IERC20MetaData.ABI

// IERC20 is an auto generated Go binding around an Ethereum contract.
type IERC20 struct {
	IERC20Caller     // Read-only binding to the contract
	IERC20Transactor // Write-only binding to the contract
	IERC20Filterer   // Log filterer for contract events
}

// IERC20Caller is an auto generated read-only Go binding around an Ethereum contract.
type IERC20Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20Transactor is an auto generated write-only Go binding around an Ethereum contract.
type IERC20Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IERC20Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IERC20Session struct {
	Contract     *IERC20           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC20CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IERC20CallerSession struct {
	Contract *IERC20Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// IERC20TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IERC20TransactorSession struct {
	Contract     *IERC20Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC20Raw is an auto generated low-level Go binding around an Ethereum contract.
type IERC20Raw struct {
	Contract *IERC20 // Generic contract binding to access the raw methods on
}

// IERC20CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IERC20CallerRaw struct {
	Contract *IERC20Caller // Generic read-only contract binding to access the raw methods on
}

// IERC20TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IERC20TransactorRaw struct {
	Contract *IERC20Transactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC20 creates a new instance of IERC20, bound to a specific deployed contract.
func NewIERC20(address common.Address, backend bind.ContractBackend) (*IERC20, error) {
	contract, err := bindIERC20(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC20{IERC20Caller: IERC20Caller{contract: contract}, IERC20Transactor: IERC20Transactor{contract: contract}, IERC20Filterer: IERC20Filterer{contract: contract}}, nil
}

// NewIERC20Caller creates a new read-only instance of IERC20, bound to a specific deployed contract.
func NewIERC20Caller(address common.Address, caller bind.ContractCaller) (*IERC20Caller, error) {
	contract, err := bindIERC20(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20Caller{contract: contract}, nil
}

// NewIERC20Transactor creates a new write-only instance of IERC20, bound to a specific deployed contract.
func NewIERC20Transactor(address common.Address, transactor bind.ContractTransactor) (*IERC20Transactor, error) {
	contract, err := bindIERC20(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20Transactor{contract: contract}, nil
}

// NewIERC20Filterer creates a new log filterer instance of IERC20, bound to a specific deployed contract.
func NewIERC20Filterer(address common.Address, filterer bind.ContractFilterer) (*IERC20Filterer, error) {
	contract, err := bindIERC20(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC20Filterer{contract: contract}, nil
}

// bindIERC20 binds a generic wrapper to an already deployed contract.
func bindIERC20(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IERC20MetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20 *IERC20Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20.Contract.IERC20Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20 *IERC20Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20.Contract.IERC20Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20 *IERC20Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20.Contract.IERC20Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20 *IERC20CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20 *IERC20TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20 *IERC20TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20 *IERC20Caller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IERC20.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20 *IERC20Session) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20.Contract.Allowance(&_IERC20.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20 *IERC20CallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20.Contract.Allowance(&_IERC20.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20 *IERC20Caller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IERC20.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20 *IERC20Session) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20.Contract.BalanceOf(&_IERC20.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20 *IERC20CallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20.Contract.BalanceOf(&_IERC20.CallOpts, account)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20 *IERC20Caller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IERC20.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20 *IERC20Session) TotalSupply() (*big.Int, error) {
	return _IERC20.Contract.TotalSupply(&_IERC20.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20 *IERC20CallerSession) TotalSupply() (*big.Int, error) {
	return _IERC20.Contract.TotalSupply(&_IERC20.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20 *IERC20Transactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20 *IERC20Session) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Approve(&_IERC20.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20 *IERC20TransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Approve(&_IERC20.TransactOpts, spender, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20Transactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.contract.Transact(opts, "transfer", to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20Session) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Transfer(&_IERC20.TransactOpts, to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20TransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Transfer(&_IERC20.TransactOpts, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20Transactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.contract.Transact(opts, "transferFrom", from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20Session) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.TransferFrom(&_IERC20.TransactOpts, from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20TransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.TransferFrom(&_IERC20.TransactOpts, from, to, amount)
}

// IERC20ApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the IERC20 contract.
type IERC20ApprovalIterator struct {
	Event *IERC20Approval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20ApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20Approval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20Approval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20ApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20ApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20Approval represents a Approval event raised by the IERC20 contract.
type IERC20Approval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20 *IERC20Filterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*IERC20ApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &IERC20ApprovalIterator{contract: _IERC20.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20 *IERC20Filterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *IERC20Approval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20Approval)
				if err := _IERC20.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20 *IERC20Filterer) ParseApproval(log types.Log) (*IERC20Approval, error) {
	event := new(IERC20Approval)
	if err := _IERC20.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20TransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the IERC20 contract.
type IERC20TransferIterator struct {
	Event *IERC20Transfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20TransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20Transfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20Transfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20TransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20TransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20Transfer represents a Transfer event raised by the IERC20 contract.
type IERC20Transfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20 *IERC20Filterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*IERC20TransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &IERC20TransferIterator{contract: _IERC20.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20 *IERC20Filterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *IERC20Transfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20Transfer)
				if err := _IERC20.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20 *IERC20Filterer) ParseTransfer(log types.Log) (*IERC20Transfer, error) {
	event := new(IERC20Transfer)
	if err := _IERC20.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20MetadataMetaData contains all meta data concerning the IERC20Metadata contract.
var IERC20MetadataMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IERC20MetadataABI is the input ABI used to generate the binding from.
// Deprecated: Use IERC20MetadataMetaData.ABI instead.
var IERC20MetadataABI = IERC20MetadataMetaData.ABI

// IERC20Metadata is an auto generated Go binding around an Ethereum contract.
type IERC20Metadata struct {
	IERC20MetadataCaller     // Read-only binding to the contract
	IERC20MetadataTransactor // Write-only binding to the contract
	IERC20MetadataFilterer   // Log filterer for contract events
}

// IERC20MetadataCaller is an auto generated read-only Go binding around an Ethereum contract.
type IERC20MetadataCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20MetadataTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IERC20MetadataTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20MetadataFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IERC20MetadataFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20MetadataSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IERC20MetadataSession struct {
	Contract     *IERC20Metadata   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC20MetadataCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IERC20MetadataCallerSession struct {
	Contract *IERC20MetadataCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// IERC20MetadataTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IERC20MetadataTransactorSession struct {
	Contract     *IERC20MetadataTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// IERC20MetadataRaw is an auto generated low-level Go binding around an Ethereum contract.
type IERC20MetadataRaw struct {
	Contract *IERC20Metadata // Generic contract binding to access the raw methods on
}

// IERC20MetadataCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IERC20MetadataCallerRaw struct {
	Contract *IERC20MetadataCaller // Generic read-only contract binding to access the raw methods on
}

// IERC20MetadataTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IERC20MetadataTransactorRaw struct {
	Contract *IERC20MetadataTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC20Metadata creates a new instance of IERC20Metadata, bound to a specific deployed contract.
func NewIERC20Metadata(address common.Address, backend bind.ContractBackend) (*IERC20Metadata, error) {
	contract, err := bindIERC20Metadata(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC20Metadata{IERC20MetadataCaller: IERC20MetadataCaller{contract: contract}, IERC20MetadataTransactor: IERC20MetadataTransactor{contract: contract}, IERC20MetadataFilterer: IERC20MetadataFilterer{contract: contract}}, nil
}

// NewIERC20MetadataCaller creates a new read-only instance of IERC20Metadata, bound to a specific deployed contract.
func NewIERC20MetadataCaller(address common.Address, caller bind.ContractCaller) (*IERC20MetadataCaller, error) {
	contract, err := bindIERC20Metadata(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20MetadataCaller{contract: contract}, nil
}

// NewIERC20MetadataTransactor creates a new write-only instance of IERC20Metadata, bound to a specific deployed contract.
func NewIERC20MetadataTransactor(address common.Address, transactor bind.ContractTransactor) (*IERC20MetadataTransactor, error) {
	contract, err := bindIERC20Metadata(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20MetadataTransactor{contract: contract}, nil
}

// NewIERC20MetadataFilterer creates a new log filterer instance of IERC20Metadata, bound to a specific deployed contract.
func NewIERC20MetadataFilterer(address common.Address, filterer bind.ContractFilterer) (*IERC20MetadataFilterer, error) {
	contract, err := bindIERC20Metadata(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC20MetadataFilterer{contract: contract}, nil
}

// bindIERC20Metadata binds a generic wrapper to an already deployed contract.
func bindIERC20Metadata(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IERC20MetadataMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20Metadata *IERC20MetadataRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20Metadata.Contract.IERC20MetadataCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20Metadata *IERC20MetadataRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.IERC20MetadataTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20Metadata *IERC20MetadataRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.IERC20MetadataTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20Metadata *IERC20MetadataCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20Metadata.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20Metadata *IERC20MetadataTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20Metadata *IERC20MetadataTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20Metadata *IERC20MetadataCaller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IERC20Metadata.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20Metadata *IERC20MetadataSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20Metadata.Contract.Allowance(&_IERC20Metadata.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20Metadata *IERC20MetadataCallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20Metadata.Contract.Allowance(&_IERC20Metadata.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20Metadata *IERC20MetadataCaller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IERC20Metadata.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20Metadata *IERC20MetadataSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20Metadata.Contract.BalanceOf(&_IERC20Metadata.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20Metadata *IERC20MetadataCallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20Metadata.Contract.BalanceOf(&_IERC20Metadata.CallOpts, account)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_IERC20Metadata *IERC20MetadataCaller) Decimals(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _IERC20Metadata.contract.Call(opts, &out, "decimals")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_IERC20Metadata *IERC20MetadataSession) Decimals() (uint8, error) {
	return _IERC20Metadata.Contract.Decimals(&_IERC20Metadata.CallOpts)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_IERC20Metadata *IERC20MetadataCallerSession) Decimals() (uint8, error) {
	return _IERC20Metadata.Contract.Decimals(&_IERC20Metadata.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_IERC20Metadata *IERC20MetadataCaller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _IERC20Metadata.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_IERC20Metadata *IERC20MetadataSession) Name() (string, error) {
	return _IERC20Metadata.Contract.Name(&_IERC20Metadata.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_IERC20Metadata *IERC20MetadataCallerSession) Name() (string, error) {
	return _IERC20Metadata.Contract.Name(&_IERC20Metadata.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_IERC20Metadata *IERC20MetadataCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _IERC20Metadata.contract.Call(opts, &out, "symbol")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_IERC20Metadata *IERC20MetadataSession) Symbol() (string, error) {
	return _IERC20Metadata.Contract.Symbol(&_IERC20Metadata.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_IERC20Metadata *IERC20MetadataCallerSession) Symbol() (string, error) {
	return _IERC20Metadata.Contract.Symbol(&_IERC20Metadata.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20Metadata *IERC20MetadataCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IERC20Metadata.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20Metadata *IERC20MetadataSession) TotalSupply() (*big.Int, error) {
	return _IERC20Metadata.Contract.TotalSupply(&_IERC20Metadata.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20Metadata *IERC20MetadataCallerSession) TotalSupply() (*big.Int, error) {
	return _IERC20Metadata.Contract.TotalSupply(&_IERC20Metadata.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataTransactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.Approve(&_IERC20Metadata.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataTransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.Approve(&_IERC20Metadata.TransactOpts, spender, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataTransactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.contract.Transact(opts, "transfer", to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.Transfer(&_IERC20Metadata.TransactOpts, to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataTransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.Transfer(&_IERC20Metadata.TransactOpts, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.contract.Transact(opts, "transferFrom", from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.TransferFrom(&_IERC20Metadata.TransactOpts, from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataTransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.TransferFrom(&_IERC20Metadata.TransactOpts, from, to, amount)
}

// IERC20MetadataApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the IERC20Metadata contract.
type IERC20MetadataApprovalIterator struct {
	Event *IERC20MetadataApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20MetadataApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20MetadataApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20MetadataApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20MetadataApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20MetadataApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20MetadataApproval represents a Approval event raised by the IERC20Metadata contract.
type IERC20MetadataApproval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20Metadata *IERC20MetadataFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*IERC20MetadataApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20Metadata.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &IERC20MetadataApprovalIterator{contract: _IERC20Metadata.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20Metadata *IERC20MetadataFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *IERC20MetadataApproval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20Metadata.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20MetadataApproval)
				if err := _IERC20Metadata.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20Metadata *IERC20MetadataFilterer) ParseApproval(log types.Log) (*IERC20MetadataApproval, error) {
	event := new(IERC20MetadataApproval)
	if err := _IERC20Metadata.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20MetadataTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the IERC20Metadata contract.
type IERC20MetadataTransferIterator struct {
	Event *IERC20MetadataTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20MetadataTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20MetadataTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20MetadataTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20MetadataTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20MetadataTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20MetadataTransfer represents a Transfer event raised by the IERC20Metadata contract.
type IERC20MetadataTransfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20Metadata *IERC20MetadataFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*IERC20MetadataTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20Metadata.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &IERC20MetadataTransferIterator{contract: _IERC20Metadata.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20Metadata *IERC20MetadataFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *IERC20MetadataTransfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20Metadata.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20MetadataTransfer)
				if err := _IERC20Metadata.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20Metadata *IERC20MetadataFilterer) ParseTransfer(log types.Log) (*IERC20MetadataTransfer, error) {
	event := new(IERC20MetadataTransfer)
	if err := _IERC20Metadata.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IFeeManagerMetaData contains all meta data concerning the IFeeManager contract.
var IFeeManagerMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetBlockRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBaseFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseFeeChangeDenominator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBlockGasCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBlockGasCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockGasCostStep\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"structIFeeManager.FeeConfig\",\"name\":\"oldFeeConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetBlockRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBaseFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseFeeChangeDenominator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBlockGasCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBlockGasCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockGasCostStep\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"structIFeeManager.FeeConfig\",\"name\":\"newFeeConfig\",\"type\":\"tuple\"}],\"name\":\"FeeConfigChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"role\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldRole\",\"type\":\"uint256\"}],\"name\":\"RoleSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"getFeeConfig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetBlockRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBaseFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseFeeChangeDenominator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBlockGasCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBlockGasCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockGasCostStep\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeConfigLastChangedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"readAllowList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"role\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetBlockRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBaseFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseFeeChangeDenominator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBlockGasCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBlockGasCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockGasCostStep\",\"type\":\"uint256\"}],\"name\":\"setFeeConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setNone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IFeeManagerABI is the input ABI used to generate the binding from.
// Deprecated: Use IFeeManagerMetaData.ABI instead.
var IFeeManagerABI = IFeeManagerMetaData.ABI

// IFeeManager is an auto generated Go binding around an Ethereum contract.
type IFeeManager struct {
	IFeeManagerCaller     // Read-only binding to the contract
	IFeeManagerTransactor // Write-only binding to the contract
	IFeeManagerFilterer   // Log filterer for contract events
}

// IFeeManagerCaller is an auto generated read-only Go binding around an Ethereum contract.
type IFeeManagerCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IFeeManagerTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IFeeManagerTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IFeeManagerFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IFeeManagerFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IFeeManagerSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IFeeManagerSession struct {
	Contract     *IFeeManager      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IFeeManagerCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IFeeManagerCallerSession struct {
	Contract *IFeeManagerCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// IFeeManagerTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IFeeManagerTransactorSession struct {
	Contract     *IFeeManagerTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// IFeeManagerRaw is an auto generated low-level Go binding around an Ethereum contract.
type IFeeManagerRaw struct {
	Contract *IFeeManager // Generic contract binding to access the raw methods on
}

// IFeeManagerCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IFeeManagerCallerRaw struct {
	Contract *IFeeManagerCaller // Generic read-only contract binding to access the raw methods on
}

// IFeeManagerTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IFeeManagerTransactorRaw struct {
	Contract *IFeeManagerTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIFeeManager creates a new instance of IFeeManager, bound to a specific deployed contract.
func NewIFeeManager(address common.Address, backend bind.ContractBackend) (*IFeeManager, error) {
	contract, err := bindIFeeManager(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IFeeManager{IFeeManagerCaller: IFeeManagerCaller{contract: contract}, IFeeManagerTransactor: IFeeManagerTransactor{contract: contract}, IFeeManagerFilterer: IFeeManagerFilterer{contract: contract}}, nil
}

// NewIFeeManagerCaller creates a new read-only instance of IFeeManager, bound to a specific deployed contract.
func NewIFeeManagerCaller(address common.Address, caller bind.ContractCaller) (*IFeeManagerCaller, error) {
	contract, err := bindIFeeManager(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IFeeManagerCaller{contract: contract}, nil
}

// NewIFeeManagerTransactor creates a new write-only instance of IFeeManager, bound to a specific deployed contract.
func NewIFeeManagerTransactor(address common.Address, transactor bind.ContractTransactor) (*IFeeManagerTransactor, error) {
	contract, err := bindIFeeManager(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IFeeManagerTransactor{contract: contract}, nil
}

// NewIFeeManagerFilterer creates a new log filterer instance of IFeeManager, bound to a specific deployed contract.
func NewIFeeManagerFilterer(address common.Address, filterer bind.ContractFilterer) (*IFeeManagerFilterer, error) {
	contract, err := bindIFeeManager(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IFeeManagerFilterer{contract: contract}, nil
}

// bindIFeeManager binds a generic wrapper to an already deployed contract.
func bindIFeeManager(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IFeeManagerMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IFeeManager *IFeeManagerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IFeeManager.Contract.IFeeManagerCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IFeeManager *IFeeManagerRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IFeeManager.Contract.IFeeManagerTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IFeeManager *IFeeManagerRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IFeeManager.Contract.IFeeManagerTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IFeeManager *IFeeManagerCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IFeeManager.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IFeeManager *IFeeManagerTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IFeeManager.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IFeeManager *IFeeManagerTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IFeeManager.Contract.contract.Transact(opts, method, params...)
}

// GetFeeConfig is a free data retrieval call binding the contract method 0x5fbbc0d2.
//
// Solidity: function getFeeConfig() view returns(uint256 gasLimit, uint256 targetBlockRate, uint256 minBaseFee, uint256 targetGas, uint256 baseFeeChangeDenominator, uint256 minBlockGasCost, uint256 maxBlockGasCost, uint256 blockGasCostStep)
func (_IFeeManager *IFeeManagerCaller) GetFeeConfig(opts *bind.CallOpts) (struct {
	GasLimit                 *big.Int
	TargetBlockRate          *big.Int
	MinBaseFee               *big.Int
	TargetGas                *big.Int
	BaseFeeChangeDenominator *big.Int
	MinBlockGasCost          *big.Int
	MaxBlockGasCost          *big.Int
	BlockGasCostStep         *big.Int
}, error) {
	var out []interface{}
	err := _IFeeManager.contract.Call(opts, &out, "getFeeConfig")

	outstruct := new(struct {
		GasLimit                 *big.Int
		TargetBlockRate          *big.Int
		MinBaseFee               *big.Int
		TargetGas                *big.Int
		BaseFeeChangeDenominator *big.Int
		MinBlockGasCost          *big.Int
		MaxBlockGasCost          *big.Int
		BlockGasCostStep         *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.GasLimit = *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	outstruct.TargetBlockRate = *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)
	outstruct.MinBaseFee = *abi.ConvertType(out[2], new(*big.Int)).(**big.Int)
	outstruct.TargetGas = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)
	outstruct.BaseFeeChangeDenominator = *abi.ConvertType(out[4], new(*big.Int)).(**big.Int)
	outstruct.MinBlockGasCost = *abi.ConvertType(out[5], new(*big.Int)).(**big.Int)
	outstruct.MaxBlockGasCost = *abi.ConvertType(out[6], new(*big.Int)).(**big.Int)
	outstruct.BlockGasCostStep = *abi.ConvertType(out[7], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// GetFeeConfig is a free data retrieval call binding the contract method 0x5fbbc0d2.
//
// Solidity: function getFeeConfig() view returns(uint256 gasLimit, uint256 targetBlockRate, uint256 minBaseFee, uint256 targetGas, uint256 baseFeeChangeDenominator, uint256 minBlockGasCost, uint256 maxBlockGasCost, uint256 blockGasCostStep)
func (_IFeeManager *IFeeManagerSession) GetFeeConfig() (struct {
	GasLimit                 *big.Int
	TargetBlockRate          *big.Int
	MinBaseFee               *big.Int
	TargetGas                *big.Int
	BaseFeeChangeDenominator *big.Int
	MinBlockGasCost          *big.Int
	MaxBlockGasCost          *big.Int
	BlockGasCostStep         *big.Int
}, error) {
	return _IFeeManager.Contract.GetFeeConfig(&_IFeeManager.CallOpts)
}

// GetFeeConfig is a free data retrieval call binding the contract method 0x5fbbc0d2.
//
// Solidity: function getFeeConfig() view returns(uint256 gasLimit, uint256 targetBlockRate, uint256 minBaseFee, uint256 targetGas, uint256 baseFeeChangeDenominator, uint256 minBlockGasCost, uint256 maxBlockGasCost, uint256 blockGasCostStep)
func (_IFeeManager *IFeeManagerCallerSession) GetFeeConfig() (struct {
	GasLimit                 *big.Int
	TargetBlockRate          *big.Int
	MinBaseFee               *big.Int
	TargetGas                *big.Int
	BaseFeeChangeDenominator *big.Int
	MinBlockGasCost          *big.Int
	MaxBlockGasCost          *big.Int
	BlockGasCostStep         *big.Int
}, error) {
	return _IFeeManager.Contract.GetFeeConfig(&_IFeeManager.CallOpts)
}

// GetFeeConfigLastChangedAt is a free data retrieval call binding the contract method 0x9e05549a.
//
// Solidity: function getFeeConfigLastChangedAt() view returns(uint256 blockNumber)
func (_IFeeManager *IFeeManagerCaller) GetFeeConfigLastChangedAt(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IFeeManager.contract.Call(opts, &out, "getFeeConfigLastChangedAt")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetFeeConfigLastChangedAt is a free data retrieval call binding the contract method 0x9e05549a.
//
// Solidity: function getFeeConfigLastChangedAt() view returns(uint256 blockNumber)
func (_IFeeManager *IFeeManagerSession) GetFeeConfigLastChangedAt() (*big.Int, error) {
	return _IFeeManager.Contract.GetFeeConfigLastChangedAt(&_IFeeManager.CallOpts)
}

// GetFeeConfigLastChangedAt is a free data retrieval call binding the contract method 0x9e05549a.
//
// Solidity: function getFeeConfigLastChangedAt() view returns(uint256 blockNumber)
func (_IFeeManager *IFeeManagerCallerSession) GetFeeConfigLastChangedAt() (*big.Int, error) {
	return _IFeeManager.Contract.GetFeeConfigLastChangedAt(&_IFeeManager.CallOpts)
}

// ReadAllowList is a free data retrieval call binding the contract method 0xeb54dae1.
//
// Solidity: function readAllowList(address addr) view returns(uint256 role)
func (_IFeeManager *IFeeManagerCaller) ReadAllowList(opts *bind.CallOpts, addr common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IFeeManager.contract.Call(opts, &out, "readAllowList", addr)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ReadAllowList is a free data retrieval call binding the contract method 0xeb54dae1.
//
// Solidity: function readAllowList(address addr) view returns(uint256 role)
func (_IFeeManager *IFeeManagerSession) ReadAllowList(addr common.Address) (*big.Int, error) {
	return _IFeeManager.Contract.ReadAllowList(&_IFeeManager.CallOpts, addr)
}

// ReadAllowList is a free data retrieval call binding the contract method 0xeb54dae1.
//
// Solidity: function readAllowList(address addr) view returns(uint256 role)
func (_IFeeManager *IFeeManagerCallerSession) ReadAllowList(addr common.Address) (*big.Int, error) {
	return _IFeeManager.Contract.ReadAllowList(&_IFeeManager.CallOpts, addr)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_IFeeManager *IFeeManagerTransactor) SetAdmin(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _IFeeManager.contract.Transact(opts, "setAdmin", addr)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_IFeeManager *IFeeManagerSession) SetAdmin(addr common.Address) (*types.Transaction, error) {
	return _IFeeManager.Contract.SetAdmin(&_IFeeManager.TransactOpts, addr)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_IFeeManager *IFeeManagerTransactorSession) SetAdmin(addr common.Address) (*types.Transaction, error) {
	return _IFeeManager.Contract.SetAdmin(&_IFeeManager.TransactOpts, addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_IFeeManager *IFeeManagerTransactor) SetEnabled(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _IFeeManager.contract.Transact(opts, "setEnabled", addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_IFeeManager *IFeeManagerSession) SetEnabled(addr common.Address) (*types.Transaction, error) {
	return _IFeeManager.Contract.SetEnabled(&_IFeeManager.TransactOpts, addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_IFeeManager *IFeeManagerTransactorSession) SetEnabled(addr common.Address) (*types.Transaction, error) {
	return _IFeeManager.Contract.SetEnabled(&_IFeeManager.TransactOpts, addr)
}

// SetFeeConfig is a paid mutator transaction binding the contract method 0x8f10b586.
//
// Solidity: function setFeeConfig(uint256 gasLimit, uint256 targetBlockRate, uint256 minBaseFee, uint256 targetGas, uint256 baseFeeChangeDenominator, uint256 minBlockGasCost, uint256 maxBlockGasCost, uint256 blockGasCostStep) returns()
func (_IFeeManager *IFeeManagerTransactor) SetFeeConfig(opts *bind.TransactOpts, gasLimit *big.Int, targetBlockRate *big.Int, minBaseFee *big.Int, targetGas *big.Int, baseFeeChangeDenominator *big.Int, minBlockGasCost *big.Int, maxBlockGasCost *big.Int, blockGasCostStep *big.Int) (*types.Transaction, error) {
	return _IFeeManager.contract.Transact(opts, "setFeeConfig", gasLimit, targetBlockRate, minBaseFee, targetGas, baseFeeChangeDenominator, minBlockGasCost, maxBlockGasCost, blockGasCostStep)
}

// SetFeeConfig is a paid mutator transaction binding the contract method 0x8f10b586.
//
// Solidity: function setFeeConfig(uint256 gasLimit, uint256 targetBlockRate, uint256 minBaseFee, uint256 targetGas, uint256 baseFeeChangeDenominator, uint256 minBlockGasCost, uint256 maxBlockGasCost, uint256 blockGasCostStep) returns()
func (_IFeeManager *IFeeManagerSession) SetFeeConfig(gasLimit *big.Int, targetBlockRate *big.Int, minBaseFee *big.Int, targetGas *big.Int, baseFeeChangeDenominator *big.Int, minBlockGasCost *big.Int, maxBlockGasCost *big.Int, blockGasCostStep *big.Int) (*types.Transaction, error) {
	return _IFeeManager.Contract.SetFeeConfig(&_IFeeManager.TransactOpts, gasLimit, targetBlockRate, minBaseFee, targetGas, baseFeeChangeDenominator, minBlockGasCost, maxBlockGasCost, blockGasCostStep)
}

// SetFeeConfig is a paid mutator transaction binding the contract method 0x8f10b586.
//
// Solidity: function setFeeConfig(uint256 gasLimit, uint256 targetBlockRate, uint256 minBaseFee, uint256 targetGas, uint256 baseFeeChangeDenominator, uint256 minBlockGasCost, uint256 maxBlockGasCost, uint256 blockGasCostStep) returns()
func (_IFeeManager *IFeeManagerTransactorSession) SetFeeConfig(gasLimit *big.Int, targetBlockRate *big.Int, minBaseFee *big.Int, targetGas *big.Int, baseFeeChangeDenominator *big.Int, minBlockGasCost *big.Int, maxBlockGasCost *big.Int, blockGasCostStep *big.Int) (*types.Transaction, error) {
	return _IFeeManager.Contract.SetFeeConfig(&_IFeeManager.TransactOpts, gasLimit, targetBlockRate, minBaseFee, targetGas, baseFeeChangeDenominator, minBlockGasCost, maxBlockGasCost, blockGasCostStep)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_IFeeManager *IFeeManagerTransactor) SetManager(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _IFeeManager.contract.Transact(opts, "setManager", addr)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_IFeeManager *IFeeManagerSession) SetManager(addr common.Address) (*types.Transaction, error) {
	return _IFeeManager.Contract.SetManager(&_IFeeManager.TransactOpts, addr)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_IFeeManager *IFeeManagerTransactorSession) SetManager(addr common.Address) (*types.Transaction, error) {
	return _IFeeManager.Contract.SetManager(&_IFeeManager.TransactOpts, addr)
}

// SetNone is a paid mutator transaction binding the contract method 0x8c6bfb3b.
//
// Solidity: function setNone(address addr) returns()
func (_IFeeManager *IFeeManagerTransactor) SetNone(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _IFeeManager.contract.Transact(opts, "setNone", addr)
}

// SetNone is a paid mutator transaction binding the contract method 0x8c6bfb3b.
//
// Solidity: function setNone(address addr) returns()
func (_IFeeManager *IFeeManagerSession) SetNone(addr common.Address) (*types.Transaction, error) {
	return _IFeeManager.Contract.SetNone(&_IFeeManager.TransactOpts, addr)
}

// SetNone is a paid mutator transaction binding the contract method 0x8c6bfb3b.
//
// Solidity: function setNone(address addr) returns()
func (_IFeeManager *IFeeManagerTransactorSession) SetNone(addr common.Address) (*types.Transaction, error) {
	return _IFeeManager.Contract.SetNone(&_IFeeManager.TransactOpts, addr)
}

// IFeeManagerFeeConfigChangedIterator is returned from FilterFeeConfigChanged and is used to iterate over the raw logs and unpacked data for FeeConfigChanged events raised by the IFeeManager contract.
type IFeeManagerFeeConfigChangedIterator struct {
	Event *IFeeManagerFeeConfigChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IFeeManagerFeeConfigChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IFeeManagerFeeConfigChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IFeeManagerFeeConfigChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IFeeManagerFeeConfigChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IFeeManagerFeeConfigChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IFeeManagerFeeConfigChanged represents a FeeConfigChanged event raised by the IFeeManager contract.
type IFeeManagerFeeConfigChanged struct {
	Sender       common.Address
	OldFeeConfig IFeeManagerFeeConfig
	NewFeeConfig IFeeManagerFeeConfig
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterFeeConfigChanged is a free log retrieval operation binding the contract event 0x4c98e43adb5962c18f3f0e6dd066e2a2de258d3b4f695b317b77c8f27cd044fc.
//
// Solidity: event FeeConfigChanged(address indexed sender, (uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256) oldFeeConfig, (uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256) newFeeConfig)
func (_IFeeManager *IFeeManagerFilterer) FilterFeeConfigChanged(opts *bind.FilterOpts, sender []common.Address) (*IFeeManagerFeeConfigChangedIterator, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IFeeManager.contract.FilterLogs(opts, "FeeConfigChanged", senderRule)
	if err != nil {
		return nil, err
	}
	return &IFeeManagerFeeConfigChangedIterator{contract: _IFeeManager.contract, event: "FeeConfigChanged", logs: logs, sub: sub}, nil
}

// WatchFeeConfigChanged is a free log subscription operation binding the contract event 0x4c98e43adb5962c18f3f0e6dd066e2a2de258d3b4f695b317b77c8f27cd044fc.
//
// Solidity: event FeeConfigChanged(address indexed sender, (uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256) oldFeeConfig, (uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256) newFeeConfig)
func (_IFeeManager *IFeeManagerFilterer) WatchFeeConfigChanged(opts *bind.WatchOpts, sink chan<- *IFeeManagerFeeConfigChanged, sender []common.Address) (event.Subscription, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IFeeManager.contract.WatchLogs(opts, "FeeConfigChanged", senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IFeeManagerFeeConfigChanged)
				if err := _IFeeManager.contract.UnpackLog(event, "FeeConfigChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFeeConfigChanged is a log parse operation binding the contract event 0x4c98e43adb5962c18f3f0e6dd066e2a2de258d3b4f695b317b77c8f27cd044fc.
//
// Solidity: event FeeConfigChanged(address indexed sender, (uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256) oldFeeConfig, (uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256) newFeeConfig)
func (_IFeeManager *IFeeManagerFilterer) ParseFeeConfigChanged(log types.Log) (*IFeeManagerFeeConfigChanged, error) {
	event := new(IFeeManagerFeeConfigChanged)
	if err := _IFeeManager.contract.UnpackLog(event, "FeeConfigChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IFeeManagerRoleSetIterator is returned from FilterRoleSet and is used to iterate over the raw logs and unpacked data for RoleSet events raised by the IFeeManager contract.
type IFeeManagerRoleSetIterator struct {
	Event *IFeeManagerRoleSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IFeeManagerRoleSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IFeeManagerRoleSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IFeeManagerRoleSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IFeeManagerRoleSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IFeeManagerRoleSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IFeeManagerRoleSet represents a RoleSet event raised by the IFeeManager contract.
type IFeeManagerRoleSet struct {
	Role    *big.Int
	Account common.Address
	Sender  common.Address
	OldRole *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleSet is a free log retrieval operation binding the contract event 0xcdb7ea01f00a414d78757bdb0f6391664ba3fedf987eed280927c1e7d695be3e.
//
// Solidity: event RoleSet(uint256 indexed role, address indexed account, address indexed sender, uint256 oldRole)
func (_IFeeManager *IFeeManagerFilterer) FilterRoleSet(opts *bind.FilterOpts, role []*big.Int, account []common.Address, sender []common.Address) (*IFeeManagerRoleSetIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IFeeManager.contract.FilterLogs(opts, "RoleSet", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &IFeeManagerRoleSetIterator{contract: _IFeeManager.contract, event: "RoleSet", logs: logs, sub: sub}, nil
}

// WatchRoleSet is a free log subscription operation binding the contract event 0xcdb7ea01f00a414d78757bdb0f6391664ba3fedf987eed280927c1e7d695be3e.
//
// Solidity: event RoleSet(uint256 indexed role, address indexed account, address indexed sender, uint256 oldRole)
func (_IFeeManager *IFeeManagerFilterer) WatchRoleSet(opts *bind.WatchOpts, sink chan<- *IFeeManagerRoleSet, role []*big.Int, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IFeeManager.contract.WatchLogs(opts, "RoleSet", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IFeeManagerRoleSet)
				if err := _IFeeManager.contract.UnpackLog(event, "RoleSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleSet is a log parse operation binding the contract event 0xcdb7ea01f00a414d78757bdb0f6391664ba3fedf987eed280927c1e7d695be3e.
//
// Solidity: event RoleSet(uint256 indexed role, address indexed account, address indexed sender, uint256 oldRole)
func (_IFeeManager *IFeeManagerFilterer) ParseRoleSet(log types.Log) (*IFeeManagerRoleSet, error) {
	event := new(IFeeManagerRoleSet)
	if err := _IFeeManager.contract.UnpackLog(event, "RoleSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// INativeMinterMetaData contains all meta data concerning the INativeMinter contract.
var INativeMinterMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NativeCoinMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"role\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldRole\",\"type\":\"uint256\"}],\"name\":\"RoleSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintNativeCoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"readAllowList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"role\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setNone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// INativeMinterABI is the input ABI used to generate the binding from.
// Deprecated: Use INativeMinterMetaData.ABI instead.
var INativeMinterABI = INativeMinterMetaData.ABI

// INativeMinter is an auto generated Go binding around an Ethereum contract.
type INativeMinter struct {
	INativeMinterCaller     // Read-only binding to the contract
	INativeMinterTransactor // Write-only binding to the contract
	INativeMinterFilterer   // Log filterer for contract events
}

// INativeMinterCaller is an auto generated read-only Go binding around an Ethereum contract.
type INativeMinterCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// INativeMinterTransactor is an auto generated write-only Go binding around an Ethereum contract.
type INativeMinterTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// INativeMinterFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type INativeMinterFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// INativeMinterSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type INativeMinterSession struct {
	Contract     *INativeMinter    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// INativeMinterCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type INativeMinterCallerSession struct {
	Contract *INativeMinterCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// INativeMinterTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type INativeMinterTransactorSession struct {
	Contract     *INativeMinterTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// INativeMinterRaw is an auto generated low-level Go binding around an Ethereum contract.
type INativeMinterRaw struct {
	Contract *INativeMinter // Generic contract binding to access the raw methods on
}

// INativeMinterCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type INativeMinterCallerRaw struct {
	Contract *INativeMinterCaller // Generic read-only contract binding to access the raw methods on
}

// INativeMinterTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type INativeMinterTransactorRaw struct {
	Contract *INativeMinterTransactor // Generic write-only contract binding to access the raw methods on
}

// NewINativeMinter creates a new instance of INativeMinter, bound to a specific deployed contract.
func NewINativeMinter(address common.Address, backend bind.ContractBackend) (*INativeMinter, error) {
	contract, err := bindINativeMinter(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &INativeMinter{INativeMinterCaller: INativeMinterCaller{contract: contract}, INativeMinterTransactor: INativeMinterTransactor{contract: contract}, INativeMinterFilterer: INativeMinterFilterer{contract: contract}}, nil
}

// NewINativeMinterCaller creates a new read-only instance of INativeMinter, bound to a specific deployed contract.
func NewINativeMinterCaller(address common.Address, caller bind.ContractCaller) (*INativeMinterCaller, error) {
	contract, err := bindINativeMinter(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &INativeMinterCaller{contract: contract}, nil
}

// NewINativeMinterTransactor creates a new write-only instance of INativeMinter, bound to a specific deployed contract.
func NewINativeMinterTransactor(address common.Address, transactor bind.ContractTransactor) (*INativeMinterTransactor, error) {
	contract, err := bindINativeMinter(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &INativeMinterTransactor{contract: contract}, nil
}

// NewINativeMinterFilterer creates a new log filterer instance of INativeMinter, bound to a specific deployed contract.
func NewINativeMinterFilterer(address common.Address, filterer bind.ContractFilterer) (*INativeMinterFilterer, error) {
	contract, err := bindINativeMinter(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &INativeMinterFilterer{contract: contract}, nil
}

// bindINativeMinter binds a generic wrapper to an already deployed contract.
func bindINativeMinter(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := INativeMinterMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_INativeMinter *INativeMinterRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _INativeMinter.Contract.INativeMinterCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_INativeMinter *INativeMinterRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _INativeMinter.Contract.INativeMinterTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_INativeMinter *INativeMinterRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _INativeMinter.Contract.INativeMinterTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_INativeMinter *INativeMinterCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _INativeMinter.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_INativeMinter *INativeMinterTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _INativeMinter.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_INativeMinter *INativeMinterTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _INativeMinter.Contract.contract.Transact(opts, method, params...)
}

// ReadAllowList is a free data retrieval call binding the contract method 0xeb54dae1.
//
// Solidity: function readAllowList(address addr) view returns(uint256 role)
func (_INativeMinter *INativeMinterCaller) ReadAllowList(opts *bind.CallOpts, addr common.Address) (*big.Int, error) {
	var out []interface{}
	err := _INativeMinter.contract.Call(opts, &out, "readAllowList", addr)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ReadAllowList is a free data retrieval call binding the contract method 0xeb54dae1.
//
// Solidity: function readAllowList(address addr) view returns(uint256 role)
func (_INativeMinter *INativeMinterSession) ReadAllowList(addr common.Address) (*big.Int, error) {
	return _INativeMinter.Contract.ReadAllowList(&_INativeMinter.CallOpts, addr)
}

// ReadAllowList is a free data retrieval call binding the contract method 0xeb54dae1.
//
// Solidity: function readAllowList(address addr) view returns(uint256 role)
func (_INativeMinter *INativeMinterCallerSession) ReadAllowList(addr common.Address) (*big.Int, error) {
	return _INativeMinter.Contract.ReadAllowList(&_INativeMinter.CallOpts, addr)
}

// MintNativeCoin is a paid mutator transaction binding the contract method 0x4f5aaaba.
//
// Solidity: function mintNativeCoin(address addr, uint256 amount) returns()
func (_INativeMinter *INativeMinterTransactor) MintNativeCoin(opts *bind.TransactOpts, addr common.Address, amount *big.Int) (*types.Transaction, error) {
	return _INativeMinter.contract.Transact(opts, "mintNativeCoin", addr, amount)
}

// MintNativeCoin is a paid mutator transaction binding the contract method 0x4f5aaaba.
//
// Solidity: function mintNativeCoin(address addr, uint256 amount) returns()
func (_INativeMinter *INativeMinterSession) MintNativeCoin(addr common.Address, amount *big.Int) (*types.Transaction, error) {
	return _INativeMinter.Contract.MintNativeCoin(&_INativeMinter.TransactOpts, addr, amount)
}

// MintNativeCoin is a paid mutator transaction binding the contract method 0x4f5aaaba.
//
// Solidity: function mintNativeCoin(address addr, uint256 amount) returns()
func (_INativeMinter *INativeMinterTransactorSession) MintNativeCoin(addr common.Address, amount *big.Int) (*types.Transaction, error) {
	return _INativeMinter.Contract.MintNativeCoin(&_INativeMinter.TransactOpts, addr, amount)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_INativeMinter *INativeMinterTransactor) SetAdmin(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _INativeMinter.contract.Transact(opts, "setAdmin", addr)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_INativeMinter *INativeMinterSession) SetAdmin(addr common.Address) (*types.Transaction, error) {
	return _INativeMinter.Contract.SetAdmin(&_INativeMinter.TransactOpts, addr)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_INativeMinter *INativeMinterTransactorSession) SetAdmin(addr common.Address) (*types.Transaction, error) {
	return _INativeMinter.Contract.SetAdmin(&_INativeMinter.TransactOpts, addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_INativeMinter *INativeMinterTransactor) SetEnabled(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _INativeMinter.contract.Transact(opts, "setEnabled", addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_INativeMinter *INativeMinterSession) SetEnabled(addr common.Address) (*types.Transaction, error) {
	return _INativeMinter.Contract.SetEnabled(&_INativeMinter.TransactOpts, addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_INativeMinter *INativeMinterTransactorSession) SetEnabled(addr common.Address) (*types.Transaction, error) {
	return _INativeMinter.Contract.SetEnabled(&_INativeMinter.TransactOpts, addr)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_INativeMinter *INativeMinterTransactor) SetManager(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _INativeMinter.contract.Transact(opts, "setManager", addr)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_INativeMinter *INativeMinterSession) SetManager(addr common.Address) (*types.Transaction, error) {
	return _INativeMinter.Contract.SetManager(&_INativeMinter.TransactOpts, addr)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_INativeMinter *INativeMinterTransactorSession) SetManager(addr common.Address) (*types.Transaction, error) {
	return _INativeMinter.Contract.SetManager(&_INativeMinter.TransactOpts, addr)
}

// SetNone is a paid mutator transaction binding the contract method 0x8c6bfb3b.
//
// Solidity: function setNone(address addr) returns()
func (_INativeMinter *INativeMinterTransactor) SetNone(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _INativeMinter.contract.Transact(opts, "setNone", addr)
}

// SetNone is a paid mutator transaction binding the contract method 0x8c6bfb3b.
//
// Solidity: function setNone(address addr) returns()
func (_INativeMinter *INativeMinterSession) SetNone(addr common.Address) (*types.Transaction, error) {
	return _INativeMinter.Contract.SetNone(&_INativeMinter.TransactOpts, addr)
}

// SetNone is a paid mutator transaction binding the contract method 0x8c6bfb3b.
//
// Solidity: function setNone(address addr) returns()
func (_INativeMinter *INativeMinterTransactorSession) SetNone(addr common.Address) (*types.Transaction, error) {
	return _INativeMinter.Contract.SetNone(&_INativeMinter.TransactOpts, addr)
}

// INativeMinterNativeCoinMintedIterator is returned from FilterNativeCoinMinted and is used to iterate over the raw logs and unpacked data for NativeCoinMinted events raised by the INativeMinter contract.
type INativeMinterNativeCoinMintedIterator struct {
	Event *INativeMinterNativeCoinMinted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *INativeMinterNativeCoinMintedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(INativeMinterNativeCoinMinted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(INativeMinterNativeCoinMinted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *INativeMinterNativeCoinMintedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *INativeMinterNativeCoinMintedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// INativeMinterNativeCoinMinted represents a NativeCoinMinted event raised by the INativeMinter contract.
type INativeMinterNativeCoinMinted struct {
	Sender    common.Address
	Recipient common.Address
	Amount    *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterNativeCoinMinted is a free log retrieval operation binding the contract event 0x400cd392f3d56fd10bb1dbd5839fdda8298208ddaa97b368faa053e1850930ee.
//
// Solidity: event NativeCoinMinted(address indexed sender, address indexed recipient, uint256 amount)
func (_INativeMinter *INativeMinterFilterer) FilterNativeCoinMinted(opts *bind.FilterOpts, sender []common.Address, recipient []common.Address) (*INativeMinterNativeCoinMintedIterator, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}
	var recipientRule []interface{}
	for _, recipientItem := range recipient {
		recipientRule = append(recipientRule, recipientItem)
	}

	logs, sub, err := _INativeMinter.contract.FilterLogs(opts, "NativeCoinMinted", senderRule, recipientRule)
	if err != nil {
		return nil, err
	}
	return &INativeMinterNativeCoinMintedIterator{contract: _INativeMinter.contract, event: "NativeCoinMinted", logs: logs, sub: sub}, nil
}

// WatchNativeCoinMinted is a free log subscription operation binding the contract event 0x400cd392f3d56fd10bb1dbd5839fdda8298208ddaa97b368faa053e1850930ee.
//
// Solidity: event NativeCoinMinted(address indexed sender, address indexed recipient, uint256 amount)
func (_INativeMinter *INativeMinterFilterer) WatchNativeCoinMinted(opts *bind.WatchOpts, sink chan<- *INativeMinterNativeCoinMinted, sender []common.Address, recipient []common.Address) (event.Subscription, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}
	var recipientRule []interface{}
	for _, recipientItem := range recipient {
		recipientRule = append(recipientRule, recipientItem)
	}

	logs, sub, err := _INativeMinter.contract.WatchLogs(opts, "NativeCoinMinted", senderRule, recipientRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(INativeMinterNativeCoinMinted)
				if err := _INativeMinter.contract.UnpackLog(event, "NativeCoinMinted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNativeCoinMinted is a log parse operation binding the contract event 0x400cd392f3d56fd10bb1dbd5839fdda8298208ddaa97b368faa053e1850930ee.
//
// Solidity: event NativeCoinMinted(address indexed sender, address indexed recipient, uint256 amount)
func (_INativeMinter *INativeMinterFilterer) ParseNativeCoinMinted(log types.Log) (*INativeMinterNativeCoinMinted, error) {
	event := new(INativeMinterNativeCoinMinted)
	if err := _INativeMinter.contract.UnpackLog(event, "NativeCoinMinted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// INativeMinterRoleSetIterator is returned from FilterRoleSet and is used to iterate over the raw logs and unpacked data for RoleSet events raised by the INativeMinter contract.
type INativeMinterRoleSetIterator struct {
	Event *INativeMinterRoleSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *INativeMinterRoleSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(INativeMinterRoleSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(INativeMinterRoleSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *INativeMinterRoleSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *INativeMinterRoleSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// INativeMinterRoleSet represents a RoleSet event raised by the INativeMinter contract.
type INativeMinterRoleSet struct {
	Role    *big.Int
	Account common.Address
	Sender  common.Address
	OldRole *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleSet is a free log retrieval operation binding the contract event 0xcdb7ea01f00a414d78757bdb0f6391664ba3fedf987eed280927c1e7d695be3e.
//
// Solidity: event RoleSet(uint256 indexed role, address indexed account, address indexed sender, uint256 oldRole)
func (_INativeMinter *INativeMinterFilterer) FilterRoleSet(opts *bind.FilterOpts, role []*big.Int, account []common.Address, sender []common.Address) (*INativeMinterRoleSetIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _INativeMinter.contract.FilterLogs(opts, "RoleSet", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &INativeMinterRoleSetIterator{contract: _INativeMinter.contract, event: "RoleSet", logs: logs, sub: sub}, nil
}

// WatchRoleSet is a free log subscription operation binding the contract event 0xcdb7ea01f00a414d78757bdb0f6391664ba3fedf987eed280927c1e7d695be3e.
//
// Solidity: event RoleSet(uint256 indexed role, address indexed account, address indexed sender, uint256 oldRole)
func (_INativeMinter *INativeMinterFilterer) WatchRoleSet(opts *bind.WatchOpts, sink chan<- *INativeMinterRoleSet, role []*big.Int, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _INativeMinter.contract.WatchLogs(opts, "RoleSet", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(INativeMinterRoleSet)
				if err := _INativeMinter.contract.UnpackLog(event, "RoleSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleSet is a log parse operation binding the contract event 0xcdb7ea01f00a414d78757bdb0f6391664ba3fedf987eed280927c1e7d695be3e.
//
// Solidity: event RoleSet(uint256 indexed role, address indexed account, address indexed sender, uint256 oldRole)
func (_INativeMinter *INativeMinterFilterer) ParseRoleSet(log types.Log) (*INativeMinterRoleSet, error) {
	event := new(INativeMinterRoleSet)
	if err := _INativeMinter.contract.UnpackLog(event, "RoleSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IRewardManagerMetaData contains all meta data concerning the IRewardManager contract.
var IRewardManagerMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"FeeRecipientsAllowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldRewardAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRewardAddress\",\"type\":\"address\"}],\"name\":\"RewardAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RewardsDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"role\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldRole\",\"type\":\"uint256\"}],\"name\":\"RoleSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"allowFeeRecipients\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"areFeeRecipientsAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isAllowed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRewardAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"rewardAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"readAllowList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"role\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setNone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setRewardAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IRewardManagerABI is the input ABI used to generate the binding from.
// Deprecated: Use IRewardManagerMetaData.ABI instead.
var IRewardManagerABI = IRewardManagerMetaData.ABI

// IRewardManager is an auto generated Go binding around an Ethereum contract.
type IRewardManager struct {
	IRewardManagerCaller     // Read-only binding to the contract
	IRewardManagerTransactor // Write-only binding to the contract
	IRewardManagerFilterer   // Log filterer for contract events
}

// IRewardManagerCaller is an auto generated read-only Go binding around an Ethereum contract.
type IRewardManagerCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IRewardManagerTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IRewardManagerTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IRewardManagerFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IRewardManagerFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IRewardManagerSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IRewardManagerSession struct {
	Contract     *IRewardManager   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IRewardManagerCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IRewardManagerCallerSession struct {
	Contract *IRewardManagerCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// IRewardManagerTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IRewardManagerTransactorSession struct {
	Contract     *IRewardManagerTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// IRewardManagerRaw is an auto generated low-level Go binding around an Ethereum contract.
type IRewardManagerRaw struct {
	Contract *IRewardManager // Generic contract binding to access the raw methods on
}

// IRewardManagerCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IRewardManagerCallerRaw struct {
	Contract *IRewardManagerCaller // Generic read-only contract binding to access the raw methods on
}

// IRewardManagerTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IRewardManagerTransactorRaw struct {
	Contract *IRewardManagerTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIRewardManager creates a new instance of IRewardManager, bound to a specific deployed contract.
func NewIRewardManager(address common.Address, backend bind.ContractBackend) (*IRewardManager, error) {
	contract, err := bindIRewardManager(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IRewardManager{IRewardManagerCaller: IRewardManagerCaller{contract: contract}, IRewardManagerTransactor: IRewardManagerTransactor{contract: contract}, IRewardManagerFilterer: IRewardManagerFilterer{contract: contract}}, nil
}

// NewIRewardManagerCaller creates a new read-only instance of IRewardManager, bound to a specific deployed contract.
func NewIRewardManagerCaller(address common.Address, caller bind.ContractCaller) (*IRewardManagerCaller, error) {
	contract, err := bindIRewardManager(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IRewardManagerCaller{contract: contract}, nil
}

// NewIRewardManagerTransactor creates a new write-only instance of IRewardManager, bound to a specific deployed contract.
func NewIRewardManagerTransactor(address common.Address, transactor bind.ContractTransactor) (*IRewardManagerTransactor, error) {
	contract, err := bindIRewardManager(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IRewardManagerTransactor{contract: contract}, nil
}

// NewIRewardManagerFilterer creates a new log filterer instance of IRewardManager, bound to a specific deployed contract.
func NewIRewardManagerFilterer(address common.Address, filterer bind.ContractFilterer) (*IRewardManagerFilterer, error) {
	contract, err := bindIRewardManager(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IRewardManagerFilterer{contract: contract}, nil
}

// bindIRewardManager binds a generic wrapper to an already deployed contract.
func bindIRewardManager(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IRewardManagerMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IRewardManager *IRewardManagerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IRewardManager.Contract.IRewardManagerCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IRewardManager *IRewardManagerRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IRewardManager.Contract.IRewardManagerTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IRewardManager *IRewardManagerRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IRewardManager.Contract.IRewardManagerTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IRewardManager *IRewardManagerCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IRewardManager.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IRewardManager *IRewardManagerTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IRewardManager.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IRewardManager *IRewardManagerTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IRewardManager.Contract.contract.Transact(opts, method, params...)
}

// AreFeeRecipientsAllowed is a free data retrieval call binding the contract method 0xf6542b2e.
//
// Solidity: function areFeeRecipientsAllowed() view returns(bool isAllowed)
func (_IRewardManager *IRewardManagerCaller) AreFeeRecipientsAllowed(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _IRewardManager.contract.Call(opts, &out, "areFeeRecipientsAllowed")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// AreFeeRecipientsAllowed is a free data retrieval call binding the contract method 0xf6542b2e.
//
// Solidity: function areFeeRecipientsAllowed() view returns(bool isAllowed)
func (_IRewardManager *IRewardManagerSession) AreFeeRecipientsAllowed() (bool, error) {
	return _IRewardManager.Contract.AreFeeRecipientsAllowed(&_IRewardManager.CallOpts)
}

// AreFeeRecipientsAllowed is a free data retrieval call binding the contract method 0xf6542b2e.
//
// Solidity: function areFeeRecipientsAllowed() view returns(bool isAllowed)
func (_IRewardManager *IRewardManagerCallerSession) AreFeeRecipientsAllowed() (bool, error) {
	return _IRewardManager.Contract.AreFeeRecipientsAllowed(&_IRewardManager.CallOpts)
}

// CurrentRewardAddress is a free data retrieval call binding the contract method 0xe915608b.
//
// Solidity: function currentRewardAddress() view returns(address rewardAddress)
func (_IRewardManager *IRewardManagerCaller) CurrentRewardAddress(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IRewardManager.contract.Call(opts, &out, "currentRewardAddress")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// CurrentRewardAddress is a free data retrieval call binding the contract method 0xe915608b.
//
// Solidity: function currentRewardAddress() view returns(address rewardAddress)
func (_IRewardManager *IRewardManagerSession) CurrentRewardAddress() (common.Address, error) {
	return _IRewardManager.Contract.CurrentRewardAddress(&_IRewardManager.CallOpts)
}

// CurrentRewardAddress is a free data retrieval call binding the contract method 0xe915608b.
//
// Solidity: function currentRewardAddress() view returns(address rewardAddress)
func (_IRewardManager *IRewardManagerCallerSession) CurrentRewardAddress() (common.Address, error) {
	return _IRewardManager.Contract.CurrentRewardAddress(&_IRewardManager.CallOpts)
}

// ReadAllowList is a free data retrieval call binding the contract method 0xeb54dae1.
//
// Solidity: function readAllowList(address addr) view returns(uint256 role)
func (_IRewardManager *IRewardManagerCaller) ReadAllowList(opts *bind.CallOpts, addr common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IRewardManager.contract.Call(opts, &out, "readAllowList", addr)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ReadAllowList is a free data retrieval call binding the contract method 0xeb54dae1.
//
// Solidity: function readAllowList(address addr) view returns(uint256 role)
func (_IRewardManager *IRewardManagerSession) ReadAllowList(addr common.Address) (*big.Int, error) {
	return _IRewardManager.Contract.ReadAllowList(&_IRewardManager.CallOpts, addr)
}

// ReadAllowList is a free data retrieval call binding the contract method 0xeb54dae1.
//
// Solidity: function readAllowList(address addr) view returns(uint256 role)
func (_IRewardManager *IRewardManagerCallerSession) ReadAllowList(addr common.Address) (*big.Int, error) {
	return _IRewardManager.Contract.ReadAllowList(&_IRewardManager.CallOpts, addr)
}

// AllowFeeRecipients is a paid mutator transaction binding the contract method 0x0329099f.
//
// Solidity: function allowFeeRecipients() returns()
func (_IRewardManager *IRewardManagerTransactor) AllowFeeRecipients(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IRewardManager.contract.Transact(opts, "allowFeeRecipients")
}

// AllowFeeRecipients is a paid mutator transaction binding the contract method 0x0329099f.
//
// Solidity: function allowFeeRecipients() returns()
func (_IRewardManager *IRewardManagerSession) AllowFeeRecipients() (*types.Transaction, error) {
	return _IRewardManager.Contract.AllowFeeRecipients(&_IRewardManager.TransactOpts)
}

// AllowFeeRecipients is a paid mutator transaction binding the contract method 0x0329099f.
//
// Solidity: function allowFeeRecipients() returns()
func (_IRewardManager *IRewardManagerTransactorSession) AllowFeeRecipients() (*types.Transaction, error) {
	return _IRewardManager.Contract.AllowFeeRecipients(&_IRewardManager.TransactOpts)
}

// DisableRewards is a paid mutator transaction binding the contract method 0xbc178628.
//
// Solidity: function disableRewards() returns()
func (_IRewardManager *IRewardManagerTransactor) DisableRewards(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IRewardManager.contract.Transact(opts, "disableRewards")
}

// DisableRewards is a paid mutator transaction binding the contract method 0xbc178628.
//
// Solidity: function disableRewards() returns()
func (_IRewardManager *IRewardManagerSession) DisableRewards() (*types.Transaction, error) {
	return _IRewardManager.Contract.DisableRewards(&_IRewardManager.TransactOpts)
}

// DisableRewards is a paid mutator transaction binding the contract method 0xbc178628.
//
// Solidity: function disableRewards() returns()
func (_IRewardManager *IRewardManagerTransactorSession) DisableRewards() (*types.Transaction, error) {
	return _IRewardManager.Contract.DisableRewards(&_IRewardManager.TransactOpts)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_IRewardManager *IRewardManagerTransactor) SetAdmin(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _IRewardManager.contract.Transact(opts, "setAdmin", addr)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_IRewardManager *IRewardManagerSession) SetAdmin(addr common.Address) (*types.Transaction, error) {
	return _IRewardManager.Contract.SetAdmin(&_IRewardManager.TransactOpts, addr)
}

// SetAdmin is a paid mutator transaction binding the contract method 0x704b6c02.
//
// Solidity: function setAdmin(address addr) returns()
func (_IRewardManager *IRewardManagerTransactorSession) SetAdmin(addr common.Address) (*types.Transaction, error) {
	return _IRewardManager.Contract.SetAdmin(&_IRewardManager.TransactOpts, addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_IRewardManager *IRewardManagerTransactor) SetEnabled(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _IRewardManager.contract.Transact(opts, "setEnabled", addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_IRewardManager *IRewardManagerSession) SetEnabled(addr common.Address) (*types.Transaction, error) {
	return _IRewardManager.Contract.SetEnabled(&_IRewardManager.TransactOpts, addr)
}

// SetEnabled is a paid mutator transaction binding the contract method 0x0aaf7043.
//
// Solidity: function setEnabled(address addr) returns()
func (_IRewardManager *IRewardManagerTransactorSession) SetEnabled(addr common.Address) (*types.Transaction, error) {
	return _IRewardManager.Contract.SetEnabled(&_IRewardManager.TransactOpts, addr)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_IRewardManager *IRewardManagerTransactor) SetManager(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _IRewardManager.contract.Transact(opts, "setManager", addr)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_IRewardManager *IRewardManagerSession) SetManager(addr common.Address) (*types.Transaction, error) {
	return _IRewardManager.Contract.SetManager(&_IRewardManager.TransactOpts, addr)
}

// SetManager is a paid mutator transaction binding the contract method 0xd0ebdbe7.
//
// Solidity: function setManager(address addr) returns()
func (_IRewardManager *IRewardManagerTransactorSession) SetManager(addr common.Address) (*types.Transaction, error) {
	return _IRewardManager.Contract.SetManager(&_IRewardManager.TransactOpts, addr)
}

// SetNone is a paid mutator transaction binding the contract method 0x8c6bfb3b.
//
// Solidity: function setNone(address addr) returns()
func (_IRewardManager *IRewardManagerTransactor) SetNone(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _IRewardManager.contract.Transact(opts, "setNone", addr)
}

// SetNone is a paid mutator transaction binding the contract method 0x8c6bfb3b.
//
// Solidity: function setNone(address addr) returns()
func (_IRewardManager *IRewardManagerSession) SetNone(addr common.Address) (*types.Transaction, error) {
	return _IRewardManager.Contract.SetNone(&_IRewardManager.TransactOpts, addr)
}

// SetNone is a paid mutator transaction binding the contract method 0x8c6bfb3b.
//
// Solidity: function setNone(address addr) returns()
func (_IRewardManager *IRewardManagerTransactorSession) SetNone(addr common.Address) (*types.Transaction, error) {
	return _IRewardManager.Contract.SetNone(&_IRewardManager.TransactOpts, addr)
}

// SetRewardAddress is a paid mutator transaction binding the contract method 0x5e00e679.
//
// Solidity: function setRewardAddress(address addr) returns()
func (_IRewardManager *IRewardManagerTransactor) SetRewardAddress(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _IRewardManager.contract.Transact(opts, "setRewardAddress", addr)
}

// SetRewardAddress is a paid mutator transaction binding the contract method 0x5e00e679.
//
// Solidity: function setRewardAddress(address addr) returns()
func (_IRewardManager *IRewardManagerSession) SetRewardAddress(addr common.Address) (*types.Transaction, error) {
	return _IRewardManager.Contract.SetRewardAddress(&_IRewardManager.TransactOpts, addr)
}

// SetRewardAddress is a paid mutator transaction binding the contract method 0x5e00e679.
//
// Solidity: function setRewardAddress(address addr) returns()
func (_IRewardManager *IRewardManagerTransactorSession) SetRewardAddress(addr common.Address) (*types.Transaction, error) {
	return _IRewardManager.Contract.SetRewardAddress(&_IRewardManager.TransactOpts, addr)
}

// IRewardManagerFeeRecipientsAllowedIterator is returned from FilterFeeRecipientsAllowed and is used to iterate over the raw logs and unpacked data for FeeRecipientsAllowed events raised by the IRewardManager contract.
type IRewardManagerFeeRecipientsAllowedIterator struct {
	Event *IRewardManagerFeeRecipientsAllowed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IRewardManagerFeeRecipientsAllowedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IRewardManagerFeeRecipientsAllowed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IRewardManagerFeeRecipientsAllowed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IRewardManagerFeeRecipientsAllowedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IRewardManagerFeeRecipientsAllowedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IRewardManagerFeeRecipientsAllowed represents a FeeRecipientsAllowed event raised by the IRewardManager contract.
type IRewardManagerFeeRecipientsAllowed struct {
	Sender common.Address
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterFeeRecipientsAllowed is a free log retrieval operation binding the contract event 0xabb1949bd129fef9b84601a48aee89d600d90074ca10216a02ce43996be55991.
//
// Solidity: event FeeRecipientsAllowed(address indexed sender)
func (_IRewardManager *IRewardManagerFilterer) FilterFeeRecipientsAllowed(opts *bind.FilterOpts, sender []common.Address) (*IRewardManagerFeeRecipientsAllowedIterator, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IRewardManager.contract.FilterLogs(opts, "FeeRecipientsAllowed", senderRule)
	if err != nil {
		return nil, err
	}
	return &IRewardManagerFeeRecipientsAllowedIterator{contract: _IRewardManager.contract, event: "FeeRecipientsAllowed", logs: logs, sub: sub}, nil
}

// WatchFeeRecipientsAllowed is a free log subscription operation binding the contract event 0xabb1949bd129fef9b84601a48aee89d600d90074ca10216a02ce43996be55991.
//
// Solidity: event FeeRecipientsAllowed(address indexed sender)
func (_IRewardManager *IRewardManagerFilterer) WatchFeeRecipientsAllowed(opts *bind.WatchOpts, sink chan<- *IRewardManagerFeeRecipientsAllowed, sender []common.Address) (event.Subscription, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IRewardManager.contract.WatchLogs(opts, "FeeRecipientsAllowed", senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IRewardManagerFeeRecipientsAllowed)
				if err := _IRewardManager.contract.UnpackLog(event, "FeeRecipientsAllowed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFeeRecipientsAllowed is a log parse operation binding the contract event 0xabb1949bd129fef9b84601a48aee89d600d90074ca10216a02ce43996be55991.
//
// Solidity: event FeeRecipientsAllowed(address indexed sender)
func (_IRewardManager *IRewardManagerFilterer) ParseFeeRecipientsAllowed(log types.Log) (*IRewardManagerFeeRecipientsAllowed, error) {
	event := new(IRewardManagerFeeRecipientsAllowed)
	if err := _IRewardManager.contract.UnpackLog(event, "FeeRecipientsAllowed", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IRewardManagerRewardAddressChangedIterator is returned from FilterRewardAddressChanged and is used to iterate over the raw logs and unpacked data for RewardAddressChanged events raised by the IRewardManager contract.
type IRewardManagerRewardAddressChangedIterator struct {
	Event *IRewardManagerRewardAddressChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IRewardManagerRewardAddressChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IRewardManagerRewardAddressChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IRewardManagerRewardAddressChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IRewardManagerRewardAddressChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IRewardManagerRewardAddressChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IRewardManagerRewardAddressChanged represents a RewardAddressChanged event raised by the IRewardManager contract.
type IRewardManagerRewardAddressChanged struct {
	Sender           common.Address
	OldRewardAddress common.Address
	NewRewardAddress common.Address
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterRewardAddressChanged is a free log retrieval operation binding the contract event 0xc2a9e07cba6f4920acaa5933bd0406949d5dbef7ee698e786ea23e8708f32a6c.
//
// Solidity: event RewardAddressChanged(address indexed sender, address indexed oldRewardAddress, address indexed newRewardAddress)
func (_IRewardManager *IRewardManagerFilterer) FilterRewardAddressChanged(opts *bind.FilterOpts, sender []common.Address, oldRewardAddress []common.Address, newRewardAddress []common.Address) (*IRewardManagerRewardAddressChangedIterator, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}
	var oldRewardAddressRule []interface{}
	for _, oldRewardAddressItem := range oldRewardAddress {
		oldRewardAddressRule = append(oldRewardAddressRule, oldRewardAddressItem)
	}
	var newRewardAddressRule []interface{}
	for _, newRewardAddressItem := range newRewardAddress {
		newRewardAddressRule = append(newRewardAddressRule, newRewardAddressItem)
	}

	logs, sub, err := _IRewardManager.contract.FilterLogs(opts, "RewardAddressChanged", senderRule, oldRewardAddressRule, newRewardAddressRule)
	if err != nil {
		return nil, err
	}
	return &IRewardManagerRewardAddressChangedIterator{contract: _IRewardManager.contract, event: "RewardAddressChanged", logs: logs, sub: sub}, nil
}

// WatchRewardAddressChanged is a free log subscription operation binding the contract event 0xc2a9e07cba6f4920acaa5933bd0406949d5dbef7ee698e786ea23e8708f32a6c.
//
// Solidity: event RewardAddressChanged(address indexed sender, address indexed oldRewardAddress, address indexed newRewardAddress)
func (_IRewardManager *IRewardManagerFilterer) WatchRewardAddressChanged(opts *bind.WatchOpts, sink chan<- *IRewardManagerRewardAddressChanged, sender []common.Address, oldRewardAddress []common.Address, newRewardAddress []common.Address) (event.Subscription, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}
	var oldRewardAddressRule []interface{}
	for _, oldRewardAddressItem := range oldRewardAddress {
		oldRewardAddressRule = append(oldRewardAddressRule, oldRewardAddressItem)
	}
	var newRewardAddressRule []interface{}
	for _, newRewardAddressItem := range newRewardAddress {
		newRewardAddressRule = append(newRewardAddressRule, newRewardAddressItem)
	}

	logs, sub, err := _IRewardManager.contract.WatchLogs(opts, "RewardAddressChanged", senderRule, oldRewardAddressRule, newRewardAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IRewardManagerRewardAddressChanged)
				if err := _IRewardManager.contract.UnpackLog(event, "RewardAddressChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRewardAddressChanged is a log parse operation binding the contract event 0xc2a9e07cba6f4920acaa5933bd0406949d5dbef7ee698e786ea23e8708f32a6c.
//
// Solidity: event RewardAddressChanged(address indexed sender, address indexed oldRewardAddress, address indexed newRewardAddress)
func (_IRewardManager *IRewardManagerFilterer) ParseRewardAddressChanged(log types.Log) (*IRewardManagerRewardAddressChanged, error) {
	event := new(IRewardManagerRewardAddressChanged)
	if err := _IRewardManager.contract.UnpackLog(event, "RewardAddressChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IRewardManagerRewardsDisabledIterator is returned from FilterRewardsDisabled and is used to iterate over the raw logs and unpacked data for RewardsDisabled events raised by the IRewardManager contract.
type IRewardManagerRewardsDisabledIterator struct {
	Event *IRewardManagerRewardsDisabled // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IRewardManagerRewardsDisabledIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IRewardManagerRewardsDisabled)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IRewardManagerRewardsDisabled)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IRewardManagerRewardsDisabledIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IRewardManagerRewardsDisabledIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IRewardManagerRewardsDisabled represents a RewardsDisabled event raised by the IRewardManager contract.
type IRewardManagerRewardsDisabled struct {
	Sender common.Address
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterRewardsDisabled is a free log retrieval operation binding the contract event 0xeb121f0335efe8f4b8ebef7793c18c171834696989656a8c345acc558359fabf.
//
// Solidity: event RewardsDisabled(address indexed sender)
func (_IRewardManager *IRewardManagerFilterer) FilterRewardsDisabled(opts *bind.FilterOpts, sender []common.Address) (*IRewardManagerRewardsDisabledIterator, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IRewardManager.contract.FilterLogs(opts, "RewardsDisabled", senderRule)
	if err != nil {
		return nil, err
	}
	return &IRewardManagerRewardsDisabledIterator{contract: _IRewardManager.contract, event: "RewardsDisabled", logs: logs, sub: sub}, nil
}

// WatchRewardsDisabled is a free log subscription operation binding the contract event 0xeb121f0335efe8f4b8ebef7793c18c171834696989656a8c345acc558359fabf.
//
// Solidity: event RewardsDisabled(address indexed sender)
func (_IRewardManager *IRewardManagerFilterer) WatchRewardsDisabled(opts *bind.WatchOpts, sink chan<- *IRewardManagerRewardsDisabled, sender []common.Address) (event.Subscription, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IRewardManager.contract.WatchLogs(opts, "RewardsDisabled", senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IRewardManagerRewardsDisabled)
				if err := _IRewardManager.contract.UnpackLog(event, "RewardsDisabled", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRewardsDisabled is a log parse operation binding the contract event 0xeb121f0335efe8f4b8ebef7793c18c171834696989656a8c345acc558359fabf.
//
// Solidity: event RewardsDisabled(address indexed sender)
func (_IRewardManager *IRewardManagerFilterer) ParseRewardsDisabled(log types.Log) (*IRewardManagerRewardsDisabled, error) {
	event := new(IRewardManagerRewardsDisabled)
	if err := _IRewardManager.contract.UnpackLog(event, "RewardsDisabled", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IRewardManagerRoleSetIterator is returned from FilterRoleSet and is used to iterate over the raw logs and unpacked data for RoleSet events raised by the IRewardManager contract.
type IRewardManagerRoleSetIterator struct {
	Event *IRewardManagerRoleSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IRewardManagerRoleSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IRewardManagerRoleSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IRewardManagerRoleSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IRewardManagerRoleSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IRewardManagerRoleSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IRewardManagerRoleSet represents a RoleSet event raised by the IRewardManager contract.
type IRewardManagerRoleSet struct {
	Role    *big.Int
	Account common.Address
	Sender  common.Address
	OldRole *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleSet is a free log retrieval operation binding the contract event 0xcdb7ea01f00a414d78757bdb0f6391664ba3fedf987eed280927c1e7d695be3e.
//
// Solidity: event RoleSet(uint256 indexed role, address indexed account, address indexed sender, uint256 oldRole)
func (_IRewardManager *IRewardManagerFilterer) FilterRoleSet(opts *bind.FilterOpts, role []*big.Int, account []common.Address, sender []common.Address) (*IRewardManagerRoleSetIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IRewardManager.contract.FilterLogs(opts, "RoleSet", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &IRewardManagerRoleSetIterator{contract: _IRewardManager.contract, event: "RoleSet", logs: logs, sub: sub}, nil
}

// WatchRoleSet is a free log subscription operation binding the contract event 0xcdb7ea01f00a414d78757bdb0f6391664ba3fedf987eed280927c1e7d695be3e.
//
// Solidity: event RoleSet(uint256 indexed role, address indexed account, address indexed sender, uint256 oldRole)
func (_IRewardManager *IRewardManagerFilterer) WatchRoleSet(opts *bind.WatchOpts, sink chan<- *IRewardManagerRoleSet, role []*big.Int, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IRewardManager.contract.WatchLogs(opts, "RoleSet", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IRewardManagerRoleSet)
				if err := _IRewardManager.contract.UnpackLog(event, "RoleSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleSet is a log parse operation binding the contract event 0xcdb7ea01f00a414d78757bdb0f6391664ba3fedf987eed280927c1e7d695be3e.
//
// Solidity: event RoleSet(uint256 indexed role, address indexed account, address indexed sender, uint256 oldRole)
func (_IRewardManager *IRewardManagerFilterer) ParseRoleSet(log types.Log) (*IRewardManagerRoleSet, error) {
	event := new(IRewardManagerRoleSet)
	if err := _IRewardManager.contract.UnpackLog(event, "RoleSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IWarpMessengerMetaData contains all meta data concerning the IWarpMessenger contract.
var IWarpMessengerMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"messageID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"SendWarpMessage\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"getBlockchainID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"blockchainID\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"index\",\"type\":\"uint32\"}],\"name\":\"getVerifiedWarpBlockHash\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"sourceChainID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"}],\"internalType\":\"structWarpBlockHash\",\"name\":\"warpBlockHash\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"index\",\"type\":\"uint32\"}],\"name\":\"getVerifiedWarpMessage\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"sourceChainID\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"originSenderAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"structWarpMessage\",\"name\":\"message\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"sendWarpMessage\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"messageID\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IWarpMessengerABI is the input ABI used to generate the binding from.
// Deprecated: Use IWarpMessengerMetaData.ABI instead.
var IWarpMessengerABI = IWarpMessengerMetaData.ABI

// IWarpMessenger is an auto generated Go binding around an Ethereum contract.
type IWarpMessenger struct {
	IWarpMessengerCaller     // Read-only binding to the contract
	IWarpMessengerTransactor // Write-only binding to the contract
	IWarpMessengerFilterer   // Log filterer for contract events
}

// IWarpMessengerCaller is an auto generated read-only Go binding around an Ethereum contract.
type IWarpMessengerCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IWarpMessengerTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IWarpMessengerTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IWarpMessengerFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IWarpMessengerFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IWarpMessengerSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IWarpMessengerSession struct {
	Contract     *IWarpMessenger   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IWarpMessengerCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IWarpMessengerCallerSession struct {
	Contract *IWarpMessengerCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// IWarpMessengerTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IWarpMessengerTransactorSession struct {
	Contract     *IWarpMessengerTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// IWarpMessengerRaw is an auto generated low-level Go binding around an Ethereum contract.
type IWarpMessengerRaw struct {
	Contract *IWarpMessenger // Generic contract binding to access the raw methods on
}

// IWarpMessengerCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IWarpMessengerCallerRaw struct {
	Contract *IWarpMessengerCaller // Generic read-only contract binding to access the raw methods on
}

// IWarpMessengerTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IWarpMessengerTransactorRaw struct {
	Contract *IWarpMessengerTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIWarpMessenger creates a new instance of IWarpMessenger, bound to a specific deployed contract.
func NewIWarpMessenger(address common.Address, backend bind.ContractBackend) (*IWarpMessenger, error) {
	contract, err := bindIWarpMessenger(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IWarpMessenger{IWarpMessengerCaller: IWarpMessengerCaller{contract: contract}, IWarpMessengerTransactor: IWarpMessengerTransactor{contract: contract}, IWarpMessengerFilterer: IWarpMessengerFilterer{contract: contract}}, nil
}

// NewIWarpMessengerCaller creates a new read-only instance of IWarpMessenger, bound to a specific deployed contract.
func NewIWarpMessengerCaller(address common.Address, caller bind.ContractCaller) (*IWarpMessengerCaller, error) {
	contract, err := bindIWarpMessenger(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IWarpMessengerCaller{contract: contract}, nil
}

// NewIWarpMessengerTransactor creates a new write-only instance of IWarpMessenger, bound to a specific deployed contract.
func NewIWarpMessengerTransactor(address common.Address, transactor bind.ContractTransactor) (*IWarpMessengerTransactor, error) {
	contract, err := bindIWarpMessenger(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IWarpMessengerTransactor{contract: contract}, nil
}

// NewIWarpMessengerFilterer creates a new log filterer instance of IWarpMessenger, bound to a specific deployed contract.
func NewIWarpMessengerFilterer(address common.Address, filterer bind.ContractFilterer) (*IWarpMessengerFilterer, error) {
	contract, err := bindIWarpMessenger(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IWarpMessengerFilterer{contract: contract}, nil
}

// bindIWarpMessenger binds a generic wrapper to an already deployed contract.
func bindIWarpMessenger(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IWarpMessengerMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IWarpMessenger *IWarpMessengerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IWarpMessenger.Contract.IWarpMessengerCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IWarpMessenger *IWarpMessengerRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IWarpMessenger.Contract.IWarpMessengerTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IWarpMessenger *IWarpMessengerRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IWarpMessenger.Contract.IWarpMessengerTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IWarpMessenger *IWarpMessengerCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IWarpMessenger.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IWarpMessenger *IWarpMessengerTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IWarpMessenger.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IWarpMessenger *IWarpMessengerTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IWarpMessenger.Contract.contract.Transact(opts, method, params...)
}

// GetBlockchainID is a free data retrieval call binding the contract method 0x4213cf78.
//
// Solidity: function getBlockchainID() view returns(bytes32 blockchainID)
func (_IWarpMessenger *IWarpMessengerCaller) GetBlockchainID(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _IWarpMessenger.contract.Call(opts, &out, "getBlockchainID")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// GetBlockchainID is a free data retrieval call binding the contract method 0x4213cf78.
//
// Solidity: function getBlockchainID() view returns(bytes32 blockchainID)
func (_IWarpMessenger *IWarpMessengerSession) GetBlockchainID() ([32]byte, error) {
	return _IWarpMessenger.Contract.GetBlockchainID(&_IWarpMessenger.CallOpts)
}

// GetBlockchainID is a free data retrieval call binding the contract method 0x4213cf78.
//
// Solidity: function getBlockchainID() view returns(bytes32 blockchainID)
func (_IWarpMessenger *IWarpMessengerCallerSession) GetBlockchainID() ([32]byte, error) {
	return _IWarpMessenger.Contract.GetBlockchainID(&_IWarpMessenger.CallOpts)
}

// GetVerifiedWarpBlockHash is a free data retrieval call binding the contract method 0xce7f5929.
//
// Solidity: function getVerifiedWarpBlockHash(uint32 index) view returns((bytes32,bytes32) warpBlockHash, bool valid)
func (_IWarpMessenger *IWarpMessengerCaller) GetVerifiedWarpBlockHash(opts *bind.CallOpts, index uint32) (struct {
	WarpBlockHash WarpBlockHash
	Valid         bool
}, error) {
	var out []interface{}
	err := _IWarpMessenger.contract.Call(opts, &out, "getVerifiedWarpBlockHash", index)

	outstruct := new(struct {
		WarpBlockHash WarpBlockHash
		Valid         bool
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.WarpBlockHash = *abi.ConvertType(out[0], new(WarpBlockHash)).(*WarpBlockHash)
	outstruct.Valid = *abi.ConvertType(out[1], new(bool)).(*bool)

	return *outstruct, err

}

// GetVerifiedWarpBlockHash is a free data retrieval call binding the contract method 0xce7f5929.
//
// Solidity: function getVerifiedWarpBlockHash(uint32 index) view returns((bytes32,bytes32) warpBlockHash, bool valid)
func (_IWarpMessenger *IWarpMessengerSession) GetVerifiedWarpBlockHash(index uint32) (struct {
	WarpBlockHash WarpBlockHash
	Valid         bool
}, error) {
	return _IWarpMessenger.Contract.GetVerifiedWarpBlockHash(&_IWarpMessenger.CallOpts, index)
}

// GetVerifiedWarpBlockHash is a free data retrieval call binding the contract method 0xce7f5929.
//
// Solidity: function getVerifiedWarpBlockHash(uint32 index) view returns((bytes32,bytes32) warpBlockHash, bool valid)
func (_IWarpMessenger *IWarpMessengerCallerSession) GetVerifiedWarpBlockHash(index uint32) (struct {
	WarpBlockHash WarpBlockHash
	Valid         bool
}, error) {
	return _IWarpMessenger.Contract.GetVerifiedWarpBlockHash(&_IWarpMessenger.CallOpts, index)
}

// GetVerifiedWarpMessage is a free data retrieval call binding the contract method 0x6f825350.
//
// Solidity: function getVerifiedWarpMessage(uint32 index) view returns((bytes32,address,bytes) message, bool valid)
func (_IWarpMessenger *IWarpMessengerCaller) GetVerifiedWarpMessage(opts *bind.CallOpts, index uint32) (struct {
	Message WarpMessage
	Valid   bool
}, error) {
	var out []interface{}
	err := _IWarpMessenger.contract.Call(opts, &out, "getVerifiedWarpMessage", index)

	outstruct := new(struct {
		Message WarpMessage
		Valid   bool
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Message = *abi.ConvertType(out[0], new(WarpMessage)).(*WarpMessage)
	outstruct.Valid = *abi.ConvertType(out[1], new(bool)).(*bool)

	return *outstruct, err

}

// GetVerifiedWarpMessage is a free data retrieval call binding the contract method 0x6f825350.
//
// Solidity: function getVerifiedWarpMessage(uint32 index) view returns((bytes32,address,bytes) message, bool valid)
func (_IWarpMessenger *IWarpMessengerSession) GetVerifiedWarpMessage(index uint32) (struct {
	Message WarpMessage
	Valid   bool
}, error) {
	return _IWarpMessenger.Contract.GetVerifiedWarpMessage(&_IWarpMessenger.CallOpts, index)
}

// GetVerifiedWarpMessage is a free data retrieval call binding the contract method 0x6f825350.
//
// Solidity: function getVerifiedWarpMessage(uint32 index) view returns((bytes32,address,bytes) message, bool valid)
func (_IWarpMessenger *IWarpMessengerCallerSession) GetVerifiedWarpMessage(index uint32) (struct {
	Message WarpMessage
	Valid   bool
}, error) {
	return _IWarpMessenger.Contract.GetVerifiedWarpMessage(&_IWarpMessenger.CallOpts, index)
}

// SendWarpMessage is a paid mutator transaction binding the contract method 0xee5b48eb.
//
// Solidity: function sendWarpMessage(bytes payload) returns(bytes32 messageID)
func (_IWarpMessenger *IWarpMessengerTransactor) SendWarpMessage(opts *bind.TransactOpts, payload []byte) (*types.Transaction, error) {
	return _IWarpMessenger.contract.Transact(opts, "sendWarpMessage", payload)
}

// SendWarpMessage is a paid mutator transaction binding the contract method 0xee5b48eb.
//
// Solidity: function sendWarpMessage(bytes payload) returns(bytes32 messageID)
func (_IWarpMessenger *IWarpMessengerSession) SendWarpMessage(payload []byte) (*types.Transaction, error) {
	return _IWarpMessenger.Contract.SendWarpMessage(&_IWarpMessenger.TransactOpts, payload)
}

// SendWarpMessage is a paid mutator transaction binding the contract method 0xee5b48eb.
//
// Solidity: function sendWarpMessage(bytes payload) returns(bytes32 messageID)
func (_IWarpMessenger *IWarpMessengerTransactorSession) SendWarpMessage(payload []byte) (*types.Transaction, error) {
	return _IWarpMessenger.Contract.SendWarpMessage(&_IWarpMessenger.TransactOpts, payload)
}

// IWarpMessengerSendWarpMessageIterator is returned from FilterSendWarpMessage and is used to iterate over the raw logs and unpacked data for SendWarpMessage events raised by the IWarpMessenger contract.
type IWarpMessengerSendWarpMessageIterator struct {
	Event *IWarpMessengerSendWarpMessage // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IWarpMessengerSendWarpMessageIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IWarpMessengerSendWarpMessage)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IWarpMessengerSendWarpMessage)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IWarpMessengerSendWarpMessageIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IWarpMessengerSendWarpMessageIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IWarpMessengerSendWarpMessage represents a SendWarpMessage event raised by the IWarpMessenger contract.
type IWarpMessengerSendWarpMessage struct {
	Sender    common.Address
	MessageID [32]byte
	Message   []byte
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterSendWarpMessage is a free log retrieval operation binding the contract event 0x56600c567728a800c0aa927500f831cb451df66a7af570eb4df4dfbf4674887d.
//
// Solidity: event SendWarpMessage(address indexed sender, bytes32 indexed messageID, bytes message)
func (_IWarpMessenger *IWarpMessengerFilterer) FilterSendWarpMessage(opts *bind.FilterOpts, sender []common.Address, messageID [][32]byte) (*IWarpMessengerSendWarpMessageIterator, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}
	var messageIDRule []interface{}
	for _, messageIDItem := range messageID {
		messageIDRule = append(messageIDRule, messageIDItem)
	}

	logs, sub, err := _IWarpMessenger.contract.FilterLogs(opts, "SendWarpMessage", senderRule, messageIDRule)
	if err != nil {
		return nil, err
	}
	return &IWarpMessengerSendWarpMessageIterator{contract: _IWarpMessenger.contract, event: "SendWarpMessage", logs: logs, sub: sub}, nil
}

// WatchSendWarpMessage is a free log subscription operation binding the contract event 0x56600c567728a800c0aa927500f831cb451df66a7af570eb4df4dfbf4674887d.
//
// Solidity: event SendWarpMessage(address indexed sender, bytes32 indexed messageID, bytes message)
func (_IWarpMessenger *IWarpMessengerFilterer) WatchSendWarpMessage(opts *bind.WatchOpts, sink chan<- *IWarpMessengerSendWarpMessage, sender []common.Address, messageID [][32]byte) (event.Subscription, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}
	var messageIDRule []interface{}
	for _, messageIDItem := range messageID {
		messageIDRule = append(messageIDRule, messageIDItem)
	}

	logs, sub, err := _IWarpMessenger.contract.WatchLogs(opts, "SendWarpMessage", senderRule, messageIDRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IWarpMessengerSendWarpMessage)
				if err := _IWarpMessenger.contract.UnpackLog(event, "SendWarpMessage", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSendWarpMessage is a log parse operation binding the contract event 0x56600c567728a800c0aa927500f831cb451df66a7af570eb4df4dfbf4674887d.
//
// Solidity: event SendWarpMessage(address indexed sender, bytes32 indexed messageID, bytes message)
func (_IWarpMessenger *IWarpMessengerFilterer) ParseSendWarpMessage(log types.Log) (*IWarpMessengerSendWarpMessage, error) {
	event := new(IWarpMessengerSendWarpMessage)
	if err := _IWarpMessenger.contract.UnpackLog(event, "SendWarpMessage", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MinterMetaData contains all meta data concerning the Minter contract.
var MinterMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x608060405234801561001057600080fd5b50604051610364380380610364833981810160405281019061003291906100db565b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050610108565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006100a88261007d565b9050919050565b6100b88161009d565b81146100c357600080fd5b50565b6000815190506100d5816100af565b92915050565b6000602082840312156100f1576100f0610078565b5b60006100ff848285016100c6565b91505092915050565b61024d806101176000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80630356b6cd1461003b578063b6b55f2514610057575b600080fd5b610055600480360381019061005091906101c0565b610073565b005b610071600480360381019061006c91906101c0565b610101565b005b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630356b6cd826040518263ffffffff1660e01b81526004016100cc91906101fc565b600060405180830381600087803b1580156100e657600080fd5b505af11580156100fa573d6000803e3d6000fd5b5050505050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d0e30db0826040518263ffffffff1660e01b81526004016000604051808303818588803b15801561016957600080fd5b505af115801561017d573d6000803e3d6000fd5b505050505050565b600080fd5b6000819050919050565b61019d8161018a565b81146101a857600080fd5b50565b6000813590506101ba81610194565b92915050565b6000602082840312156101d6576101d5610185565b5b60006101e4848285016101ab565b91505092915050565b6101f68161018a565b82525050565b600060208201905061021160008301846101ed565b9291505056fea26469706673582212202f7464e4ba0efd60b76b57adf42e37a8cad238848f0b5f4bedc95eeb8b600dd464736f6c634300081a0033",
}

// MinterABI is the input ABI used to generate the binding from.
// Deprecated: Use MinterMetaData.ABI instead.
var MinterABI = MinterMetaData.ABI

// MinterBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use MinterMetaData.Bin instead.
var MinterBin = MinterMetaData.Bin

// DeployMinter deploys a new Ethereum contract, binding an instance of Minter to it.
func DeployMinter(auth *bind.TransactOpts, backend bind.ContractBackend, tokenAddress common.Address) (common.Address, *types.Transaction, *Minter, error) {
	parsed, err := MinterMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(MinterBin), backend, tokenAddress)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Minter{MinterCaller: MinterCaller{contract: contract}, MinterTransactor: MinterTransactor{contract: contract}, MinterFilterer: MinterFilterer{contract: contract}}, nil
}

// Minter is an auto generated Go binding around an Ethereum contract.
type Minter struct {
	MinterCaller     // Read-only binding to the contract
	MinterTransactor // Write-only binding to the contract
	MinterFilterer   // Log filterer for contract events
}

// MinterCaller is an auto generated read-only Go binding around an Ethereum contract.
type MinterCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MinterTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MinterTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MinterFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MinterFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MinterSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MinterSession struct {
	Contract     *Minter           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MinterCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MinterCallerSession struct {
	Contract *MinterCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// MinterTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MinterTransactorSession struct {
	Contract     *MinterTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MinterRaw is an auto generated low-level Go binding around an Ethereum contract.
type MinterRaw struct {
	Contract *Minter // Generic contract binding to access the raw methods on
}

// MinterCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MinterCallerRaw struct {
	Contract *MinterCaller // Generic read-only contract binding to access the raw methods on
}

// MinterTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MinterTransactorRaw struct {
	Contract *MinterTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMinter creates a new instance of Minter, bound to a specific deployed contract.
func NewMinter(address common.Address, backend bind.ContractBackend) (*Minter, error) {
	contract, err := bindMinter(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Minter{MinterCaller: MinterCaller{contract: contract}, MinterTransactor: MinterTransactor{contract: contract}, MinterFilterer: MinterFilterer{contract: contract}}, nil
}

// NewMinterCaller creates a new read-only instance of Minter, bound to a specific deployed contract.
func NewMinterCaller(address common.Address, caller bind.ContractCaller) (*MinterCaller, error) {
	contract, err := bindMinter(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MinterCaller{contract: contract}, nil
}

// NewMinterTransactor creates a new write-only instance of Minter, bound to a specific deployed contract.
func NewMinterTransactor(address common.Address, transactor bind.ContractTransactor) (*MinterTransactor, error) {
	contract, err := bindMinter(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MinterTransactor{contract: contract}, nil
}

// NewMinterFilterer creates a new log filterer instance of Minter, bound to a specific deployed contract.
func NewMinterFilterer(address common.Address, filterer bind.ContractFilterer) (*MinterFilterer, error) {
	contract, err := bindMinter(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MinterFilterer{contract: contract}, nil
}

// bindMinter binds a generic wrapper to an already deployed contract.
func bindMinter(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MinterMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Minter *MinterRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Minter.Contract.MinterCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Minter *MinterRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Minter.Contract.MinterTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Minter *MinterRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Minter.Contract.MinterTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Minter *MinterCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Minter.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Minter *MinterTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Minter.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Minter *MinterTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Minter.Contract.contract.Transact(opts, method, params...)
}

// Deposit is a paid mutator transaction binding the contract method 0xb6b55f25.
//
// Solidity: function deposit(uint256 value) returns()
func (_Minter *MinterTransactor) Deposit(opts *bind.TransactOpts, value *big.Int) (*types.Transaction, error) {
	return _Minter.contract.Transact(opts, "deposit", value)
}

// Deposit is a paid mutator transaction binding the contract method 0xb6b55f25.
//
// Solidity: function deposit(uint256 value) returns()
func (_Minter *MinterSession) Deposit(value *big.Int) (*types.Transaction, error) {
	return _Minter.Contract.Deposit(&_Minter.TransactOpts, value)
}

// Deposit is a paid mutator transaction binding the contract method 0xb6b55f25.
//
// Solidity: function deposit(uint256 value) returns()
func (_Minter *MinterTransactorSession) Deposit(value *big.Int) (*types.Transaction, error) {
	return _Minter.Contract.Deposit(&_Minter.TransactOpts, value)
}

// Mintdraw is a paid mutator transaction binding the contract method 0x0356b6cd.
//
// Solidity: function mintdraw(uint256 amount) returns()
func (_Minter *MinterTransactor) Mintdraw(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error) {
	return _Minter.contract.Transact(opts, "mintdraw", amount)
}

// Mintdraw is a paid mutator transaction binding the contract method 0x0356b6cd.
//
// Solidity: function mintdraw(uint256 amount) returns()
func (_Minter *MinterSession) Mintdraw(amount *big.Int) (*types.Transaction, error) {
	return _Minter.Contract.Mintdraw(&_Minter.TransactOpts, amount)
}

// Mintdraw is a paid mutator transaction binding the contract method 0x0356b6cd.
//
// Solidity: function mintdraw(uint256 amount) returns()
func (_Minter *MinterTransactorSession) Mintdraw(amount *big.Int) (*types.Transaction, error) {
	return _Minter.Contract.Mintdraw(&_Minter.TransactOpts, amount)
}

// OwnableMetaData contains all meta data concerning the Ownable contract.
var OwnableMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// OwnableABI is the input ABI used to generate the binding from.
// Deprecated: Use OwnableMetaData.ABI instead.
var OwnableABI = OwnableMetaData.ABI

// Ownable is an auto generated Go binding around an Ethereum contract.
type Ownable struct {
	OwnableCaller     // Read-only binding to the contract
	OwnableTransactor // Write-only binding to the contract
	OwnableFilterer   // Log filterer for contract events
}

// OwnableCaller is an auto generated read-only Go binding around an Ethereum contract.
type OwnableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnableTransactor is an auto generated write-only Go binding around an Ethereum contract.
type OwnableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnableFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type OwnableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnableSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type OwnableSession struct {
	Contract     *Ownable          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// OwnableCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type OwnableCallerSession struct {
	Contract *OwnableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// OwnableTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type OwnableTransactorSession struct {
	Contract     *OwnableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// OwnableRaw is an auto generated low-level Go binding around an Ethereum contract.
type OwnableRaw struct {
	Contract *Ownable // Generic contract binding to access the raw methods on
}

// OwnableCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type OwnableCallerRaw struct {
	Contract *OwnableCaller // Generic read-only contract binding to access the raw methods on
}

// OwnableTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type OwnableTransactorRaw struct {
	Contract *OwnableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewOwnable creates a new instance of Ownable, bound to a specific deployed contract.
func NewOwnable(address common.Address, backend bind.ContractBackend) (*Ownable, error) {
	contract, err := bindOwnable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Ownable{OwnableCaller: OwnableCaller{contract: contract}, OwnableTransactor: OwnableTransactor{contract: contract}, OwnableFilterer: OwnableFilterer{contract: contract}}, nil
}

// NewOwnableCaller creates a new read-only instance of Ownable, bound to a specific deployed contract.
func NewOwnableCaller(address common.Address, caller bind.ContractCaller) (*OwnableCaller, error) {
	contract, err := bindOwnable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &OwnableCaller{contract: contract}, nil
}

// NewOwnableTransactor creates a new write-only instance of Ownable, bound to a specific deployed contract.
func NewOwnableTransactor(address common.Address, transactor bind.ContractTransactor) (*OwnableTransactor, error) {
	contract, err := bindOwnable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &OwnableTransactor{contract: contract}, nil
}

// NewOwnableFilterer creates a new log filterer instance of Ownable, bound to a specific deployed contract.
func NewOwnableFilterer(address common.Address, filterer bind.ContractFilterer) (*OwnableFilterer, error) {
	contract, err := bindOwnable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &OwnableFilterer{contract: contract}, nil
}

// bindOwnable binds a generic wrapper to an already deployed contract.
func bindOwnable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := OwnableMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Ownable *OwnableRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Ownable.Contract.OwnableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Ownable *OwnableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Ownable.Contract.OwnableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Ownable *OwnableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Ownable.Contract.OwnableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Ownable *OwnableCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Ownable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Ownable *OwnableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Ownable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Ownable *OwnableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Ownable.Contract.contract.Transact(opts, method, params...)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Ownable *OwnableCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Ownable.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Ownable *OwnableSession) Owner() (common.Address, error) {
	return _Ownable.Contract.Owner(&_Ownable.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Ownable *OwnableCallerSession) Owner() (common.Address, error) {
	return _Ownable.Contract.Owner(&_Ownable.CallOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_Ownable *OwnableTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Ownable.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_Ownable *OwnableSession) RenounceOwnership() (*types.Transaction, error) {
	return _Ownable.Contract.RenounceOwnership(&_Ownable.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_Ownable *OwnableTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _Ownable.Contract.RenounceOwnership(&_Ownable.TransactOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Ownable *OwnableTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _Ownable.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Ownable *OwnableSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _Ownable.Contract.TransferOwnership(&_Ownable.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Ownable *OwnableTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _Ownable.Contract.TransferOwnership(&_Ownable.TransactOpts, newOwner)
}

// OwnableOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the Ownable contract.
type OwnableOwnershipTransferredIterator struct {
	Event *OwnableOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log          // Log channel receiving the found contract events
	sub  interfaces.Subscription // Subscription for errors, completion and termination
	done bool                    // Whether the subscription completed delivering logs
	fail error                   // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OwnableOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OwnableOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OwnableOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OwnableOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OwnableOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OwnableOwnershipTransferred represents a OwnershipTransferred event raised by the Ownable contract.
type OwnableOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Ownable *OwnableFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*OwnableOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Ownable.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &OwnableOwnershipTransferredIterator{contract: _Ownable.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Ownable *OwnableFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *OwnableOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Ownable.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OwnableOwnershipTransferred)
				if err := _Ownable.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Ownable *OwnableFilterer) ParseOwnershipTransferred(log types.Log) (*OwnableOwnershipTransferred, error) {
	event := new(OwnableOwnershipTransferred)
	if err := _Ownable.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

