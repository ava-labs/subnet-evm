// Code generated
// This file is a generated precompile contract test with the skeleton of test functions.
// The file is generated by a template. Please inspect every code and comment in this file before use.

package juror

import (
	"math/big"

	"testing"

	ob "github.com/ava-labs/subnet-evm/plugin/evm/orderbook"
	hu "github.com/ava-labs/subnet-evm/plugin/evm/orderbook/hubbleutils"
	"github.com/ethereum/go-ethereum/common"
	"github.com/stretchr/testify/assert"

	b "github.com/ava-labs/subnet-evm/precompile/contracts/bibliophile"
	gomock "github.com/golang/mock/gomock"
)

func TestValidateLimitOrderLike(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockBibliophile := b.NewMockBibliophileClient(ctrl)

	trader := common.HexToAddress("0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC")
	order := &ob.BaseOrder{
		AmmIndex:          big.NewInt(0),
		Trader:            trader,
		BaseAssetQuantity: big.NewInt(10),
		Price:             big.NewInt(20),
		Salt:              big.NewInt(1),
		ReduceOnly:        false,
	}
	filledAmount := big.NewInt(5)
	fillAmount := big.NewInt(5)

	t.Run("Side=Long", func(t *testing.T) {
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(gomock.Any()).Return(common.Address{}).AnyTimes()
		t.Run("OrderStatus != Placed will throw error", func(t *testing.T) {
			err := validateLimitOrderLike(mockBibliophile, order, filledAmount, Invalid, Long, fillAmount)
			assert.EqualError(t, err, ErrInvalidOrder.Error())

			err = validateLimitOrderLike(mockBibliophile, order, filledAmount, Filled, Long, fillAmount)
			assert.EqualError(t, err, ErrInvalidOrder.Error())

			err = validateLimitOrderLike(mockBibliophile, order, filledAmount, Cancelled, Long, fillAmount)
			assert.EqualError(t, err, ErrInvalidOrder.Error())
		})

		t.Run("base asset quantity <= 0", func(t *testing.T) {
			badOrder := *order
			badOrder.BaseAssetQuantity = big.NewInt(-23)

			err := validateLimitOrderLike(mockBibliophile, &badOrder, filledAmount, Placed, Long, fillAmount)
			assert.EqualError(t, err, ErrNotLongOrder.Error())

			badOrder.BaseAssetQuantity = big.NewInt(0)
			err = validateLimitOrderLike(mockBibliophile, &badOrder, filledAmount, Placed, Long, fillAmount)
			assert.EqualError(t, err, ErrNotLongOrder.Error())
		})

		t.Run("ErrOverFill", func(t *testing.T) {
			fillAmount := big.NewInt(6)

			err := validateLimitOrderLike(mockBibliophile, order, filledAmount, Placed, Long, fillAmount)
			assert.EqualError(t, err, ErrOverFill.Error())
		})

		t.Run("ErrReduceOnlyAmountExceeded", func(t *testing.T) {
			badOrder := *order
			badOrder.ReduceOnly = true

			for i := int64(10); /* any +ve # */ i > new(big.Int).Neg(fillAmount).Int64(); i-- {
				mockBibliophile.EXPECT().GetSize(gomock.Any(), gomock.Any()).Return(big.NewInt(i)).Times(1)
				err := validateLimitOrderLike(mockBibliophile, &badOrder, filledAmount, Placed, Long, fillAmount)
				assert.EqualError(t, err, ErrReduceOnlyAmountExceeded.Error())
			}
		})

		t.Run("all conditions met for reduceOnly order", func(t *testing.T) {
			badOrder := *order
			badOrder.ReduceOnly = true

			start := new(big.Int).Neg(fillAmount).Int64()
			for i := start; i > start-5; i-- {
				mockBibliophile.EXPECT().GetSize(gomock.Any(), gomock.Any()).Return(big.NewInt(i)).Times(1)
				err := validateLimitOrderLike(mockBibliophile, &badOrder, filledAmount, Placed, Long, fillAmount)
				assert.Nil(t, err)
			}
		})

		t.Run("all conditions met", func(t *testing.T) {
			err := validateLimitOrderLike(mockBibliophile, order, filledAmount, Placed, Long, fillAmount)
			assert.Nil(t, err)
		})
	})

	t.Run("Side=Short", func(t *testing.T) {
		order := &ob.BaseOrder{
			AmmIndex:          big.NewInt(0),
			Trader:            trader,
			BaseAssetQuantity: big.NewInt(-10),
			Price:             big.NewInt(20),
			Salt:              big.NewInt(1),
			ReduceOnly:        false,
		}
		filledAmount := big.NewInt(-5)
		fillAmount := big.NewInt(-5)
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(gomock.Any()).Return(common.Address{}).AnyTimes()
		t.Run("OrderStatus != Placed will throw error", func(t *testing.T) {
			err := validateLimitOrderLike(mockBibliophile, order, filledAmount, Invalid, Short, fillAmount)
			assert.EqualError(t, err, ErrInvalidOrder.Error())

			err = validateLimitOrderLike(mockBibliophile, order, filledAmount, Filled, Short, fillAmount)
			assert.EqualError(t, err, ErrInvalidOrder.Error())

			err = validateLimitOrderLike(mockBibliophile, order, filledAmount, Cancelled, Short, fillAmount)
			assert.EqualError(t, err, ErrInvalidOrder.Error())
		})

		t.Run("base asset quantity >= 0", func(t *testing.T) {
			badOrder := *order
			badOrder.BaseAssetQuantity = big.NewInt(23)

			err := validateLimitOrderLike(mockBibliophile, &badOrder, filledAmount, Placed, Short, fillAmount)
			assert.EqualError(t, err, ErrNotShortOrder.Error())

			badOrder.BaseAssetQuantity = big.NewInt(0)
			err = validateLimitOrderLike(mockBibliophile, &badOrder, filledAmount, Placed, Short, fillAmount)
			assert.EqualError(t, err, ErrNotShortOrder.Error())
		})

		t.Run("ErrOverFill", func(t *testing.T) {
			fillAmount := big.NewInt(-6)

			err := validateLimitOrderLike(mockBibliophile, order, filledAmount, Placed, Short, fillAmount)
			assert.EqualError(t, err, ErrOverFill.Error())
		})

		t.Run("ErrReduceOnlyAmountExceeded", func(t *testing.T) {
			badOrder := *order
			badOrder.ReduceOnly = true

			for i := int64(-10); /* any -ve # */ i < new(big.Int).Abs(fillAmount).Int64(); i++ {
				mockBibliophile.EXPECT().GetSize(gomock.Any(), gomock.Any()).Return(big.NewInt(i)).Times(1)
				err := validateLimitOrderLike(mockBibliophile, &badOrder, filledAmount, Placed, Short, fillAmount)
				assert.EqualError(t, err, ErrReduceOnlyAmountExceeded.Error())
			}
		})

		t.Run("all conditions met for reduceOnly order", func(t *testing.T) {
			badOrder := *order
			badOrder.ReduceOnly = true

			start := new(big.Int).Abs(fillAmount).Int64()
			for i := start; i < start+5; i++ {
				mockBibliophile.EXPECT().GetSize(gomock.Any(), gomock.Any()).Return(big.NewInt(i)).Times(1)
				err := validateLimitOrderLike(mockBibliophile, &badOrder, filledAmount, Placed, Short, fillAmount)
				assert.Nil(t, err)
			}
		})

		t.Run("all conditions met", func(t *testing.T) {
			err := validateLimitOrderLike(mockBibliophile, order, filledAmount, Placed, Short, fillAmount)
			assert.Nil(t, err)
		})
	})

	t.Run("invalid side", func(t *testing.T) {
		order := &ob.BaseOrder{
			AmmIndex:          big.NewInt(0),
			Trader:            trader,
			BaseAssetQuantity: big.NewInt(10),
			Price:             big.NewInt(20),
			Salt:              big.NewInt(1),
			ReduceOnly:        false,
		}
		filledAmount := big.NewInt(0)
		fillAmount := big.NewInt(5)

		err := validateLimitOrderLike(mockBibliophile, order, filledAmount, Placed, Side(4), fillAmount) // assuming 4 is an invalid Side value
		assert.EqualError(t, err, "invalid side")
	})
}

func TestValidateExecuteLimitOrder(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockBibliophile := b.NewMockBibliophileClient(ctrl)
	marketAddress := common.HexToAddress("0xa72b463C21dA61cCc86069cFab82e9e8491152a0")
	trader := common.HexToAddress("0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC")

	order := &ob.LimitOrder{
		BaseOrder: ob.BaseOrder{
			AmmIndex:          big.NewInt(534),
			Trader:            trader,
			BaseAssetQuantity: big.NewInt(10),
			Price:             big.NewInt(20),
			Salt:              big.NewInt(1),
			ReduceOnly:        false,
		},
		PostOnly: false,
	}
	filledAmount := big.NewInt(5)
	fillAmount := big.NewInt(5)

	t.Run("validateExecuteLimitOrder", func(t *testing.T) {
		orderHash, err := order.Hash()
		assert.Nil(t, err)

		blockPlaced := big.NewInt(42)
		mockBibliophile.EXPECT().GetOrderFilledAmount(orderHash).Return(filledAmount).Times(1)
		mockBibliophile.EXPECT().GetOrderStatus(orderHash).Return(int64(1)).Times(1)                                 // placed
		mockBibliophile.EXPECT().GetBlockPlaced(orderHash).Return(blockPlaced).Times(1)                              // placed
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order.AmmIndex.Int64()).Return(marketAddress).Times(1) // placed

		m, err := validateExecuteLimitOrder(mockBibliophile, order, Long, fillAmount, orderHash)
		assert.Nil(t, err)
		assertMetadataEquality(t, &Metadata{
			AmmIndex:          new(big.Int).Set(order.AmmIndex),
			Trader:            trader,
			BaseAssetQuantity: new(big.Int).Set(order.BaseAssetQuantity),
			BlockPlaced:       blockPlaced,
			Price:             new(big.Int).Set(order.Price),
			OrderHash:         orderHash,
		}, m)
	})
}

func assertMetadataEquality(t *testing.T, expected, actual *Metadata) {
	assert.Equal(t, expected.AmmIndex.Int64(), actual.AmmIndex.Int64())
	assert.Equal(t, expected.Trader, actual.Trader)
	assert.Equal(t, expected.BaseAssetQuantity, actual.BaseAssetQuantity)
	assert.Equal(t, expected.BlockPlaced, actual.BlockPlaced)
	assert.Equal(t, expected.Price, actual.Price)
	assert.Equal(t, expected.OrderHash, actual.OrderHash)
}

func TestDetermineFillPrice(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockBibliophile := b.NewMockBibliophileClient(ctrl)

	oraclePrice := hu.Mul1e6(big.NewInt(20))                                                               // $10
	spreadLimit := new(big.Int).Mul(big.NewInt(50), big.NewInt(1e4))                                       // 50%
	upperbound := hu.Div1e6(new(big.Int).Mul(oraclePrice, new(big.Int).Add(big.NewInt(1e6), spreadLimit))) // $10
	lowerbound := hu.Div1e6(new(big.Int).Mul(oraclePrice, new(big.Int).Sub(big.NewInt(1e6), spreadLimit))) // $30
	market := int64(5)

	t.Run("long order came first", func(t *testing.T) {
		blockPlaced0 := big.NewInt(69)
		blockPlaced1 := big.NewInt(70)
		t.Run("long price < lower bound", func(t *testing.T) {
			t.Run("short price < long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       hu.Mul1e6(big.NewInt(9)),
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       hu.Mul1e6(big.NewInt(8)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, output)
				assert.Equal(t, ErrTooLow, err)
			})

			t.Run("short price == long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       hu.Mul1e6(big.NewInt(7)),
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       hu.Mul1e6(big.NewInt(7)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, output)
				assert.Equal(t, ErrTooLow, err)
			})
		})

		t.Run("long price == lower bound", func(t *testing.T) {
			longPrice := lowerbound
			t.Run("short price < long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       new(big.Int).Sub(longPrice, big.NewInt(1)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})

			t.Run("short price == long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       longPrice,
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})
		})

		t.Run("lowerbound < long price < oracle", func(t *testing.T) {
			longPrice := hu.Mul1e6(big.NewInt(15))
			t.Run("short price < long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       new(big.Int).Sub(longPrice, big.NewInt(1)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})

			t.Run("short price == long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       longPrice,
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})
		})

		t.Run("long price == oracle", func(t *testing.T) {
			longPrice := oraclePrice
			t.Run("short price < long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       new(big.Int).Sub(longPrice, big.NewInt(1)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})

			t.Run("short price == long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       longPrice,
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})
		})

		t.Run("oracle < long price < upper bound", func(t *testing.T) {
			longPrice := hu.Mul1e6(big.NewInt(25))
			t.Run("short price < long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       new(big.Int).Sub(longPrice, big.NewInt(1)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})

			t.Run("short price == long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       longPrice,
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})
		})

		t.Run("long price == upper bound", func(t *testing.T) {
			longPrice := upperbound
			t.Run("short price < long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       new(big.Int).Sub(longPrice, big.NewInt(1)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})

			t.Run("short price == long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       longPrice,
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})
		})

		t.Run("upper bound < long price", func(t *testing.T) {
			longPrice := new(big.Int).Add(upperbound, big.NewInt(42))
			t.Run("upper < short price < long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       new(big.Int).Add(upperbound, big.NewInt(1)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, output)
				assert.Equal(t, ErrTooHigh, err)
			})

			t.Run("upper == short price < long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       upperbound,
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{upperbound, Maker, Taker}, *output)
			})

			t.Run("short price < upper", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       new(big.Int).Sub(upperbound, big.NewInt(1)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{upperbound, Maker, Taker}, *output)
			})

			t.Run("short price < lower", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       new(big.Int).Sub(lowerbound, big.NewInt(1)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{upperbound, Maker, Taker}, *output)
			})
		})
	})
}

func TestDetermineLiquidationFillPrice(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockBibliophile := b.NewMockBibliophileClient(ctrl)

	liqUpperBound, liqLowerBound := hu.Mul1e6(big.NewInt(22)), hu.Mul1e6(big.NewInt(18))

	upperbound := hu.Mul1e6(big.NewInt(30)) // $30
	lowerbound := hu.Mul1e6(big.NewInt(10)) // $10
	market := int64(7)

	t.Run("long position is being liquidated", func(t *testing.T) {
		t.Run("order price < liqLowerBound", func(t *testing.T) {
			m0 := &Metadata{
				Price:             new(big.Int).Sub(liqLowerBound, big.NewInt(1)),
				BaseAssetQuantity: big.NewInt(5),
				AmmIndex:          big.NewInt(market),
			}
			mockBibliophile.EXPECT().GetAcceptableBoundsForLiquidation(market).Return(liqUpperBound, liqLowerBound).Times(1)
			mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
			output, err := determineLiquidationFillPrice(mockBibliophile, m0)
			assert.Nil(t, output)
			assert.Equal(t, ErrTooLow, err)
		})
		t.Run("order price == liqLowerBound", func(t *testing.T) {
			m0 := &Metadata{
				Price:             liqLowerBound,
				BaseAssetQuantity: big.NewInt(5),
				AmmIndex:          big.NewInt(market),
			}
			mockBibliophile.EXPECT().GetAcceptableBoundsForLiquidation(market).Return(liqUpperBound, liqLowerBound).Times(1)
			mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
			output, err := determineLiquidationFillPrice(mockBibliophile, m0)
			assert.Nil(t, err)
			assert.Equal(t, liqLowerBound, output)
		})

		t.Run("liqLowerBound < order price < upper bound", func(t *testing.T) {
			m0 := &Metadata{
				Price:             new(big.Int).Add(liqLowerBound, big.NewInt(99)),
				BaseAssetQuantity: big.NewInt(5),
				AmmIndex:          big.NewInt(market),
			}
			mockBibliophile.EXPECT().GetAcceptableBoundsForLiquidation(market).Return(liqUpperBound, liqLowerBound).Times(1)
			mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
			output, err := determineLiquidationFillPrice(mockBibliophile, m0)
			assert.Nil(t, err)
			assert.Equal(t, m0.Price, output)
		})

		t.Run("order price == upper bound", func(t *testing.T) {
			m0 := &Metadata{
				Price:             upperbound,
				BaseAssetQuantity: big.NewInt(5),
				AmmIndex:          big.NewInt(market),
			}
			mockBibliophile.EXPECT().GetAcceptableBoundsForLiquidation(market).Return(liqUpperBound, liqLowerBound).Times(1)
			mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
			output, err := determineLiquidationFillPrice(mockBibliophile, m0)
			assert.Nil(t, err)
			assert.Equal(t, upperbound, output)
		})

		t.Run("order price > upper bound", func(t *testing.T) {
			m0 := &Metadata{
				Price:             new(big.Int).Add(upperbound, big.NewInt(99)),
				BaseAssetQuantity: big.NewInt(5),
				AmmIndex:          big.NewInt(market),
			}
			mockBibliophile.EXPECT().GetAcceptableBoundsForLiquidation(market).Return(liqUpperBound, liqLowerBound).Times(1)
			mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
			output, err := determineLiquidationFillPrice(mockBibliophile, m0)
			assert.Nil(t, err)
			assert.Equal(t, upperbound, output)
		})
	})
}
