// Code generated
// This file is a generated precompile contract config with stubbed abstract functions.
// The file is generated by a template. Please inspect every code and comment in this file before use.

package blocklist

import (
	"math/big"

	"github.com/ava-labs/libevm/common"
	"github.com/ava-labs/subnet-evm/precompile/contract"
)

// CUSTOM CODE STARTS HERE
// Reference imports to suppress errors from unused imports. This code and any unnecessary imports can be removed.
var (
	_ = big.NewInt
	_ = common.Big0
	_ = contract.LogGas
)

/* NOTE: Events can only be emitted in state-changing functions. So you cannot use events in read-only (view) functions.
Events are generally emitted at the end of a state-changing function with AddLog method of the StateDB. The AddLog method takes 4 arguments:
	1. Address of the contract that emitted the event.
	2. Topic hashes of the event.
	3. Encoded non-indexed data of the event.
	4. Block number at which the event was emitted.
The first argument is the address of the contract that emitted the event.
Topics can be at most 4 elements, the first topic is the hash of the event signature and the rest are the indexed event arguments. There can be at most 3 indexed arguments.
Topics cannot be fully unpacked into their original values since they're 32-bytes hashes.
The non-indexed arguments are encoded using the ABI encoding scheme. The non-indexed arguments can be unpacked into their original values.
Before packing the event, you need to calculate the gas cost of the event. The gas cost of an event is the base gas cost + the gas cost of the topics + the gas cost of the non-indexed data.
See Get{EvetName}EventGasCost functions for more details.
You can use the following code to emit an event in your state-changing precompile functions (generated packer might be different)):
topics, data, err := PackMyEvent(
	topic1,
	topic2,
	data1,
	data2,
)
if err != nil {
	return nil, remainingGas, err
}
accessibleState.GetStateDB().AddLog(
	ContractAddress,
	topics,
	data,
	accessibleState.GetBlockContext().Number().Uint64(),
)
*/

// BlockListAddressBlocked represents a AddressBlocked non-indexed event data raised by the BlockList contract.
type AddressBlockedEventData struct {
	Reason string
}

// GetAddressBlockedEventGasCost returns the gas cost of the event.
// The gas cost of an event is the base gas cost + the gas cost of the topics + the gas cost of the non-indexed data.
// The base gas cost and the gas cost of per topics are fixed and can be found in the contract package.
// The gas cost of the non-indexed data depends on the data type and the data size.
func GetAddressBlockedEventGasCost(data AddressBlockedEventData) uint64 {
	gas := contract.LogGas // base gas cost

	// Add topics gas cost (2 topics)
	// Topics always include the signature hash of the event. The rest are the indexed event arguments.
	gas += contract.LogTopicGas * 2

	// CUSTOM CODE STARTS HERE
	// TODO: calculate gas cost for packing the data.reason according to the type.
	// Keep in mind that the data here will be encoded using the ABI encoding scheme.
	// So the computation cost might change according to the data type + data size and should be charged accordingly.
	// i.e gas += LogDataGas * uint64(len(data.reason))
	gas += contract.LogDataGas // * ...
	// CUSTOM CODE ENDS HERE

	// CUSTOM CODE STARTS HERE
	// TODO: do any additional gas cost calculation here (only if needed)
	return gas
}

// PackAddressBlockedEvent packs the event into the appropriate arguments for AddressBlocked.
// It returns topic hashes and the encoded non-indexed data.
func PackAddressBlockedEvent(account common.Address, data AddressBlockedEventData) ([]common.Hash, []byte, error) {
	return BlockListABI.PackEvent("AddressBlocked", account, data.Reason)
}

// UnpackAddressBlockedEventData attempts to unpack non-indexed [dataBytes].
func UnpackAddressBlockedEventData(dataBytes []byte) (AddressBlockedEventData, error) {
	eventData := AddressBlockedEventData{}
	err := BlockListABI.UnpackIntoInterface(&eventData, "AddressBlocked", dataBytes)
	return eventData, err
}

// BlockListAddressUnblocked represents a AddressUnblocked non-indexed event data raised by the BlockList contract.
type AddressUnblockedEventData struct {
	Reason string
}

// GetAddressUnblockedEventGasCost returns the gas cost of the event.
// The gas cost of an event is the base gas cost + the gas cost of the topics + the gas cost of the non-indexed data.
// The base gas cost and the gas cost of per topics are fixed and can be found in the contract package.
// The gas cost of the non-indexed data depends on the data type and the data size.
func GetAddressUnblockedEventGasCost(data AddressUnblockedEventData) uint64 {
	gas := contract.LogGas // base gas cost

	// Add topics gas cost (2 topics)
	// Topics always include the signature hash of the event. The rest are the indexed event arguments.
	gas += contract.LogTopicGas * 2

	// CUSTOM CODE STARTS HERE
	// TODO: calculate gas cost for packing the data.reason according to the type.
	// Keep in mind that the data here will be encoded using the ABI encoding scheme.
	// So the computation cost might change according to the data type + data size and should be charged accordingly.
	// i.e gas += LogDataGas * uint64(len(data.reason))
	gas += contract.LogDataGas // * ...
	// CUSTOM CODE ENDS HERE

	// CUSTOM CODE STARTS HERE
	// TODO: do any additional gas cost calculation here (only if needed)
	return gas
}

// PackAddressUnblockedEvent packs the event into the appropriate arguments for AddressUnblocked.
// It returns topic hashes and the encoded non-indexed data.
func PackAddressUnblockedEvent(account common.Address, data AddressUnblockedEventData) ([]common.Hash, []byte, error) {
	return BlockListABI.PackEvent("AddressUnblocked", account, data.Reason)
}

// UnpackAddressUnblockedEventData attempts to unpack non-indexed [dataBytes].
func UnpackAddressUnblockedEventData(dataBytes []byte) (AddressUnblockedEventData, error) {
	eventData := AddressUnblockedEventData{}
	err := BlockListABI.UnpackIntoInterface(&eventData, "AddressUnblocked", dataBytes)
	return eventData, err
}

// GetAdminChangedEventGasCost returns the gas cost of the event.
// The gas cost of an event is the base gas cost + the gas cost of the topics + the gas cost of the non-indexed data.
// The base gas cost and the gas cost of per topics are fixed and can be found in the contract package.
// The gas cost of the non-indexed data depends on the data type and the data size.
func GetAdminChangedEventGasCost() uint64 {
	gas := contract.LogGas // base gas cost

	// Add topics gas cost (2 topics)
	// Topics always include the signature hash of the event. The rest are the indexed event arguments.
	gas += contract.LogTopicGas * 2

	// CUSTOM CODE STARTS HERE
	// TODO: do any additional gas cost calculation here (only if needed)
	return gas
}

// PackAdminChangedEvent packs the event into the appropriate arguments for AdminChanged.
// It returns topic hashes and the encoded non-indexed data.
func PackAdminChangedEvent(account common.Address) ([]common.Hash, []byte, error) {
	return BlockListABI.PackEvent("AdminChanged", account)
}

// UnpackAdminChangedEvent won't be generated because the event does not have any non-indexed data.
